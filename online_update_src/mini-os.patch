diff -Nru xen-4.2.1-new/extras/mini-os/\ xen-4.2.1/extras/mini-os/\
--- xen-4.2.1-new/extras/mini-os/\	2015-10-26 10:34:49.363009999 +0800
+++ xen-4.2.1/extras/mini-os/\	1970-01-01 07:00:00.000000000 +0700
@@ -1,472 +0,0 @@
-/*
- * POSIX-compatible main layer
- *
- * Samuel Thibault <Samuel.Thibault@eu.citrix.net>, October 2007
- */
-
-#ifdef HAVE_LIBC
-#include <os.h>
-#include <sched.h>
-#include <console.h>
-#include <netfront.h>
-#include <pcifront.h>
-#include <time.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <xenbus.h>
-#include <events.h>
-#include <netinet/in.h>
-#include <sys/types.h>
-#include <sys/socket.h>
-#include <arpa/inet.h>
-#include <string.h>
-
-
-extern int main(int argc, char *argv[], char *envp[]);
-extern void __libc_init_array(void);
-extern void __libc_fini_array(void);
-extern unsigned long __CTOR_LIST__[];
-extern unsigned long __DTOR_LIST__[];
-
-#if 0
-#include <stdio.h>
-int main(int argc, char *argv[], char *envp[])
-{
-    printf("Hello, World!\n");
-    return 1;
-}
-#endif
-
-void _init(void)
-{
-}
-
-void _fini(void)
-{
-}
-
-extern char __app_bss_start, __app_bss_end;
-static void call_main(void *p)
-{
-    char *c, quote;
-#ifdef CONFIG_QEMU_XS_ARGS
-    char *domargs, *msg;
-#endif
-    int argc;
-    char **argv;
-    char *envp[] = { NULL };
-#ifdef CONFIG_QEMU_XS_ARGS
-    char *vm;
-    char path[128];
-    int domid;
-#endif
-    int i;
-
-    /* Let other parts initialize (including console output) before maybe
-     * crashing. */
-    //sleep(1);
-
-#ifdef CONFIG_SPARSE_BSS
-    sparse((unsigned long) &__app_bss_start, &__app_bss_end - &__app_bss_start);
-#endif
-#if defined(HAVE_LWIP) && defined(CONFIG_START_NETWORK) && defined(CONFIG_NETFRONT)
-    start_networking();
-#endif
-#ifdef CONFIG_PCIFRONT
-    create_thread("pcifront", pcifront_watches, NULL);
-#endif
-
-#ifdef CONFIG_QEMU_XS_ARGS
-    /* Fetch argc, argv from XenStore */
-    domid = xenbus_read_integer("target");
-    if (domid == -1) {
-        printk("Couldn't read target\n");
-        do_exit();
-    }
-
-    snprintf(path, sizeof(path), "/local/domain/%d/vm", domid);
-    msg = xenbus_read(XBT_NIL, path, &vm);
-    if (msg) {
-        printk("Couldn't read vm path\n");
-        do_exit();
-    }
-    printk("dom vm is at %s\n", vm);
-
-    snprintf(path, sizeof(path), "%s/image/dmargs", vm);
-    free(vm);
-    msg = xenbus_read(XBT_NIL, path, &domargs);
-
-    if (msg) {
-        printk("Couldn't get stubdom args: %s\n", msg);
-        domargs = strdup("");
-    }
-#endif
-
-    argc = 1;
-
-#define PARSE_ARGS(ARGS,START,QUOTE,END) \
-    c = ARGS; \
-    quote = 0; \
-    while (*c) { \
-	if (*c != ' ') { \
-	    START; \
-	    while (*c) { \
-		if (quote) { \
-		    if (*c == quote) { \
-			quote = 0; \
-			QUOTE; \
-			continue; \
-		    } \
-		} else if (*c == ' ') \
-		    break; \
-		if (*c == '"' || *c == '\'') { \
-		    quote = *c; \
-		    QUOTE; \
-		    continue; \
-		} \
-		c++; \
-	    } \
-	} else { \
-            END; \
-	    while (*c == ' ') \
-		c++; \
-	} \
-    } \
-    if (quote) {\
-	printk("Warning: unterminated quotation %c\n", quote); \
-	quote = 0; \
-    }
-#define PARSE_ARGS_COUNT(ARGS) PARSE_ARGS(ARGS, argc++, c++, )
-#define PARSE_ARGS_STORE(ARGS) PARSE_ARGS(ARGS, argv[argc++] = c, memmove(c, c + 1, strlen(c + 1) + 1), *c++ = 0)
-
-    PARSE_ARGS_COUNT((char*)start_info.cmd_line);
-#ifdef CONFIG_QEMU_XS_ARGS
-    PARSE_ARGS_COUNT(domargs);
-#endif
-
-    argv = alloca((argc + 1) * sizeof(char *));
-    argv[0] = "main";
-    argc = 1;
-
-    PARSE_ARGS_STORE((char*)start_info.cmd_line)
-#ifdef CONFIG_QEMU_XS_ARGS
-    PARSE_ARGS_STORE(domargs)
-#endif
-
-    argv[argc] = NULL;
-
-    for (i = 0; i < argc; i++)
-	printf("\"%s\" ", argv[i]);
-    printf("\n");
-
-    __libc_init_array();
-    environ = envp;
-    for (i = 0; __CTOR_LIST__[i] != 0; i++)
-        ((void((*)(void)))__CTOR_LIST__[i]) ();
-    tzset();
-
-    exit(main(argc, argv, envp));
-}
-
-void _exit(int ret)
-{
-    int i;
-
-    for (i = 0; __DTOR_LIST__[i] != 0; i++)
-        ((void((*)(void)))__DTOR_LIST__[i]) ();
-    close_all_files();
-    __libc_fini_array();
-    printk("main returned %d\n", ret);
-#if defined(HAVE_LWIP) && defined(CONFIG_NETFRONT)
-    stop_networking();
-#endif
-    stop_kernel();
-    if (!ret) {
-	/* No problem, just shutdown.  */
-        struct sched_shutdown sched_shutdown = { .reason = SHUTDOWN_poweroff };
-        HYPERVISOR_sched_op(SCHEDOP_shutdown, &sched_shutdown);
-    }
-    do_exit();
-}
-int htoi(char s[])
-{
-    int n = 0;
-    int i = 0;
-    while (s[i] != '\0' && s[i] != '\n') {
-        if (s[i] == '0') {
-            if (s[i+1] == 'x' || s[i+1] == 'X')
-                            i+=2;
-        }
-        if (s[i] >= '0' && s[i] <= '9') {
-            n = n * 16 + (s[i] - '0');
-        } else if (s[i] >= 'a' && s[i] <= 'f') {
-            n = n * 16 + (s[i] - 'a') + 10;
-        } else if (s[i] >= 'A' && s[i] <= 'F') {
-            n = n * 16 + (s[i] - 'A') + 10;
-        } else
-            return -1;
-        ++i;
-    }
-    return n;
-}
-unsigned long *gots;
-unsigned long *gotm = (unsigned long *)(0x9a540);
-
-void update_minios_parse_sym(void)
-{
-	/*write moduleID to dom0*/
-	int domid;
-	char path[128];
-	char value[10];
-	char *msg, *realaddr;
-
-	domid = xenbus_read_integer("domid");
-	snprintf(path, sizeof(path), "/local/domain/%d/console/mid", domid);
-	sprintf(value, "%p", gotm[1]);
-	xenbus_write(0, path, value);
-	//gotm[3] = (unsigned long)0xdf1a0;	
-	snprintf(path, sizeof(path), "/local/domain/%d/console/realaddr", domid);
-	msg = xenbus_read(XBT_NIL, path, &realaddr);
-	if (msg)
-		printk("Could not read realaddr!\n");
-	gotm[3] = (unsigned long)(0xdf000+htoi(realaddr));
-}
-
-void update_sotest_parse_sym(void)
-{
-	int domid, count1, i;	
-	char path[128];
-	char *msg, *val_count, *realaddr;
-
-	domid = xenbus_read_integer("domid");
-	snprintf(path, sizeof(path), "/local/domain/%d/console/count1", domid);
-	msg = xenbus_read(XBT_NIL, path, &val_count);
-	count1 = atoi(val_count);
-
-	for (i=0; i<count1; i++){
-		snprintf(path, sizeof(path), "/local/domain/%d/console/addr1_%d", domid, i);
-		msg = xenbus_read(XBT_NIL, path, &realaddr);
-		if (msg)
-			printk("Could not read realaddr!\n");
-		gots[3+i] = (unsigned long )htoi(realaddr);
-	}
-	//printf("-------realaddr = %s\n", realaddr);
-}
-
-/*get updated shared library*/
-static void get_shared_library(void *p)
-{
-	/*
-	int domid;
-	char pathdomgfn[128];
-	unsigned long dom_gfn;
-	char gfn[64];
-	char *shared_addr;
-*/
-	/*step 1: get a pfn of page*/
-/*	shared_addr = (char *)alloc_page();
-	dom_gfn = virt_to_pfn(shared_addr);
-	snprintf(gfn, sizeof(gfn), "%d", dom_gfn);
-*/
-	/*step 2: write pfn to xenstore*/
-	/*
-	domid = xenbus_read_integer("domid");
-	snprintf(pathdomgfn, sizeof(pathdomgfn), "/local/domain/%d/console/domgfn", domid);
-	xenbus_write(0, pathdomgfn, gfn);
-	memcpy(shared_addr, "Hello World", sizeof("Hello World"));
-	printf("shared_addr = %s\n", shared_addr);
-	*/
-
-	/*
-	int server_sockfd;
-	int client_sockfd;
-	int len;
-	struct sockaddr_in my_addr; //server
-	struct sockaddr_in remote_addr; //client
-	int sin_size = sizeof(struct sockaddr_in);
-
-	//declare a struct of socket
-	memset(&my_addr, 0, sizeof(my_addr));//init sockaddr_in
-	my_addr.sin_family = AF_INET; //Set IP communication
-	my_addr.sin_addr.s_addr = INADDR_ANY;//server IP, permit any IP to connect
-	my_addr.sin_port = htons(10000);//set a server port
-
-	//build a socke, if success, return a fd of socket
-	if ((server_sockfd = socket(PF_INET, SOCK_STREAM, 0)) < 0){
-		perror("socket");
-		return 1;
-	}
-
-	//bind socket to network IP
-	if (bind(server_sockfd, (struct sockaddr *)&my_addr, sizeof(struct sockaddr)) < 0){
-		perror("bind");
-		return 1;
-	}
-
-	// listen a request
-	listen(server_sockfd, 5);
-	
-	//wait for a request
-	if ((client_sockfd = accept(server_sockfd, (struct sockaddr *)&remote_addr, &sin_size)) < 0){
-		perror("accept");
-		return 1;
-	}
-	char *buf = (char *)malloc(sizeof(char) *512);
-	char **dest = (char **)malloc(sizeof(char *)*2);
-	int i;
-	for (i=0; i<2; i++)
-		dest[i] = (char *)malloc(sizeof(char)*512);
-	i=0;
-	while ((len = recv(client_sockfd, buf, 512, 0)) > 0){
-		memcpy(dest[i], buf, 512);
-		i++;
-	}
-	for (i=0; i<512; i++)
-		printf("%p, ", dest[0][i]);
-	printf("\n\n\n");
-	close(client_sockfd);
-	close(server_sockfd);
-	return 0;
-	*/
-	/*get .got.plt of libso_test2.so*/
-	int domid;
-	char path[128];
-	char *msg, *val;
-
-	domid = xenbus_read_integer("domid");
-	snprintf(path, sizeof(path), "/local/domain/%d/console/got", domid);
-	while (1){
-		msg = xenbus_read(XBT_NIL, path, &val);	
-		if (msg)
-			continue;
-		if (gots == htoi(val)+0xdf000)
-			continue;
-		gots = (unsigned long *)(htoi(val)+0xdf000);
-		//printk("------------gots[0] = %p\n", gots[0]);
-		/*set moduleID in gots[1]*/
-		gots[1] = (unsigned long)0x1;		
-		/*set got[3] to update_parse_sym*/
-		gotm[3] = update_minios_parse_sym;
-		gots[3] = update_sotest_parse_sym;
-	}
-
-}
-
-
-/*parse symbol, like _dl_runtime_resolve*/
-void lazy_binding_parse_sym()
-{
-	int domid, count0, count1, i, j;
-	char path[128];
-	//char value[12];
-	//unsigned long *got = (unsigned long *)(&_edata+0xa0);
-	char *msg, *val_count, *realaddr;
-	unsigned long *got0, *got1;
-	
-	/*step 1:write addr into xenstore!*/
-	domid = xenbus_read_integer("domid");
-	snprintf(path, sizeof(path), "/local/domain/%d/console/flag", domid);
-	//sprintf(value, "%p", got[1]);
-	xenbus_write(0, path, "1");
-	//printk("value = %s\n", value);
-	/*step 2:read xenstore and set .got.plt table*/
-	//label 1: read count
-	snprintf(path, sizeof(path), "/local/domain/%d/console/count0", domid);
-	while (1) {
-		msg = xenbus_read(XBT_NIL, path, &val_count);
-		if (msg)
-			continue;
-		break;
-	}
-	count0 = atoi(val_count);
-	//printf("count = %d\n", count);
-	//printf("val_count = %s\n", val_count);
-	//label 2: read addr
-	//find .plt.got
-	//printf("----------------count = %d\n", count);
-	snprintf(path, sizeof(path), "/local/domain/%d/console/count1", domid);
-	msg = xenbus_read(XBT_NIL, path, &val_count);
-	count1 = atoi(val_count);
-	
-	for (j=0; j<2; j++){
-		snprintf(path, sizeof(path), "/local/domain/%d/console/r_got%d", domid, j);
-		if (j == 0){
-			msg = xenbus_read(XBT_NIL, path, &realaddr);
-			if (msg)
-				printk("Could not read realaddr1!\n");
-			got0 = (unsigned long *)htoi(realaddr);
-			//printf("-------------got0 = %p\n", got0);
-		}
-		if (j == 1){
-			msg = xenbus_read(XBT_NIL, path, &realaddr);
-			if (msg)
-				printk("Could not read realaddr2!\n");
-			got1 = (unsigned long *)(htoi(realaddr)+0xdd000);
-			//printf("-------------got1 = %p\n", got1);
-		}
-	}
-	
-	for (i=0; i<count0; i++){
-		snprintf(path, sizeof(path), "/local/domain/%d/console/addr0_%d", domid, i);
-		msg = xenbus_read(XBT_NIL, path, &realaddr);
-		if (msg)
-			printk("Could not read realaddr3!\n");
-		//printf("realaddr = %p\n", htoi(realaddr));
-		got0[i+3] = (unsigned long)htoi(realaddr);
-	}
-	for (i=0; i<count1; i++){
-		snprintf(path, sizeof(path), "/local/domain/%d/console/addr1_%d", domid, i);
-		msg = xenbus_read(XBT_NIL, path, &realaddr);
-		if (msg)
-			printk("Could not read realaddr4!\n");
-		//printf("realaddr = %p\n", htoi(realaddr));
-		got1[i+3] = (unsigned long)htoi(realaddr);
-	}
-	//__asm __volatile ("call %0" :: "m" (got0[3]));
-}
-
-/*define plt_func*/
-/*
-void plt_func(void)
-{
-	__asm __volatile ("call lazy_binding_parse_sym");
-}
-*/
-
-/*init .plt.got, make it to point plt_func*/
-/*
-void init_plt_got(unsigned long *got)
-{
-	got[3] = (unsigned long)plt_func;
-}
-*/
-
-
-int app_main(start_info_t *si)
-{
-	/*step 1: init .plt.got*/
-	unsigned long *got = (unsigned long *)(0x9a540);
-//	unsigned long *gotl = (unsigned long *)(0xde2b0);
-
-/*	
-	unsigned long *got1 = (unsigned long *)0xce2b0;
-	got0[3] = (unsigned long)0xcd1a0;
-*/
-	//got[3] = (unsigned long)0xdd1a0;
-	got[3] = lazy_binding_parse_sym;
-//	gotl[3] = lazy_binding_parse_sym;
-//	lazy_binding_parse_sym();
-//	lazy_thread = create_thread("lazy", lazy_binding_parse_sym, NULL);
-//	sleep(10);
-//	init_plt_got(got);
-	/*step 2: */
-	//printk("--------got[1] = %p\n", got[1]);
-	/*update shared library!*/
-
-    printk("Dummy main: start_info=%p\n", si);
-    main_thread = create_thread("main", call_main, si);
-	update_thread = create_thread("update", get_shared_library, NULL);
-
-    return 0;
-}
-#endif
diff -Nru xen-4.2.1-new/extras/mini-os/arch/x86/mm.c xen-4.2.1/extras/mini-os/arch/x86/mm.c
--- xen-4.2.1-new/extras/mini-os/arch/x86/mm.c	2015-10-26 10:34:49.375009999 +0800
+++ xen-4.2.1/extras/mini-os/arch/x86/mm.c	2012-12-17 23:00:04.000000000 +0800
@@ -922,7 +922,6 @@
 void arch_init_mm(unsigned long* start_pfn_p, unsigned long* max_pfn_p)
 {
     unsigned long start_pfn, max_pfn;
-	//unsigned long start;
 
     printk("      _text: %p(VA)\n", &_text);
     printk("     _etext: %p(VA)\n", &_etext);
@@ -930,21 +929,6 @@
     printk("     _edata: %p(VA)\n", &_edata);
     printk("stack start: %p(VA)\n", stack);
     printk("       _end: %p(VA)\n", &_end);
-/*
-	for (start = (unsigned long)&_text; start < (unsigned long)&_etext; start= start+4096)
-	{
-		printk("machine page: %x\n", pfn_to_mfn(virt_to_pfn(start)));
-	}
-*/
-	/*machine address*/
-	/*
-	printk("machine _text: %x(MA)\n", pfn_to_mfn(virt_to_pfn(&_text)));
-	printk("machine _etext: %x(MA)\n", pfn_to_mfn(virt_to_pfn(&_etext)));
-	printk("machine _erodata: %x(MA)\n", pfn_to_mfn(virt_to_pfn(&_erodata)));
-	printk("machine _edata: %x(MA)\n", pfn_to_mfn(virt_to_pfn(&_edata)));
-	printk("machine _stack_start: %x(MA)\n", pfn_to_mfn(virt_to_pfn(stack)));
-	printk("machine _end: %x(MA)\n", pfn_to_mfn(virt_to_pfn(&_end)));
-	*/
 
     /* First page follows page table pages and 3 more pages (store page etc) */
     start_pfn = PFN_UP(to_phys(start_info.pt_base)) + 
diff -Nru xen-4.2.1-new/extras/mini-os/include/lib.h xen-4.2.1/extras/mini-os/include/lib.h
--- xen-4.2.1-new/extras/mini-os/include/lib.h	2015-10-26 10:34:49.383010001 +0800
+++ xen-4.2.1/extras/mini-os/include/lib.h	2012-12-17 23:00:04.000000000 +0800
@@ -198,11 +198,7 @@
 int alloc_fd(enum fd_type type);
 void close_all_files(void);
 extern struct thread *main_thread;
-/*update library thread*/
-extern struct thread *update_thread;
-extern struct thread *lazy_thread;
 void sparse(unsigned long data, size_t size);
-void lazy_binding_parse_sym(void);
 #endif
 
 #endif /* _LIB_H_ */
diff -Nru xen-4.2.1-new/extras/mini-os/include/list.h xen-4.2.1/extras/mini-os/include/list.h
--- xen-4.2.1-new/extras/mini-os/include/list.h	2015-10-03 16:19:21.988009474 +0800
+++ xen-4.2.1/extras/mini-os/include/list.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,651 +0,0 @@
-/*
- * DO NOT EDIT THIS FILE
- *
- * Generated automatically by bsd-sys-queue-h-seddery to
- *  - introduce MINIOS_ and minios_ namespace prefixes
- *  - turn "struct type" into "type" so that type arguments
- *     to the macros are type names not struct tags
- *  - remove the reference to sys/cdefs.h, which is not needed
- *
- * The purpose of this seddery is to allow the resulting file to be
- * freely included by software which might also want to include other
- * list macros; to make it usable when struct tags are not being used
- * or not known; to make it more portable.
- */
-/*-
- * Copyright (c) 1991, 1993
- *	The Regents of the University of California.  All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 4. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- *	@(#)queue.h	8.5 (Berkeley) 8/20/94
- * $FreeBSD$
- */
-
-#ifndef MINIOS__SYS_QUEUE_H_
-#define	MINIOS__SYS_QUEUE_H_
-
-/* #include <sys/cdefs.h> */
-
-/*
- * This file defines four types of data structures: singly-linked lists,
- * singly-linked tail queues, lists and tail queues.
- *
- * A singly-linked list is headed by a single forward pointer. The elements
- * are singly linked for minimum space and pointer manipulation overhead at
- * the expense of O(n) removal for arbitrary elements. New elements can be
- * added to the list after an existing element or at the head of the list.
- * Elements being removed from the head of the list should use the explicit
- * macro for this purpose for optimum efficiency. A singly-linked list may
- * only be traversed in the forward direction.  Singly-linked lists are ideal
- * for applications with large datasets and few or no removals or for
- * implementing a LIFO queue.
- *
- * A singly-linked tail queue is headed by a pair of pointers, one to the
- * head of the list and the other to the tail of the list. The elements are
- * singly linked for minimum space and pointer manipulation overhead at the
- * expense of O(n) removal for arbitrary elements. New elements can be added
- * to the list after an existing element, at the head of the list, or at the
- * end of the list. Elements being removed from the head of the tail queue
- * should use the explicit macro for this purpose for optimum efficiency.
- * A singly-linked tail queue may only be traversed in the forward direction.
- * Singly-linked tail queues are ideal for applications with large datasets
- * and few or no removals or for implementing a FIFO queue.
- *
- * A list is headed by a single forward pointer (or an array of forward
- * pointers for a hash table header). The elements are doubly linked
- * so that an arbitrary element can be removed without a need to
- * traverse the list. New elements can be added to the list before
- * or after an existing element or at the head of the list. A list
- * may only be traversed in the forward direction.
- *
- * A tail queue is headed by a pair of pointers, one to the head of the
- * list and the other to the tail of the list. The elements are doubly
- * linked so that an arbitrary element can be removed without a need to
- * traverse the list. New elements can be added to the list before or
- * after an existing element, at the head of the list, or at the end of
- * the list. A tail queue may be traversed in either direction.
- *
- * For details on the use of these macros, see the queue(3) manual page.
- *
- *
- *				MINIOS_SLIST	MINIOS_LIST	MINIOS_STAILQ	MINIOS_TAILQ
- * _HEAD			+	+	+	+
- * _HEAD_INITIALIZER		+	+	+	+
- * _ENTRY			+	+	+	+
- * _INIT			+	+	+	+
- * _EMPTY			+	+	+	+
- * _FIRST			+	+	+	+
- * _NEXT			+	+	+	+
- * _PREV			-	-	-	+
- * _LAST			-	-	+	+
- * _FOREACH			+	+	+	+
- * _FOREACH_SAFE		+	+	+	+
- * _FOREACH_REVERSE		-	-	-	+
- * _FOREACH_REVERSE_SAFE	-	-	-	+
- * _INSERT_HEAD			+	+	+	+
- * _INSERT_BEFORE		-	+	-	+
- * _INSERT_AFTER		+	+	+	+
- * _INSERT_TAIL			-	-	+	+
- * _CONCAT			-	-	+	+
- * _REMOVE_AFTER		+	-	+	-
- * _REMOVE_HEAD			+	-	+	-
- * _REMOVE			+	+	+	+
- * _SWAP			+	+	+	+
- *
- */
-#ifdef MINIOS_QUEUE_MACRO_DEBUG
-/* Store the last 2 places the queue element or head was altered */
-struct minios__qm_trace {
-	char * lastfile;
-	int lastline;
-	char * prevfile;
-	int prevline;
-};
-
-#define	MINIOS__TRACEBUF	struct minios__qm_trace trace;
-#define	MINIOS__TRASHIT(x)	do {(x) = (void *)-1;} while (0)
-#define	MINIOS__QMD_SAVELINK(name, link)	void **name = (void *)&(link)
-
-#define	MINIOS__QMD_TRACE_HEAD(head) do {					\
-	(head)->trace.prevline = (head)->trace.lastline;		\
-	(head)->trace.prevfile = (head)->trace.lastfile;		\
-	(head)->trace.lastline = __LINE__;				\
-	(head)->trace.lastfile = __FILE__;				\
-} while (0)
-
-#define	MINIOS__QMD_TRACE_ELEM(elem) do {					\
-	(elem)->trace.prevline = (elem)->trace.lastline;		\
-	(elem)->trace.prevfile = (elem)->trace.lastfile;		\
-	(elem)->trace.lastline = __LINE__;				\
-	(elem)->trace.lastfile = __FILE__;				\
-} while (0)
-
-#else
-#define	MINIOS__QMD_TRACE_ELEM(elem)
-#define	MINIOS__QMD_TRACE_HEAD(head)
-#define	MINIOS__QMD_SAVELINK(name, link)
-#define	MINIOS__TRACEBUF
-#define	MINIOS__TRASHIT(x)
-#endif	/* MINIOS_QUEUE_MACRO_DEBUG */
-
-/*
- * Singly-linked List declarations.
- */
-#define	MINIOS_SLIST_HEAD(name, type)						\
-struct name {								\
-	type *slh_first;	/* first element */			\
-}
-
-#define	MINIOS_SLIST_HEAD_INITIALIZER(head)					\
-	{ 0 }
-
-#define	MINIOS_SLIST_ENTRY(type)						\
-struct {								\
-	type *sle_next;	/* next element */			\
-}
-
-/*
- * Singly-linked List functions.
- */
-#define	MINIOS_SLIST_EMPTY(head)	((head)->slh_first == 0)
-
-#define	MINIOS_SLIST_FIRST(head)	((head)->slh_first)
-
-#define	MINIOS_SLIST_FOREACH(var, head, field)					\
-	for ((var) = MINIOS_SLIST_FIRST((head));				\
-	    (var);							\
-	    (var) = MINIOS_SLIST_NEXT((var), field))
-
-#define	MINIOS_SLIST_FOREACH_SAFE(var, head, field, tvar)			\
-	for ((var) = MINIOS_SLIST_FIRST((head));				\
-	    (var) && ((tvar) = MINIOS_SLIST_NEXT((var), field), 1);		\
-	    (var) = (tvar))
-
-#define	MINIOS_SLIST_FOREACH_PREVPTR(var, varp, head, field)			\
-	for ((varp) = &MINIOS_SLIST_FIRST((head));				\
-	    ((var) = *(varp)) != 0;					\
-	    (varp) = &MINIOS_SLIST_NEXT((var), field))
-
-#define	MINIOS_SLIST_INIT(head) do {						\
-	MINIOS_SLIST_FIRST((head)) = 0;					\
-} while (0)
-
-#define	MINIOS_SLIST_INSERT_AFTER(slistelm, elm, field) do {			\
-	MINIOS_SLIST_NEXT((elm), field) = MINIOS_SLIST_NEXT((slistelm), field);	\
-	MINIOS_SLIST_NEXT((slistelm), field) = (elm);				\
-} while (0)
-
-#define	MINIOS_SLIST_INSERT_HEAD(head, elm, field) do {			\
-	MINIOS_SLIST_NEXT((elm), field) = MINIOS_SLIST_FIRST((head));			\
-	MINIOS_SLIST_FIRST((head)) = (elm);					\
-} while (0)
-
-#define	MINIOS_SLIST_NEXT(elm, field)	((elm)->field.sle_next)
-
-#define	MINIOS_SLIST_REMOVE(head, elm, type, field) do {			\
-	MINIOS__QMD_SAVELINK(oldnext, (elm)->field.sle_next);			\
-	if (MINIOS_SLIST_FIRST((head)) == (elm)) {				\
-		MINIOS_SLIST_REMOVE_HEAD((head), field);			\
-	}								\
-	else {								\
-		type *curelm = MINIOS_SLIST_FIRST((head));		\
-		while (MINIOS_SLIST_NEXT(curelm, field) != (elm))		\
-			curelm = MINIOS_SLIST_NEXT(curelm, field);		\
-		MINIOS_SLIST_REMOVE_AFTER(curelm, field);			\
-	}								\
-	MINIOS__TRASHIT(*oldnext);						\
-} while (0)
-
-#define MINIOS_SLIST_REMOVE_AFTER(elm, field) do {				\
-	MINIOS_SLIST_NEXT(elm, field) =					\
-	    MINIOS_SLIST_NEXT(MINIOS_SLIST_NEXT(elm, field), field);			\
-} while (0)
-
-#define	MINIOS_SLIST_REMOVE_HEAD(head, field) do {				\
-	MINIOS_SLIST_FIRST((head)) = MINIOS_SLIST_NEXT(MINIOS_SLIST_FIRST((head)), field);	\
-} while (0)
-
-#define MINIOS_SLIST_SWAP(head1, head2, type) do {				\
-	type *swap_first = MINIOS_SLIST_FIRST(head1);			\
-	MINIOS_SLIST_FIRST(head1) = MINIOS_SLIST_FIRST(head2);			\
-	MINIOS_SLIST_FIRST(head2) = swap_first;				\
-} while (0)
-
-/*
- * Singly-linked Tail queue declarations.
- */
-#define	MINIOS_STAILQ_HEAD(name, type)						\
-struct name {								\
-	type *stqh_first;/* first element */			\
-	type **stqh_last;/* addr of last next element */		\
-}
-
-#define	MINIOS_STAILQ_HEAD_INITIALIZER(head)					\
-	{ 0, &(head).stqh_first }
-
-#define	MINIOS_STAILQ_ENTRY(type)						\
-struct {								\
-	type *stqe_next;	/* next element */			\
-}
-
-/*
- * Singly-linked Tail queue functions.
- */
-#define	MINIOS_STAILQ_CONCAT(head1, head2) do {				\
-	if (!MINIOS_STAILQ_EMPTY((head2))) {					\
-		*(head1)->stqh_last = (head2)->stqh_first;		\
-		(head1)->stqh_last = (head2)->stqh_last;		\
-		MINIOS_STAILQ_INIT((head2));					\
-	}								\
-} while (0)
-
-#define	MINIOS_STAILQ_EMPTY(head)	((head)->stqh_first == 0)
-
-#define	MINIOS_STAILQ_FIRST(head)	((head)->stqh_first)
-
-#define	MINIOS_STAILQ_FOREACH(var, head, field)				\
-	for((var) = MINIOS_STAILQ_FIRST((head));				\
-	   (var);							\
-	   (var) = MINIOS_STAILQ_NEXT((var), field))
-
-
-#define	MINIOS_STAILQ_FOREACH_SAFE(var, head, field, tvar)			\
-	for ((var) = MINIOS_STAILQ_FIRST((head));				\
-	    (var) && ((tvar) = MINIOS_STAILQ_NEXT((var), field), 1);		\
-	    (var) = (tvar))
-
-#define	MINIOS_STAILQ_INIT(head) do {						\
-	MINIOS_STAILQ_FIRST((head)) = 0;					\
-	(head)->stqh_last = &MINIOS_STAILQ_FIRST((head));			\
-} while (0)
-
-#define	MINIOS_STAILQ_INSERT_AFTER(head, tqelm, elm, field) do {		\
-	if ((MINIOS_STAILQ_NEXT((elm), field) = MINIOS_STAILQ_NEXT((tqelm), field)) == 0)\
-		(head)->stqh_last = &MINIOS_STAILQ_NEXT((elm), field);		\
-	MINIOS_STAILQ_NEXT((tqelm), field) = (elm);				\
-} while (0)
-
-#define	MINIOS_STAILQ_INSERT_HEAD(head, elm, field) do {			\
-	if ((MINIOS_STAILQ_NEXT((elm), field) = MINIOS_STAILQ_FIRST((head))) == 0)	\
-		(head)->stqh_last = &MINIOS_STAILQ_NEXT((elm), field);		\
-	MINIOS_STAILQ_FIRST((head)) = (elm);					\
-} while (0)
-
-#define	MINIOS_STAILQ_INSERT_TAIL(head, elm, field) do {			\
-	MINIOS_STAILQ_NEXT((elm), field) = 0;				\
-	*(head)->stqh_last = (elm);					\
-	(head)->stqh_last = &MINIOS_STAILQ_NEXT((elm), field);			\
-} while (0)
-
-#define	MINIOS_STAILQ_LAST(head, type, field)					\
-	(MINIOS_STAILQ_EMPTY((head)) ?						\
-		0 :							\
-	        ((type *)(void *)				\
-		((char *)((head)->stqh_last) - __offsetof(type, field))))
-
-#define	MINIOS_STAILQ_NEXT(elm, field)	((elm)->field.stqe_next)
-
-#define	MINIOS_STAILQ_REMOVE(head, elm, type, field) do {			\
-	MINIOS__QMD_SAVELINK(oldnext, (elm)->field.stqe_next);			\
-	if (MINIOS_STAILQ_FIRST((head)) == (elm)) {				\
-		MINIOS_STAILQ_REMOVE_HEAD((head), field);			\
-	}								\
-	else {								\
-		type *curelm = MINIOS_STAILQ_FIRST((head));		\
-		while (MINIOS_STAILQ_NEXT(curelm, field) != (elm))		\
-			curelm = MINIOS_STAILQ_NEXT(curelm, field);		\
-		MINIOS_STAILQ_REMOVE_AFTER(head, curelm, field);		\
-	}								\
-	MINIOS__TRASHIT(*oldnext);						\
-} while (0)
-
-#define MINIOS_STAILQ_REMOVE_AFTER(head, elm, field) do {			\
-	if ((MINIOS_STAILQ_NEXT(elm, field) =					\
-	     MINIOS_STAILQ_NEXT(MINIOS_STAILQ_NEXT(elm, field), field)) == 0)	\
-		(head)->stqh_last = &MINIOS_STAILQ_NEXT((elm), field);		\
-} while (0)
-
-#define	MINIOS_STAILQ_REMOVE_HEAD(head, field) do {				\
-	if ((MINIOS_STAILQ_FIRST((head)) =					\
-	     MINIOS_STAILQ_NEXT(MINIOS_STAILQ_FIRST((head)), field)) == 0)		\
-		(head)->stqh_last = &MINIOS_STAILQ_FIRST((head));		\
-} while (0)
-
-#define MINIOS_STAILQ_SWAP(head1, head2, type) do {				\
-	type *swap_first = MINIOS_STAILQ_FIRST(head1);			\
-	type **swap_last = (head1)->stqh_last;			\
-	MINIOS_STAILQ_FIRST(head1) = MINIOS_STAILQ_FIRST(head2);			\
-	(head1)->stqh_last = (head2)->stqh_last;			\
-	MINIOS_STAILQ_FIRST(head2) = swap_first;				\
-	(head2)->stqh_last = swap_last;					\
-	if (MINIOS_STAILQ_EMPTY(head1))					\
-		(head1)->stqh_last = &MINIOS_STAILQ_FIRST(head1);		\
-	if (MINIOS_STAILQ_EMPTY(head2))					\
-		(head2)->stqh_last = &MINIOS_STAILQ_FIRST(head2);		\
-} while (0)
-
-
-/*
- * List declarations.
- */
-#define	MINIOS_LIST_HEAD(name, type)						\
-struct name {								\
-	type *lh_first;	/* first element */			\
-}
-
-#define	MINIOS_LIST_HEAD_INITIALIZER(head)					\
-	{ 0 }
-
-#define	MINIOS_LIST_ENTRY(type)						\
-struct {								\
-	type *le_next;	/* next element */			\
-	type **le_prev;	/* address of previous next element */	\
-}
-
-/*
- * List functions.
- */
-
-#if (defined(_KERNEL) && defined(INVARIANTS))
-#define	MINIOS__QMD_LIST_CHECK_HEAD(head, field) do {				\
-	if (MINIOS_LIST_FIRST((head)) != 0 &&				\
-	    MINIOS_LIST_FIRST((head))->field.le_prev !=			\
-	     &MINIOS_LIST_FIRST((head)))					\
-		panic("Bad list head %p first->prev != head", (head));	\
-} while (0)
-
-#define	MINIOS__QMD_LIST_CHECK_NEXT(elm, field) do {				\
-	if (MINIOS_LIST_NEXT((elm), field) != 0 &&				\
-	    MINIOS_LIST_NEXT((elm), field)->field.le_prev !=			\
-	     &((elm)->field.le_next))					\
-	     	panic("Bad link elm %p next->prev != elm", (elm));	\
-} while (0)
-
-#define	MINIOS__QMD_LIST_CHECK_PREV(elm, field) do {				\
-	if (*(elm)->field.le_prev != (elm))				\
-		panic("Bad link elm %p prev->next != elm", (elm));	\
-} while (0)
-#else
-#define	MINIOS__QMD_LIST_CHECK_HEAD(head, field)
-#define	MINIOS__QMD_LIST_CHECK_NEXT(elm, field)
-#define	MINIOS__QMD_LIST_CHECK_PREV(elm, field)
-#endif /* (_KERNEL && INVARIANTS) */
-
-#define	MINIOS_LIST_EMPTY(head)	((head)->lh_first == 0)
-
-#define	MINIOS_LIST_FIRST(head)	((head)->lh_first)
-
-#define	MINIOS_LIST_FOREACH(var, head, field)					\
-	for ((var) = MINIOS_LIST_FIRST((head));				\
-	    (var);							\
-	    (var) = MINIOS_LIST_NEXT((var), field))
-
-#define	MINIOS_LIST_FOREACH_SAFE(var, head, field, tvar)			\
-	for ((var) = MINIOS_LIST_FIRST((head));				\
-	    (var) && ((tvar) = MINIOS_LIST_NEXT((var), field), 1);		\
-	    (var) = (tvar))
-
-#define	MINIOS_LIST_INIT(head) do {						\
-	MINIOS_LIST_FIRST((head)) = 0;					\
-} while (0)
-
-#define	MINIOS_LIST_INSERT_AFTER(listelm, elm, field) do {			\
-	MINIOS__QMD_LIST_CHECK_NEXT(listelm, field);				\
-	if ((MINIOS_LIST_NEXT((elm), field) = MINIOS_LIST_NEXT((listelm), field)) != 0)\
-		MINIOS_LIST_NEXT((listelm), field)->field.le_prev =		\
-		    &MINIOS_LIST_NEXT((elm), field);				\
-	MINIOS_LIST_NEXT((listelm), field) = (elm);				\
-	(elm)->field.le_prev = &MINIOS_LIST_NEXT((listelm), field);		\
-} while (0)
-
-#define	MINIOS_LIST_INSERT_BEFORE(listelm, elm, field) do {			\
-	MINIOS__QMD_LIST_CHECK_PREV(listelm, field);				\
-	(elm)->field.le_prev = (listelm)->field.le_prev;		\
-	MINIOS_LIST_NEXT((elm), field) = (listelm);				\
-	*(listelm)->field.le_prev = (elm);				\
-	(listelm)->field.le_prev = &MINIOS_LIST_NEXT((elm), field);		\
-} while (0)
-
-#define	MINIOS_LIST_INSERT_HEAD(head, elm, field) do {				\
-	MINIOS__QMD_LIST_CHECK_HEAD((head), field);				\
-	if ((MINIOS_LIST_NEXT((elm), field) = MINIOS_LIST_FIRST((head))) != 0)	\
-		MINIOS_LIST_FIRST((head))->field.le_prev = &MINIOS_LIST_NEXT((elm), field);\
-	MINIOS_LIST_FIRST((head)) = (elm);					\
-	(elm)->field.le_prev = &MINIOS_LIST_FIRST((head));			\
-} while (0)
-
-#define	MINIOS_LIST_NEXT(elm, field)	((elm)->field.le_next)
-
-#define	MINIOS_LIST_REMOVE(elm, field) do {					\
-	MINIOS__QMD_SAVELINK(oldnext, (elm)->field.le_next);			\
-	MINIOS__QMD_SAVELINK(oldprev, (elm)->field.le_prev);			\
-	MINIOS__QMD_LIST_CHECK_NEXT(elm, field);				\
-	MINIOS__QMD_LIST_CHECK_PREV(elm, field);				\
-	if (MINIOS_LIST_NEXT((elm), field) != 0)				\
-		MINIOS_LIST_NEXT((elm), field)->field.le_prev = 		\
-		    (elm)->field.le_prev;				\
-	*(elm)->field.le_prev = MINIOS_LIST_NEXT((elm), field);		\
-	MINIOS__TRASHIT(*oldnext);						\
-	MINIOS__TRASHIT(*oldprev);						\
-} while (0)
-
-#define MINIOS_LIST_SWAP(head1, head2, type, field) do {			\
-	type *swap_tmp = MINIOS_LIST_FIRST((head1));			\
-	MINIOS_LIST_FIRST((head1)) = MINIOS_LIST_FIRST((head2));			\
-	MINIOS_LIST_FIRST((head2)) = swap_tmp;					\
-	if ((swap_tmp = MINIOS_LIST_FIRST((head1))) != 0)			\
-		swap_tmp->field.le_prev = &MINIOS_LIST_FIRST((head1));		\
-	if ((swap_tmp = MINIOS_LIST_FIRST((head2))) != 0)			\
-		swap_tmp->field.le_prev = &MINIOS_LIST_FIRST((head2));		\
-} while (0)
-
-/*
- * Tail queue declarations.
- */
-#define	MINIOS_TAILQ_HEAD(name, type)						\
-struct name {								\
-	type *tqh_first;	/* first element */			\
-	type **tqh_last;	/* addr of last next element */		\
-	MINIOS__TRACEBUF							\
-}
-
-#define	MINIOS_TAILQ_HEAD_INITIALIZER(head)					\
-	{ 0, &(head).tqh_first }
-
-#define	MINIOS_TAILQ_ENTRY(type)						\
-struct {								\
-	type *tqe_next;	/* next element */			\
-	type **tqe_prev;	/* address of previous next element */	\
-	MINIOS__TRACEBUF							\
-}
-
-/*
- * Tail queue functions.
- */
-#if (defined(_KERNEL) && defined(INVARIANTS))
-#define	MINIOS__QMD_TAILQ_CHECK_HEAD(head, field) do {				\
-	if (!MINIOS_TAILQ_EMPTY(head) &&					\
-	    MINIOS_TAILQ_FIRST((head))->field.tqe_prev !=			\
-	     &MINIOS_TAILQ_FIRST((head)))					\
-		panic("Bad tailq head %p first->prev != head", (head));	\
-} while (0)
-
-#define	MINIOS__QMD_TAILQ_CHECK_TAIL(head, field) do {				\
-	if (*(head)->tqh_last != 0)					\
-	    	panic("Bad tailq NEXT(%p->tqh_last) != 0", (head)); 	\
-} while (0)
-
-#define	MINIOS__QMD_TAILQ_CHECK_NEXT(elm, field) do {				\
-	if (MINIOS_TAILQ_NEXT((elm), field) != 0 &&				\
-	    MINIOS_TAILQ_NEXT((elm), field)->field.tqe_prev !=			\
-	     &((elm)->field.tqe_next))					\
-		panic("Bad link elm %p next->prev != elm", (elm));	\
-} while (0)
-
-#define	MINIOS__QMD_TAILQ_CHECK_PREV(elm, field) do {				\
-	if (*(elm)->field.tqe_prev != (elm))				\
-		panic("Bad link elm %p prev->next != elm", (elm));	\
-} while (0)
-#else
-#define	MINIOS__QMD_TAILQ_CHECK_HEAD(head, field)
-#define	MINIOS__QMD_TAILQ_CHECK_TAIL(head, headname)
-#define	MINIOS__QMD_TAILQ_CHECK_NEXT(elm, field)
-#define	MINIOS__QMD_TAILQ_CHECK_PREV(elm, field)
-#endif /* (_KERNEL && INVARIANTS) */
-
-#define	MINIOS_TAILQ_CONCAT(head1, head2, field) do {				\
-	if (!MINIOS_TAILQ_EMPTY(head2)) {					\
-		*(head1)->tqh_last = (head2)->tqh_first;		\
-		(head2)->tqh_first->field.tqe_prev = (head1)->tqh_last;	\
-		(head1)->tqh_last = (head2)->tqh_last;			\
-		MINIOS_TAILQ_INIT((head2));					\
-		MINIOS__QMD_TRACE_HEAD(head1);					\
-		MINIOS__QMD_TRACE_HEAD(head2);					\
-	}								\
-} while (0)
-
-#define	MINIOS_TAILQ_EMPTY(head)	((head)->tqh_first == 0)
-
-#define	MINIOS_TAILQ_FIRST(head)	((head)->tqh_first)
-
-#define	MINIOS_TAILQ_FOREACH(var, head, field)					\
-	for ((var) = MINIOS_TAILQ_FIRST((head));				\
-	    (var);							\
-	    (var) = MINIOS_TAILQ_NEXT((var), field))
-
-#define	MINIOS_TAILQ_FOREACH_SAFE(var, head, field, tvar)			\
-	for ((var) = MINIOS_TAILQ_FIRST((head));				\
-	    (var) && ((tvar) = MINIOS_TAILQ_NEXT((var), field), 1);		\
-	    (var) = (tvar))
-
-#define	MINIOS_TAILQ_FOREACH_REVERSE(var, head, headname, field)		\
-	for ((var) = MINIOS_TAILQ_LAST((head), headname);			\
-	    (var);							\
-	    (var) = MINIOS_TAILQ_PREV((var), headname, field))
-
-#define	MINIOS_TAILQ_FOREACH_REVERSE_SAFE(var, head, headname, field, tvar)	\
-	for ((var) = MINIOS_TAILQ_LAST((head), headname);			\
-	    (var) && ((tvar) = MINIOS_TAILQ_PREV((var), headname, field), 1);	\
-	    (var) = (tvar))
-
-#define	MINIOS_TAILQ_INIT(head) do {						\
-	MINIOS_TAILQ_FIRST((head)) = 0;					\
-	(head)->tqh_last = &MINIOS_TAILQ_FIRST((head));			\
-	MINIOS__QMD_TRACE_HEAD(head);						\
-} while (0)
-
-#define	MINIOS_TAILQ_INSERT_AFTER(head, listelm, elm, field) do {		\
-	MINIOS__QMD_TAILQ_CHECK_NEXT(listelm, field);				\
-	if ((MINIOS_TAILQ_NEXT((elm), field) = MINIOS_TAILQ_NEXT((listelm), field)) != 0)\
-		MINIOS_TAILQ_NEXT((elm), field)->field.tqe_prev = 		\
-		    &MINIOS_TAILQ_NEXT((elm), field);				\
-	else {								\
-		(head)->tqh_last = &MINIOS_TAILQ_NEXT((elm), field);		\
-		MINIOS__QMD_TRACE_HEAD(head);					\
-	}								\
-	MINIOS_TAILQ_NEXT((listelm), field) = (elm);				\
-	(elm)->field.tqe_prev = &MINIOS_TAILQ_NEXT((listelm), field);		\
-	MINIOS__QMD_TRACE_ELEM(&(elm)->field);					\
-	MINIOS__QMD_TRACE_ELEM(&listelm->field);				\
-} while (0)
-
-#define	MINIOS_TAILQ_INSERT_BEFORE(listelm, elm, field) do {			\
-	MINIOS__QMD_TAILQ_CHECK_PREV(listelm, field);				\
-	(elm)->field.tqe_prev = (listelm)->field.tqe_prev;		\
-	MINIOS_TAILQ_NEXT((elm), field) = (listelm);				\
-	*(listelm)->field.tqe_prev = (elm);				\
-	(listelm)->field.tqe_prev = &MINIOS_TAILQ_NEXT((elm), field);		\
-	MINIOS__QMD_TRACE_ELEM(&(elm)->field);					\
-	MINIOS__QMD_TRACE_ELEM(&listelm->field);				\
-} while (0)
-
-#define	MINIOS_TAILQ_INSERT_HEAD(head, elm, field) do {			\
-	MINIOS__QMD_TAILQ_CHECK_HEAD(head, field);				\
-	if ((MINIOS_TAILQ_NEXT((elm), field) = MINIOS_TAILQ_FIRST((head))) != 0)	\
-		MINIOS_TAILQ_FIRST((head))->field.tqe_prev =			\
-		    &MINIOS_TAILQ_NEXT((elm), field);				\
-	else								\
-		(head)->tqh_last = &MINIOS_TAILQ_NEXT((elm), field);		\
-	MINIOS_TAILQ_FIRST((head)) = (elm);					\
-	(elm)->field.tqe_prev = &MINIOS_TAILQ_FIRST((head));			\
-	MINIOS__QMD_TRACE_HEAD(head);						\
-	MINIOS__QMD_TRACE_ELEM(&(elm)->field);					\
-} while (0)
-
-#define	MINIOS_TAILQ_INSERT_TAIL(head, elm, field) do {			\
-	MINIOS__QMD_TAILQ_CHECK_TAIL(head, field);				\
-	MINIOS_TAILQ_NEXT((elm), field) = 0;				\
-	(elm)->field.tqe_prev = (head)->tqh_last;			\
-	*(head)->tqh_last = (elm);					\
-	(head)->tqh_last = &MINIOS_TAILQ_NEXT((elm), field);			\
-	MINIOS__QMD_TRACE_HEAD(head);						\
-	MINIOS__QMD_TRACE_ELEM(&(elm)->field);					\
-} while (0)
-
-#define	MINIOS_TAILQ_LAST(head, headname)					\
-	(*(((struct headname *)((head)->tqh_last))->tqh_last))
-
-#define	MINIOS_TAILQ_NEXT(elm, field) ((elm)->field.tqe_next)
-
-#define	MINIOS_TAILQ_PREV(elm, headname, field)				\
-	(*(((struct headname *)((elm)->field.tqe_prev))->tqh_last))
-
-#define	MINIOS_TAILQ_REMOVE(head, elm, field) do {				\
-	MINIOS__QMD_SAVELINK(oldnext, (elm)->field.tqe_next);			\
-	MINIOS__QMD_SAVELINK(oldprev, (elm)->field.tqe_prev);			\
-	MINIOS__QMD_TAILQ_CHECK_NEXT(elm, field);				\
-	MINIOS__QMD_TAILQ_CHECK_PREV(elm, field);				\
-	if ((MINIOS_TAILQ_NEXT((elm), field)) != 0)				\
-		MINIOS_TAILQ_NEXT((elm), field)->field.tqe_prev = 		\
-		    (elm)->field.tqe_prev;				\
-	else {								\
-		(head)->tqh_last = (elm)->field.tqe_prev;		\
-		MINIOS__QMD_TRACE_HEAD(head);					\
-	}								\
-	*(elm)->field.tqe_prev = MINIOS_TAILQ_NEXT((elm), field);		\
-	MINIOS__TRASHIT(*oldnext);						\
-	MINIOS__TRASHIT(*oldprev);						\
-	MINIOS__QMD_TRACE_ELEM(&(elm)->field);					\
-} while (0)
-
-#define MINIOS_TAILQ_SWAP(head1, head2, type, field) do {			\
-	type *swap_first = (head1)->tqh_first;			\
-	type **swap_last = (head1)->tqh_last;			\
-	(head1)->tqh_first = (head2)->tqh_first;			\
-	(head1)->tqh_last = (head2)->tqh_last;				\
-	(head2)->tqh_first = swap_first;				\
-	(head2)->tqh_last = swap_last;					\
-	if ((swap_first = (head1)->tqh_first) != 0)			\
-		swap_first->field.tqe_prev = &(head1)->tqh_first;	\
-	else								\
-		(head1)->tqh_last = &(head1)->tqh_first;		\
-	if ((swap_first = (head2)->tqh_first) != 0)			\
-		swap_first->field.tqe_prev = &(head2)->tqh_first;	\
-	else								\
-		(head2)->tqh_last = &(head2)->tqh_first;		\
-} while (0)
-
-#endif /* !MINIOS__SYS_QUEUE_H_ */
diff -Nru xen-4.2.1-new/extras/mini-os/include/xen/arch-arm/hvm/save.h xen-4.2.1/extras/mini-os/include/xen/arch-arm/hvm/save.h
--- xen-4.2.1-new/extras/mini-os/include/xen/arch-arm/hvm/save.h	2012-12-17 23:01:56.000000000 +0800
+++ xen-4.2.1/extras/mini-os/include/xen/arch-arm/hvm/save.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,39 +0,0 @@
-/*
- * Structure definitions for HVM state that is held by Xen and must
- * be saved along with the domain's memory and device-model state.
- *
- * Copyright (c) 2012 Citrix Systems Ltd.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- */
-
-#ifndef __XEN_PUBLIC_HVM_SAVE_ARM_H__
-#define __XEN_PUBLIC_HVM_SAVE_ARM_H__
-
-#endif
-
-/*
- * Local variables:
- * mode: C
- * c-set-style: "BSD"
- * c-basic-offset: 4
- * tab-width: 4
- * indent-tabs-mode: nil
- * End:
- */
diff -Nru xen-4.2.1-new/extras/mini-os/include/xen/arch-arm.h xen-4.2.1/extras/mini-os/include/xen/arch-arm.h
--- xen-4.2.1-new/extras/mini-os/include/xen/arch-arm.h	2014-08-23 21:01:22.000000000 +0800
+++ xen-4.2.1/extras/mini-os/include/xen/arch-arm.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,176 +0,0 @@
-/******************************************************************************
- * arch-arm.h
- *
- * Guest OS interface to ARM Xen.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- * Copyright 2011 (C) Citrix Systems
- */
-
-#ifndef __XEN_PUBLIC_ARCH_ARM_H__
-#define __XEN_PUBLIC_ARCH_ARM_H__
-
-/* hypercall calling convention
- * ----------------------------
- *
- * A hypercall is issued using the ARM HVC instruction.
- *
- * A hypercall can take up to 5 arguments. These are passed in
- * registers, the first argument in r0, the second argument in r1, the
- * third in r2, the forth in r3 and the fifth in r4.
- *
- * The hypercall number is passed in r12.
- *
- * The HVC ISS must contain a Xen specific TAG: XEN_HYPERCALL_TAG.
- *
- * The return value is in r0.
- *
- * The hypercall will clobber r12 and the argument registers used by
- * that hypercall (except r0 which is the return value) i.e. a 2
- * argument hypercall will clobber r1 and a 4 argument hypercall will
- * clobber r1, r2 and r3.
- *
- */
-
-#define XEN_HYPERCALL_TAG   0XEA1
-
-
-#ifndef __ASSEMBLY__
-#define ___DEFINE_XEN_GUEST_HANDLE(name, type) \
-    typedef struct { type *p; } __guest_handle_ ## name
-
-#define __DEFINE_XEN_GUEST_HANDLE(name, type) \
-    ___DEFINE_XEN_GUEST_HANDLE(name, type);   \
-    ___DEFINE_XEN_GUEST_HANDLE(const_##name, const type)
-#define DEFINE_XEN_GUEST_HANDLE(name)   __DEFINE_XEN_GUEST_HANDLE(name, name)
-#define __XEN_GUEST_HANDLE(name)        __guest_handle_ ## name
-#define XEN_GUEST_HANDLE(name)          __XEN_GUEST_HANDLE(name)
-#define set_xen_guest_handle_raw(hnd, val)  do { (hnd).p = val; } while (0)
-#ifdef __XEN_TOOLS__
-#define get_xen_guest_handle(val, hnd)  do { val = (hnd).p; } while (0)
-#endif
-#define set_xen_guest_handle(hnd, val) set_xen_guest_handle_raw(hnd, val)
-
-struct cpu_user_regs
-{
-    uint32_t r0;
-    uint32_t r1;
-    uint32_t r2;
-    uint32_t r3;
-    uint32_t r4;
-    uint32_t r5;
-    uint32_t r6;
-    uint32_t r7;
-    uint32_t r8;
-    uint32_t r9;
-    uint32_t r10;
-    union {
-        uint32_t r11;
-        uint32_t fp;
-    };
-    uint32_t r12;
-
-    uint32_t sp; /* r13 - SP: Valid for Hyp. frames only, o/w banked (see below) */
-
-    /* r14 - LR: is the same physical register as LR_usr */
-    union {
-        uint32_t lr; /* r14 - LR: Valid for Hyp. Same physical register as lr_usr. */
-        uint32_t lr_usr;
-    };
-
-    uint32_t pc; /* Return IP */
-    uint32_t cpsr; /* Return mode */
-    uint32_t pad0; /* Doubleword-align the kernel half of the frame */
-
-    /* Outer guest frame only from here on... */
-
-    uint32_t r8_fiq, r9_fiq, r10_fiq, r11_fiq, r12_fiq;
-
-    uint32_t sp_usr; /* LR_usr is the same register as LR, see above */
-
-    uint32_t sp_svc, sp_abt, sp_und, sp_irq, sp_fiq;
-    uint32_t lr_svc, lr_abt, lr_und, lr_irq, lr_fiq;
-
-    uint32_t spsr_svc, spsr_abt, spsr_und, spsr_irq, spsr_fiq;
-
-    uint32_t pad1; /* Doubleword-align the user half of the frame */
-};
-typedef struct cpu_user_regs cpu_user_regs_t;
-DEFINE_XEN_GUEST_HANDLE(cpu_user_regs_t);
-
-typedef uint64_t xen_pfn_t;
-#define PRI_xen_pfn PRIx64
-
-/* Maximum number of virtual CPUs in legacy multi-processor guests. */
-/* Only one. All other VCPUS must use VCPUOP_register_vcpu_info */
-#define XEN_LEGACY_MAX_VCPUS 1
-
-typedef uint32_t xen_ulong_t;
-
-struct vcpu_guest_context {
-    struct cpu_user_regs user_regs;         /* User-level CPU registers     */
-
-    uint32_t sctlr;
-    uint32_t ttbr0, ttbr1, ttbcr;
-};
-typedef struct vcpu_guest_context vcpu_guest_context_t;
-DEFINE_XEN_GUEST_HANDLE(vcpu_guest_context_t);
-
-struct arch_vcpu_info { };
-typedef struct arch_vcpu_info arch_vcpu_info_t;
-
-struct arch_shared_info { };
-typedef struct arch_shared_info arch_shared_info_t;
-typedef uint64_t xen_callback_t;
-
-#endif /* ifndef __ASSEMBLY __ */
-
-/* PSR bits (CPSR, SPSR)*/
-
-/* 0-4: Mode */
-#define PSR_MODE_MASK 0x1f
-#define PSR_MODE_USR 0x10
-#define PSR_MODE_FIQ 0x11
-#define PSR_MODE_IRQ 0x12
-#define PSR_MODE_SVC 0x13
-#define PSR_MODE_MON 0x16
-#define PSR_MODE_ABT 0x17
-#define PSR_MODE_HYP 0x1a
-#define PSR_MODE_UND 0x1b
-#define PSR_MODE_SYS 0x1f
-
-#define PSR_THUMB       (1<<5)        /* Thumb Mode enable */
-#define PSR_FIQ_MASK    (1<<6)        /* Fast Interrupt mask */
-#define PSR_IRQ_MASK    (1<<7)        /* Interrupt mask */
-#define PSR_ABT_MASK    (1<<8)        /* Asynchronous Abort mask */
-#define PSR_BIG_ENDIAN  (1<<9)        /* Big Endian Mode */
-#define PSR_JAZELLE     (1<<24)       /* Jazelle Mode */
-
-#endif /*  __XEN_PUBLIC_ARCH_ARM_H__ */
-
-/*
- * Local variables:
- * mode: C
- * c-set-style: "BSD"
- * c-basic-offset: 4
- * tab-width: 4
- * indent-tabs-mode: nil
- * End:
- */
diff -Nru xen-4.2.1-new/extras/mini-os/include/xen/arch-ia64/debug_op.h xen-4.2.1/extras/mini-os/include/xen/arch-ia64/debug_op.h
--- xen-4.2.1-new/extras/mini-os/include/xen/arch-ia64/debug_op.h	2012-12-17 23:01:56.000000000 +0800
+++ xen-4.2.1/extras/mini-os/include/xen/arch-ia64/debug_op.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,99 +0,0 @@
-/******************************************************************************
- * debug_op.h
- *
- * Copyright (c) 2007 Tristan Gingold <tgingold@free.fr>
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- */
-
-#ifndef __XEN_PUBLIC_IA64_DEBUG_OP_H__
-#define __XEN_PUBLIC_IA64_DEBUG_OP_H__
-
-/* Set/Get extra conditions to break.  */
-#define XEN_IA64_DEBUG_OP_SET_FLAGS 1
-#define XEN_IA64_DEBUG_OP_GET_FLAGS 2
-
-/* Break on kernel single step.  */
-#define XEN_IA64_DEBUG_ON_KERN_SSTEP   (1 << 0)
-
-/* Break on kernel debug (breakpoint or watch point).  */
-#define XEN_IA64_DEBUG_ON_KERN_DEBUG   (1 << 1)
-
-/* Break on kernel taken branch.  */
-#define XEN_IA64_DEBUG_ON_KERN_TBRANCH (1 << 2)
-
-/* Break on interrupt injection.  */
-#define XEN_IA64_DEBUG_ON_EXTINT       (1 << 3)
-
-/* Break on interrupt injection.  */
-#define XEN_IA64_DEBUG_ON_EXCEPT       (1 << 4)
-
-/* Break on event injection.  */
-#define XEN_IA64_DEBUG_ON_EVENT        (1 << 5)
-
-/* Break on privop/virtualized instruction (slow path only).  */
-#define XEN_IA64_DEBUG_ON_PRIVOP       (1 << 6)
-
-/* Break on emulated PAL call (at entry).  */
-#define XEN_IA64_DEBUG_ON_PAL          (1 << 7)
-
-/* Break on emulated SAL call (at entry).  */
-#define XEN_IA64_DEBUG_ON_SAL          (1 << 8)
-
-/* Break on emulated EFI call (at entry).  */
-#define XEN_IA64_DEBUG_ON_EFI          (1 << 9)
-
-/* Break on rfi emulation (slow path only, before exec).  */
-#define XEN_IA64_DEBUG_ON_RFI          (1 << 10)
-
-/* Break on address translation switch.  */
-#define XEN_IA64_DEBUG_ON_MMU          (1 << 11)
-
-/* Break on bad guest physical address.  */
-#define XEN_IA64_DEBUG_ON_BAD_MPA      (1 << 12)
-
-/* Force psr.ss bit.  */
-#define XEN_IA64_DEBUG_FORCE_SS        (1 << 13)
-
-/* Force psr.db bit.  */
-#define XEN_IA64_DEBUG_FORCE_DB        (1 << 14)
-
-/* Break on ITR/PTR.  */
-#define XEN_IA64_DEBUG_ON_TR           (1 << 15)
-
-/* Break on ITC/PTC.L/PTC.G/PTC.GA.  */
-#define XEN_IA64_DEBUG_ON_TC           (1 << 16)
-
-/* Get translation cache.  */
-#define XEN_IA64_DEBUG_OP_GET_TC   3
-
-/* Translate virtual address to guest physical address.  */
-#define XEN_IA64_DEBUG_OP_TRANSLATE 4
-
-union xen_ia64_debug_op {
-    uint64_t flags;
-    struct xen_ia64_debug_vtlb {
-        uint64_t nbr;                             /* IN/OUT */
-        XEN_GUEST_HANDLE_64(ia64_tr_entry_t) tr;  /* IN/OUT */
-    } vtlb;
-};
-typedef union xen_ia64_debug_op xen_ia64_debug_op_t;
-DEFINE_XEN_GUEST_HANDLE(xen_ia64_debug_op_t);
-
-#endif /* __XEN_PUBLIC_IA64_DEBUG_OP_H__ */
diff -Nru xen-4.2.1-new/extras/mini-os/include/xen/arch-ia64/hvm/memmap.h xen-4.2.1/extras/mini-os/include/xen/arch-ia64/hvm/memmap.h
--- xen-4.2.1-new/extras/mini-os/include/xen/arch-ia64/hvm/memmap.h	2012-12-17 23:01:56.000000000 +0800
+++ xen-4.2.1/extras/mini-os/include/xen/arch-ia64/hvm/memmap.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,91 +0,0 @@
-/******************************************************************************
- * memmap.h
- *
- * Copyright (c) 2008 Tristan Gingold <tgingold AT free fr>
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- */
-
-#ifndef __XEN_PUBLIC_HVM_MEMMAP_IA64_H__
-#define __XEN_PUBLIC_HVM_MEMMAP_IA64_H__
-
-#define MEM_G  (1UL << 30)
-#define MEM_M  (1UL << 20)
-#define MEM_K  (1UL << 10)
-
-/* Guest physical address of IO ports space.  */
-#define MMIO_START  (3 * MEM_G)
-#define MMIO_SIZE   (512 * MEM_M)
-
-#define VGA_IO_START  0xA0000UL
-#define VGA_IO_SIZE   0x20000
-
-#define LEGACY_IO_START  (MMIO_START + MMIO_SIZE)
-#define LEGACY_IO_SIZE   (64 * MEM_M)
-
-#define IO_PAGE_START  (LEGACY_IO_START + LEGACY_IO_SIZE)
-#define IO_PAGE_SIZE   XEN_PAGE_SIZE
-
-#define STORE_PAGE_START  (IO_PAGE_START + IO_PAGE_SIZE)
-#define STORE_PAGE_SIZE   XEN_PAGE_SIZE
-
-#define BUFFER_IO_PAGE_START  (STORE_PAGE_START + STORE_PAGE_SIZE)
-#define BUFFER_IO_PAGE_SIZE   XEN_PAGE_SIZE
-
-#define BUFFER_PIO_PAGE_START  (BUFFER_IO_PAGE_START + BUFFER_IO_PAGE_SIZE)
-#define BUFFER_PIO_PAGE_SIZE   XEN_PAGE_SIZE
-
-#define IO_SAPIC_START  0xfec00000UL
-#define IO_SAPIC_SIZE   0x100000
-
-#define PIB_START  0xfee00000UL
-#define PIB_SIZE   0x200000
-
-#define GFW_START  (4 * MEM_G - 16 * MEM_M)
-#define GFW_SIZE   (16 * MEM_M)
-
-/* domVTI */
-#define GPFN_FRAME_BUFFER  0x1 /* VGA framebuffer */
-#define GPFN_LOW_MMIO      0x2 /* Low MMIO range */
-#define GPFN_PIB           0x3 /* PIB base */
-#define GPFN_IOSAPIC       0x4 /* IOSAPIC base */
-#define GPFN_LEGACY_IO     0x5 /* Legacy I/O base */
-#define GPFN_HIGH_MMIO     0x6 /* High MMIO range */
-
-/* Nvram belongs to GFW memory space  */
-#define NVRAM_SIZE   (MEM_K * 64)
-#define NVRAM_START  (GFW_START + 10 * MEM_M)
-
-#define NVRAM_VALID_SIG  0x4650494e45584948 /* "HIXENIPF" */
-struct nvram_save_addr {
-    unsigned long addr;
-    unsigned long signature;
-};
-
-#endif /* __XEN_PUBLIC_HVM_MEMMAP_IA64_H__ */
-
-/*
- * Local variables:
- * mode: C
- * c-set-style: "BSD"
- * c-basic-offset: 4
- * tab-width: 4
- * indent-tabs-mode: nil
- * End:
- */
diff -Nru xen-4.2.1-new/extras/mini-os/include/xen/arch-ia64/hvm/save.h xen-4.2.1/extras/mini-os/include/xen/arch-ia64/hvm/save.h
--- xen-4.2.1-new/extras/mini-os/include/xen/arch-ia64/hvm/save.h	2012-12-17 23:01:56.000000000 +0800
+++ xen-4.2.1/extras/mini-os/include/xen/arch-ia64/hvm/save.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,208 +0,0 @@
-/******************************************************************************
- * save_types.h
- *
- * Copyright (c) 2007 Isaku Yamahata <yamahata at valinux co jp>
- *                    VA Linux Systems Japan K.K.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- */
-
-#ifndef __XEN_PUBLIC_HVM_SAVE_IA64_H__
-#define __XEN_PUBLIC_HVM_SAVE_IA64_H__
-
-#include "../../hvm/save.h"
-#include "../../arch-ia64.h"
-
-/* 
- * Save/restore header: general info about the save file. 
- */
-
-/* x86 uses 0x54381286 */
-#define HVM_FILE_MAGIC   0x343641492f6e6558UL   /* "Xen/IA64" */
-#define HVM_FILE_VERSION 0x0000000000000001UL
-
-struct hvm_save_header {
-    uint64_t magic;             /* Must be HVM_FILE_MAGIC */
-    uint64_t version;           /* File format version */
-    uint64_t changeset;         /* Version of Xen that saved this file */
-    uint64_t cpuid[5];          /* CPUID[0x01][%eax] on the saving machine */
-};
-
-DECLARE_HVM_SAVE_TYPE(HEADER, 1, struct hvm_save_header);
-
-/*
- * CPU
- */
-struct hvm_hw_ia64_cpu {
-    uint64_t    ipsr;
-};
-DECLARE_HVM_SAVE_TYPE(CPU, 2, struct hvm_hw_ia64_cpu);
-
-/*
- * CPU
- */
-struct hvm_hw_ia64_vpd {
-    struct vpd      vpd;
-};
-DECLARE_HVM_SAVE_TYPE(VPD, 3, struct hvm_hw_ia64_vpd);
-
-/*
- * device dependency
- * vacpi => viosapic => vlsapic
- */
-/*
- * vlsapic
- */
-struct hvm_hw_ia64_vlsapic {
-    uint64_t insvc[4];
-    uint64_t vhpi; // ??? should this be saved in vpd
-    uint8_t xtp;
-    uint8_t pal_init_pending;
-    uint8_t pad[2];
-};
-DECLARE_HVM_SAVE_TYPE(VLSAPIC, 4, struct hvm_hw_ia64_vlsapic);
-/* set
- * unconditionaly set v->arch.irq_new_peding = 1 
- * unconditionaly set v->arch.irq_new_condition = 0
- */
-
-/*
- * vtime
- */
-/* itc, itm, itv are saved by arch vcpu context */
-struct hvm_hw_ia64_vtime {
-    uint64_t itc;
-    uint64_t itm;
-
-    uint64_t last_itc;
-    uint64_t pending;
-};
-DECLARE_HVM_SAVE_TYPE(VTIME, 5, struct hvm_hw_ia64_vtime);
-/*
- * calculate v->vtm.vtm_offset
- * ??? Or should vtm_offset be set by leave_hypervisor_tail()?
- * start vtm_timer if necessary by vtm_set_itm().
- * ??? Or should vtm_timer be set by leave_hypervisor_tail()?
- *
- * ??? or should be done by schedule_tail()
- *        => schedule_tail() should do.
- */
-
-/*
- * viosapic
- */
-#define VIOSAPIC_NUM_PINS     48
-
-/* To share VT-d code which uses vioapic_redir_entry.
- * Although on ia64 this is for vsapic, but we have to vioapic_redir_entry
- * instead of viosapic_redir_entry.
- */
-union vioapic_redir_entry
-{
-    uint64_t bits;
-    struct {
-        uint8_t vector;
-
-        uint8_t delivery_mode  : 3;
-        uint8_t reserve1       : 1;
-        uint8_t delivery_status: 1;
-        uint8_t polarity       : 1;
-        uint8_t reserve2       : 1;
-        uint8_t trig_mode      : 1;
-
-        uint8_t mask           : 1;
-        uint8_t reserve3       : 7;
-
-        uint8_t reserved[3];
-        uint16_t dest_id;
-    } fields;
-};
-
-struct hvm_hw_ia64_viosapic {
-    uint64_t    irr;
-    uint64_t    isr;
-    uint32_t    ioregsel;
-    uint32_t    pad;
-    uint64_t    lowest_vcpu_id;
-    uint64_t    base_address;
-    union vioapic_redir_entry  redirtbl[VIOSAPIC_NUM_PINS];
-};
-DECLARE_HVM_SAVE_TYPE(VIOSAPIC, 6, struct hvm_hw_ia64_viosapic);
-  
-/*
- * vacpi
- * PM timer
- */
-struct vacpi_regs {
-    union {
-        struct {
-            uint32_t pm1a_sts:16;/* PM1a_EVT_BLK.PM1a_STS: status register */
-            uint32_t pm1a_en:16; /* PM1a_EVT_BLK.PM1a_EN: enable register */
-        };
-        uint32_t evt_blk;
-    };
-    uint32_t tmr_val;   /* PM_TMR_BLK.TMR_VAL: 32bit free-running counter */
-};
-
-struct hvm_hw_ia64_vacpi {
-    struct vacpi_regs   regs;
-};
-DECLARE_HVM_SAVE_TYPE(VACPI, 7, struct hvm_hw_ia64_vacpi);
-/* update last_gtime and setup timer of struct vacpi */
-
-/*
- * opt_feature: identity mapping of region 4, 5 and 7.
- * With the c/s 16396:d2935f9c217f of xen-ia64-devel.hg,
- * opt_feature hypercall supports only region 4,5,7 identity mappings.
- * structure hvm_hw_ia64_identity_mappings only supports them.
- * The new structure, struct hvm_hw_ia64_identity_mappings, is created to
- * avoid to keep up with change of the xen/ia64 internal structure, struct
- * opt_feature.
- *
- * If it is enhanced in the future, new structure will be created.
- */
-struct hvm_hw_ia64_identity_mapping {
-    uint64_t on;        /* on/off */
-    uint64_t pgprot;    /* The page protection bit mask of the pte. */
-    uint64_t key;       /* A protection key. */
-};
-
-struct hvm_hw_ia64_identity_mappings {
-    struct hvm_hw_ia64_identity_mapping im_reg4;/* Region 4 identity mapping */
-    struct hvm_hw_ia64_identity_mapping im_reg5;/* Region 5 identity mapping */
-    struct hvm_hw_ia64_identity_mapping im_reg7;/* Region 7 identity mapping */
-};
-DECLARE_HVM_SAVE_TYPE(OPT_FEATURE_IDENTITY_MAPPINGS, 8, struct hvm_hw_ia64_identity_mappings);
-
-/* 
- * Largest type-code in use
- */
-#define HVM_SAVE_CODE_MAX       8
-
-#endif /* __XEN_PUBLIC_HVM_SAVE_IA64_H__ */
-
-/*
- * Local variables:
- * mode: C
- * c-set-style: "BSD"
- * c-basic-offset: 4
- * tab-width: 4
- * indent-tabs-mode: nil
- * End:
- */
diff -Nru xen-4.2.1-new/extras/mini-os/include/xen/arch-ia64/sioemu.h xen-4.2.1/extras/mini-os/include/xen/arch-ia64/sioemu.h
--- xen-4.2.1-new/extras/mini-os/include/xen/arch-ia64/sioemu.h	2012-12-17 23:01:56.000000000 +0800
+++ xen-4.2.1/extras/mini-os/include/xen/arch-ia64/sioemu.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,92 +0,0 @@
-/******************************************************************************
- * sioemu.h
- *
- * Copyright (c) 2008 Tristan Gingold <tgingold@free.fr>
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- */
-
-#ifndef __XEN_PUBLIC_IA64_SIOEMU_H__
-#define __XEN_PUBLIC_IA64_SIOEMU_H__
-
-/* SIOEMU specific hypercalls.
-   The numbers are the minor part of FW_HYPERCALL_SIOEMU.  */
-
-/* Defines the callback entry point.  r8=ip, r9=data.
-   Must be called per-vcpu.  */
-#define SIOEMU_HYPERCALL_SET_CALLBACK 0x01
-
-/* Finish sioemu fw initialization and start firmware.  r8=ip.  */
-#define SIOEMU_HYPERCALL_START_FW 0x02
-
-/* Add IO pages in physmap.  */
-#define SIOEMU_HYPERCALL_ADD_IO_PHYSMAP 0x03
-
-/* Get wallclock time.  */
-#define SIOEMU_HYPERCALL_GET_TIME 0x04
-
-/* Flush cache.  */
-#define SIOEMU_HYPERCALL_FLUSH_CACHE 0x07
-
-/* Get freq base.  */
-#define SIOEMU_HYPERCALL_FREQ_BASE 0x08
-
-/* Return from callback.  */
-#define SIOEMU_HYPERCALL_CALLBACK_RETURN 0x09
-
-/* Deliver an interrupt.  */
-#define SIOEMU_HYPERCALL_DELIVER_INT 0x0a
-
-/* SIOEMU callback reason.  */
-
-/* An event (from event channel) has to be delivered.  */
-#define SIOEMU_CB_EVENT       0x00
-
-/* Emulate an IO access.  */
-#define SIOEMU_CB_IO_EMULATE  0x01
-
-/* An IPI is sent to a dead vcpu.  */
-#define SIOEMU_CB_WAKEUP_VCPU 0x02
-
-/* A SAL hypercall is executed.  */
-#define SIOEMU_CB_SAL_ASSIST  0x03
-
-#ifndef __ASSEMBLY__
-struct sioemu_callback_info {
-    /* Saved registers.  */
-    unsigned long ip;
-    unsigned long psr;
-    unsigned long ifs;
-    unsigned long nats;
-    unsigned long r8;
-    unsigned long r9;
-    unsigned long r10;
-    unsigned long r11;
-
-    /* Callback parameters.  */
-    unsigned long cause;
-    unsigned long arg0;
-    unsigned long arg1;
-    unsigned long arg2;
-    unsigned long arg3;
-    unsigned long _pad2[2];
-    unsigned long r2;
-};
-#endif /* __ASSEMBLY__ */
-#endif /* __XEN_PUBLIC_IA64_SIOEMU_H__ */
diff -Nru xen-4.2.1-new/extras/mini-os/include/xen/arch-ia64.h xen-4.2.1/extras/mini-os/include/xen/arch-ia64.h
--- xen-4.2.1-new/extras/mini-os/include/xen/arch-ia64.h	2014-08-23 21:01:22.000000000 +0800
+++ xen-4.2.1/extras/mini-os/include/xen/arch-ia64.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,637 +0,0 @@
-/******************************************************************************
- * arch-ia64/hypervisor-if.h
- * 
- * Guest OS interface to IA64 Xen.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- */
-
-#include "xen.h"
-
-#ifndef __HYPERVISOR_IF_IA64_H__
-#define __HYPERVISOR_IF_IA64_H__
-
-#if !defined(__GNUC__) || defined(__STRICT_ANSI__)
-#error "Anonymous structs/unions are a GNU extension."
-#endif
-
-/* Structural guest handles introduced in 0x00030201. */
-#if __XEN_INTERFACE_VERSION__ >= 0x00030201
-#define ___DEFINE_XEN_GUEST_HANDLE(name, type) \
-    typedef struct { type *p; } __guest_handle_ ## name
-#else
-#define ___DEFINE_XEN_GUEST_HANDLE(name, type) \
-    typedef type * __guest_handle_ ## name
-#endif
-
-#define __DEFINE_XEN_GUEST_HANDLE(name, type) \
-    ___DEFINE_XEN_GUEST_HANDLE(name, type);   \
-    ___DEFINE_XEN_GUEST_HANDLE(const_##name, const type)
-
-#define DEFINE_XEN_GUEST_HANDLE(name)   __DEFINE_XEN_GUEST_HANDLE(name, name)
-#define XEN_GUEST_HANDLE(name)          __guest_handle_ ## name
-#define XEN_GUEST_HANDLE_64(name)       XEN_GUEST_HANDLE(name)
-#define uint64_aligned_t                uint64_t
-#define set_xen_guest_handle_raw(hnd, val)  do { (hnd).p = val; } while (0)
-#ifdef __XEN_TOOLS__
-#define get_xen_guest_handle(val, hnd)  do { val = (hnd).p; } while (0)
-#endif
-#define set_xen_guest_handle(hnd, val) set_xen_guest_handle_raw(hnd, val)
-
-#ifndef __ASSEMBLY__
-typedef unsigned long xen_pfn_t;
-#define PRI_xen_pfn "lx"
-#endif
-
-/* Arch specific VIRQs definition */
-#define VIRQ_ITC        VIRQ_ARCH_0 /* V. Virtual itc timer */
-#define VIRQ_MCA_CMC    VIRQ_ARCH_1 /* MCA cmc interrupt */
-#define VIRQ_MCA_CPE    VIRQ_ARCH_2 /* MCA cpe interrupt */
-
-/* Maximum number of virtual CPUs in multi-processor guests. */
-/* WARNING: before changing this, check that shared_info fits on a page */
-#define XEN_LEGACY_MAX_VCPUS 64
-
-/* IO ports location for PV.  */
-#define IO_PORTS_PADDR          0x00000ffffc000000UL
-#define IO_PORTS_SIZE           0x0000000004000000UL
-
-#ifndef __ASSEMBLY__
-
-typedef unsigned long xen_ulong_t;
-
-#ifdef __XEN_TOOLS__
-#define XEN_PAGE_SIZE XC_PAGE_SIZE
-#else
-#define XEN_PAGE_SIZE PAGE_SIZE
-#endif
-
-#define INVALID_MFN       (~0UL)
-
-struct pt_fpreg {
-    union {
-        unsigned long bits[2];
-        long double __dummy;    /* force 16-byte alignment */
-    } u;
-};
-
-union vac {
-    unsigned long value;
-    struct {
-        int a_int:1;
-        int a_from_int_cr:1;
-        int a_to_int_cr:1;
-        int a_from_psr:1;
-        int a_from_cpuid:1;
-        int a_cover:1;
-        int a_bsw:1;
-        long reserved:57;
-    };
-};
-typedef union vac vac_t;
-
-union vdc {
-    unsigned long value;
-    struct {
-        int d_vmsw:1;
-        int d_extint:1;
-        int d_ibr_dbr:1;
-        int d_pmc:1;
-        int d_to_pmd:1;
-        int d_itm:1;
-        long reserved:58;
-    };
-};
-typedef union vdc vdc_t;
-
-struct mapped_regs {
-    union vac   vac;
-    union vdc   vdc;
-    unsigned long  virt_env_vaddr;
-    unsigned long  reserved1[29];
-    unsigned long  vhpi;
-    unsigned long  reserved2[95];
-    union {
-        unsigned long  vgr[16];
-        unsigned long bank1_regs[16]; // bank1 regs (r16-r31) when bank0 active
-    };
-    union {
-        unsigned long  vbgr[16];
-        unsigned long bank0_regs[16]; // bank0 regs (r16-r31) when bank1 active
-    };
-    unsigned long  vnat;
-    unsigned long  vbnat;
-    unsigned long  vcpuid[5];
-    unsigned long  reserved3[11];
-    unsigned long  vpsr;
-    unsigned long  vpr;
-    unsigned long  reserved4[76];
-    union {
-        unsigned long  vcr[128];
-        struct {
-            unsigned long dcr;  // CR0
-            unsigned long itm;
-            unsigned long iva;
-            unsigned long rsv1[5];
-            unsigned long pta;  // CR8
-            unsigned long rsv2[7];
-            unsigned long ipsr;  // CR16
-            unsigned long isr;
-            unsigned long rsv3;
-            unsigned long iip;
-            unsigned long ifa;
-            unsigned long itir;
-            unsigned long iipa;
-            unsigned long ifs;
-            unsigned long iim;  // CR24
-            unsigned long iha;
-            unsigned long rsv4[38];
-            unsigned long lid;  // CR64
-            unsigned long ivr;
-            unsigned long tpr;
-            unsigned long eoi;
-            unsigned long irr[4];
-            unsigned long itv;  // CR72
-            unsigned long pmv;
-            unsigned long cmcv;
-            unsigned long rsv5[5];
-            unsigned long lrr0;  // CR80
-            unsigned long lrr1;
-            unsigned long rsv6[46];
-        };
-    };
-    union {
-        unsigned long  reserved5[128];
-        struct {
-            unsigned long precover_ifs;
-            unsigned long unat;  // not sure if this is needed until NaT arch is done
-            int interrupt_collection_enabled; // virtual psr.ic
-            /* virtual interrupt deliverable flag is evtchn_upcall_mask in
-             * shared info area now. interrupt_mask_addr is the address
-             * of evtchn_upcall_mask for current vcpu
-             */
-            unsigned char *interrupt_mask_addr;
-            int pending_interruption;
-            unsigned char vpsr_pp;
-            unsigned char vpsr_dfh;
-            unsigned char hpsr_dfh;
-            unsigned char hpsr_mfh;
-            unsigned long reserved5_1[4];
-            int metaphysical_mode; // 1 = use metaphys mapping, 0 = use virtual
-            int banknum; // 0 or 1, which virtual register bank is active
-            unsigned long rrs[8]; // region registers
-            unsigned long krs[8]; // kernel registers
-            unsigned long tmp[16]; // temp registers (e.g. for hyperprivops)
-
-            /* itc paravirtualization
-             * vAR.ITC = mAR.ITC + itc_offset
-             * itc_last is one which was lastly passed to
-             * the guest OS in order to prevent it from
-             * going backwords.
-             */
-            unsigned long itc_offset;
-            unsigned long itc_last;
-        };
-    };
-};
-typedef struct mapped_regs mapped_regs_t;
-
-struct vpd {
-    struct mapped_regs vpd_low;
-    unsigned long  reserved6[3456];
-    unsigned long  vmm_avail[128];
-    unsigned long  reserved7[4096];
-};
-typedef struct vpd vpd_t;
-
-struct arch_vcpu_info {
-};
-typedef struct arch_vcpu_info arch_vcpu_info_t;
-
-/*
- * This structure is used for magic page in domain pseudo physical address
- * space and the result of XENMEM_machine_memory_map.
- * As the XENMEM_machine_memory_map result,
- * xen_memory_map::nr_entries indicates the size in bytes 
- * including struct xen_ia64_memmap_info. Not the number of entries.
- */
-struct xen_ia64_memmap_info {
-    uint64_t efi_memmap_size;       /* size of EFI memory map */
-    uint64_t efi_memdesc_size;      /* size of an EFI memory map descriptor */
-    uint32_t efi_memdesc_version;   /* memory descriptor version */
-    void *memdesc[0];               /* array of efi_memory_desc_t */
-};
-typedef struct xen_ia64_memmap_info xen_ia64_memmap_info_t;
-
-struct arch_shared_info {
-    /* PFN of the start_info page.  */
-    unsigned long start_info_pfn;
-
-    /* Interrupt vector for event channel.  */
-    int evtchn_vector;
-
-    /* PFN of memmap_info page */
-    unsigned int memmap_info_num_pages;/* currently only = 1 case is
-                                          supported. */
-    unsigned long memmap_info_pfn;
-
-    uint64_t pad[31];
-};
-typedef struct arch_shared_info arch_shared_info_t;
-
-typedef unsigned long xen_callback_t;
-
-struct ia64_tr_entry {
-    unsigned long pte;
-    unsigned long itir;
-    unsigned long vadr;
-    unsigned long rid;
-};
-typedef struct ia64_tr_entry ia64_tr_entry_t;
-DEFINE_XEN_GUEST_HANDLE(ia64_tr_entry_t);
-
-struct vcpu_tr_regs {
-    struct ia64_tr_entry itrs[12];
-    struct ia64_tr_entry dtrs[12];
-};
-
-union vcpu_ar_regs {
-    unsigned long ar[128];
-    struct {
-        unsigned long kr[8];
-        unsigned long rsv1[8];
-        unsigned long rsc;
-        unsigned long bsp;
-        unsigned long bspstore;
-        unsigned long rnat;
-        unsigned long rsv2;
-        unsigned long fcr;
-        unsigned long rsv3[2];
-        unsigned long eflag;
-        unsigned long csd;
-        unsigned long ssd;
-        unsigned long cflg;
-        unsigned long fsr;
-        unsigned long fir;
-        unsigned long fdr;
-        unsigned long rsv4;
-        unsigned long ccv; /* 32 */
-        unsigned long rsv5[3];
-        unsigned long unat;
-        unsigned long rsv6[3];
-        unsigned long fpsr;
-        unsigned long rsv7[3];
-        unsigned long itc;
-        unsigned long rsv8[3];
-        unsigned long ign1[16];
-        unsigned long pfs; /* 64 */
-        unsigned long lc;
-        unsigned long ec;
-        unsigned long rsv9[45];
-        unsigned long ign2[16];
-    };
-};
-
-union vcpu_cr_regs {
-    unsigned long cr[128];
-    struct {
-        unsigned long dcr;  // CR0
-        unsigned long itm;
-        unsigned long iva;
-        unsigned long rsv1[5];
-        unsigned long pta;  // CR8
-        unsigned long rsv2[7];
-        unsigned long ipsr;  // CR16
-        unsigned long isr;
-        unsigned long rsv3;
-        unsigned long iip;
-        unsigned long ifa;
-        unsigned long itir;
-        unsigned long iipa;
-        unsigned long ifs;
-        unsigned long iim;  // CR24
-        unsigned long iha;
-        unsigned long rsv4[38];
-        unsigned long lid;  // CR64
-        unsigned long ivr;
-        unsigned long tpr;
-        unsigned long eoi;
-        unsigned long irr[4];
-        unsigned long itv;  // CR72
-        unsigned long pmv;
-        unsigned long cmcv;
-        unsigned long rsv5[5];
-        unsigned long lrr0;  // CR80
-        unsigned long lrr1;
-        unsigned long rsv6[46];
-    };
-};
-
-struct vcpu_guest_context_regs {
-        unsigned long r[32];
-        unsigned long b[8];
-        unsigned long bank[16];
-        unsigned long ip;
-        unsigned long psr;
-        unsigned long cfm;
-        unsigned long pr;
-        unsigned int nats; /* NaT bits for r1-r31.  */
-        unsigned int bnats; /* Nat bits for banked registers.  */
-        union vcpu_ar_regs ar;
-        union vcpu_cr_regs cr;
-        struct pt_fpreg f[128];
-        unsigned long dbr[8];
-        unsigned long ibr[8];
-        unsigned long rr[8];
-        unsigned long pkr[16];
-
-        /* FIXME: cpuid,pmd,pmc */
-
-        unsigned long xip;
-        unsigned long xpsr;
-        unsigned long xfs;
-        unsigned long xr[4];
-
-        struct vcpu_tr_regs tr;
-
-        /* Physical registers in case of debug event.  */
-        unsigned long excp_iipa;
-        unsigned long excp_ifa;
-        unsigned long excp_isr;
-        unsigned int excp_vector;
-
-        /*
-         * The rbs is intended to be the image of the stacked registers still
-         * in the cpu (not yet stored in memory).  It is laid out as if it
-         * were written in memory at a 512 (64*8) aligned address + offset.
-         * rbs_voff is (offset / 8).  rbs_nat contains NaT bits for the
-         * remaining rbs registers.  rbs_rnat contains NaT bits for in memory
-         * rbs registers.
-         * Note: loadrs is 2**14 bytes == 2**11 slots.
-         */
-        unsigned int rbs_voff;
-        unsigned long rbs[2048];
-        unsigned long rbs_rnat;
-
-        /*
-         * RSE.N_STACKED_PHYS via PAL_RSE_INFO
-         * Strictly this isn't cpu context, but this value is necessary
-         * for domain save/restore. So is here.
-         */
-        unsigned long num_phys_stacked;
-};
-
-struct vcpu_guest_context {
-#define VGCF_EXTRA_REGS (1UL << 1)	/* Set extra regs.  */
-#define VGCF_SET_CR_IRR (1UL << 2)	/* Set cr_irr[0:3]. */
-#define VGCF_online     (1UL << 3)  /* make this vcpu online */
-#define VGCF_SET_AR_ITC (1UL << 4)  /* set pv ar.itc. itc_offset, itc_last */
-    unsigned long flags;       /* VGCF_* flags */
-
-    struct vcpu_guest_context_regs regs;
-
-    unsigned long event_callback_ip;
-
-    /* xen doesn't share privregs pages with hvm domain so that this member
-     * doesn't make sense for hvm domain.
-     * ~0UL is already used for INVALID_P2M_ENTRY. */
-#define VGC_PRIVREGS_HVM       (~(-2UL))
-    unsigned long privregs_pfn;
-};
-typedef struct vcpu_guest_context vcpu_guest_context_t;
-DEFINE_XEN_GUEST_HANDLE(vcpu_guest_context_t);
-
-/* dom0 vp op */
-#define __HYPERVISOR_ia64_dom0vp_op     __HYPERVISOR_arch_0
-/*  Map io space in machine address to dom0 physical address space.
-    Currently physical assigned address equals to machine address.  */
-#define IA64_DOM0VP_ioremap             0
-
-/* Convert a pseudo physical page frame number to the corresponding
-   machine page frame number. If no page is assigned, INVALID_MFN or
-   GPFN_INV_MASK is returned depending on domain's non-vti/vti mode.  */
-#define IA64_DOM0VP_phystomach          1
-
-/* Convert a machine page frame number to the corresponding pseudo physical
-   page frame number of the caller domain.  */
-#define IA64_DOM0VP_machtophys          3
-
-/* Reserved for future use.  */
-#define IA64_DOM0VP_iounmap             4
-
-/* Unmap and free pages contained in the specified pseudo physical region.  */
-#define IA64_DOM0VP_zap_physmap         5
-
-/* Assign machine page frame to dom0's pseudo physical address space.  */
-#define IA64_DOM0VP_add_physmap         6
-
-/* expose the p2m table into domain */
-#define IA64_DOM0VP_expose_p2m          7
-
-/* xen perfmon */
-#define IA64_DOM0VP_perfmon             8
-
-/* gmfn version of IA64_DOM0VP_add_physmap */
-#define IA64_DOM0VP_add_physmap_with_gmfn       9
-
-/* get fpswa revision */
-#define IA64_DOM0VP_fpswa_revision      10
-
-/* Add an I/O port space range */
-#define IA64_DOM0VP_add_io_space        11
-
-/* expose the foreign domain's p2m table into privileged domain */
-#define IA64_DOM0VP_expose_foreign_p2m  12
-#define         IA64_DOM0VP_EFP_ALLOC_PTE       0x1 /* allocate p2m table */
-
-/* unexpose the foreign domain's p2m table into privileged domain */
-#define IA64_DOM0VP_unexpose_foreign_p2m        13
-
-/* get memmap_info and memmap. It is possible to map the page directly
-   by foreign page mapping, but there is a race between writer.
-   This hypercall avoids such race. */
-#define IA64_DOM0VP_get_memmap          14
-
-// flags for page assignement to pseudo physical address space
-#define _ASSIGN_readonly                0
-#define ASSIGN_readonly                 (1UL << _ASSIGN_readonly)
-#define ASSIGN_writable                 (0UL << _ASSIGN_readonly) // dummy flag
-/* Internal only: memory attribute must be WC/UC/UCE.  */
-#define _ASSIGN_nocache                 1
-#define ASSIGN_nocache                  (1UL << _ASSIGN_nocache)
-// tlb tracking
-#define _ASSIGN_tlb_track               2
-#define ASSIGN_tlb_track                (1UL << _ASSIGN_tlb_track)
-/* Internal only: associated with PGC_allocated bit */
-#define _ASSIGN_pgc_allocated           3
-#define ASSIGN_pgc_allocated            (1UL << _ASSIGN_pgc_allocated)
-/* Page is an IO page.  */
-#define _ASSIGN_io                      4
-#define ASSIGN_io                       (1UL << _ASSIGN_io)
-
-/* This structure has the same layout of struct ia64_boot_param, defined in
-   <asm/system.h>.  It is redefined here to ease use.  */
-struct xen_ia64_boot_param {
-	unsigned long command_line;	/* physical address of cmd line args */
-	unsigned long efi_systab;	/* physical address of EFI system table */
-	unsigned long efi_memmap;	/* physical address of EFI memory map */
-	unsigned long efi_memmap_size;	/* size of EFI memory map */
-	unsigned long efi_memdesc_size;	/* size of an EFI memory map descriptor */
-	unsigned int  efi_memdesc_version;	/* memory descriptor version */
-	struct {
-		unsigned short num_cols;	/* number of columns on console.  */
-		unsigned short num_rows;	/* number of rows on console.  */
-		unsigned short orig_x;	/* cursor's x position */
-		unsigned short orig_y;	/* cursor's y position */
-	} console_info;
-	unsigned long fpswa;		/* physical address of the fpswa interface */
-	unsigned long initrd_start;
-	unsigned long initrd_size;
-	unsigned long domain_start;	/* va where the boot time domain begins */
-	unsigned long domain_size;	/* how big is the boot domain */
-};
-
-#endif /* !__ASSEMBLY__ */
-
-/* Size of the shared_info area (this is not related to page size).  */
-#define XSI_SHIFT			14
-#define XSI_SIZE			(1 << XSI_SHIFT)
-/* Log size of mapped_regs area (64 KB - only 4KB is used).  */
-#define XMAPPEDREGS_SHIFT		12
-#define XMAPPEDREGS_SIZE		(1 << XMAPPEDREGS_SHIFT)
-/* Offset of XASI (Xen arch shared info) wrt XSI_BASE.  */
-#define XMAPPEDREGS_OFS			XSI_SIZE
-
-/* Hyperprivops.  */
-#define HYPERPRIVOP_START		0x1
-#define HYPERPRIVOP_RFI			(HYPERPRIVOP_START + 0x0)
-#define HYPERPRIVOP_RSM_DT		(HYPERPRIVOP_START + 0x1)
-#define HYPERPRIVOP_SSM_DT		(HYPERPRIVOP_START + 0x2)
-#define HYPERPRIVOP_COVER		(HYPERPRIVOP_START + 0x3)
-#define HYPERPRIVOP_ITC_D		(HYPERPRIVOP_START + 0x4)
-#define HYPERPRIVOP_ITC_I		(HYPERPRIVOP_START + 0x5)
-#define HYPERPRIVOP_SSM_I		(HYPERPRIVOP_START + 0x6)
-#define HYPERPRIVOP_GET_IVR		(HYPERPRIVOP_START + 0x7)
-#define HYPERPRIVOP_GET_TPR		(HYPERPRIVOP_START + 0x8)
-#define HYPERPRIVOP_SET_TPR		(HYPERPRIVOP_START + 0x9)
-#define HYPERPRIVOP_EOI			(HYPERPRIVOP_START + 0xa)
-#define HYPERPRIVOP_SET_ITM		(HYPERPRIVOP_START + 0xb)
-#define HYPERPRIVOP_THASH		(HYPERPRIVOP_START + 0xc)
-#define HYPERPRIVOP_PTC_GA		(HYPERPRIVOP_START + 0xd)
-#define HYPERPRIVOP_ITR_D		(HYPERPRIVOP_START + 0xe)
-#define HYPERPRIVOP_GET_RR		(HYPERPRIVOP_START + 0xf)
-#define HYPERPRIVOP_SET_RR		(HYPERPRIVOP_START + 0x10)
-#define HYPERPRIVOP_SET_KR		(HYPERPRIVOP_START + 0x11)
-#define HYPERPRIVOP_FC			(HYPERPRIVOP_START + 0x12)
-#define HYPERPRIVOP_GET_CPUID		(HYPERPRIVOP_START + 0x13)
-#define HYPERPRIVOP_GET_PMD		(HYPERPRIVOP_START + 0x14)
-#define HYPERPRIVOP_GET_EFLAG		(HYPERPRIVOP_START + 0x15)
-#define HYPERPRIVOP_SET_EFLAG		(HYPERPRIVOP_START + 0x16)
-#define HYPERPRIVOP_RSM_BE		(HYPERPRIVOP_START + 0x17)
-#define HYPERPRIVOP_GET_PSR		(HYPERPRIVOP_START + 0x18)
-#define HYPERPRIVOP_SET_RR0_TO_RR4	(HYPERPRIVOP_START + 0x19)
-#define HYPERPRIVOP_MAX			(0x1a)
-
-/* Fast and light hypercalls.  */
-#define __HYPERVISOR_ia64_fast_eoi	__HYPERVISOR_arch_1
-
-/* Extra debug features.  */
-#define __HYPERVISOR_ia64_debug_op  __HYPERVISOR_arch_2
-
-/* Xencomm macros.  */
-#define XENCOMM_INLINE_MASK 0xf800000000000000UL
-#define XENCOMM_INLINE_FLAG 0x8000000000000000UL
-
-#ifndef __ASSEMBLY__
-
-/*
- * Optimization features.
- * The hypervisor may do some special optimizations for guests. This hypercall
- * can be used to switch on/of these special optimizations.
- */
-#define __HYPERVISOR_opt_feature	0x700UL
-
-#define XEN_IA64_OPTF_OFF	0x0
-#define XEN_IA64_OPTF_ON	0x1
-
-/*
- * If this feature is switched on, the hypervisor inserts the
- * tlb entries without calling the guests traphandler.
- * This is useful in guests using region 7 for identity mapping
- * like the linux kernel does.
- */
-#define XEN_IA64_OPTF_IDENT_MAP_REG7    1
-
-/* Identity mapping of region 4 addresses in HVM. */
-#define XEN_IA64_OPTF_IDENT_MAP_REG4    2
-
-/* Identity mapping of region 5 addresses in HVM. */
-#define XEN_IA64_OPTF_IDENT_MAP_REG5    3
-
-#define XEN_IA64_OPTF_IDENT_MAP_NOT_SET  (0)
-
-struct xen_ia64_opt_feature {
-	unsigned long cmd;		/* Which feature */
-	unsigned char on;		/* Switch feature on/off */
-	union {
-		struct {
-				/* The page protection bit mask of the pte.
-			 	 * This will be or'ed with the pte. */
-			unsigned long pgprot;
-			unsigned long key;	/* A protection key for itir. */
-		};
-	};
-};
-
-#endif /* __ASSEMBLY__ */
-
-/* xen perfmon */
-#ifdef XEN
-#ifndef __ASSEMBLY__
-#ifndef _ASM_IA64_PERFMON_H
-
-#include <xen/list.h>   // asm/perfmon.h requires struct list_head
-#include <asm/perfmon.h>
-// for PFM_xxx and pfarg_features_t, pfarg_context_t, pfarg_reg_t, pfarg_load_t
-
-#endif /* _ASM_IA64_PERFMON_H */
-
-DEFINE_XEN_GUEST_HANDLE(pfarg_features_t);
-DEFINE_XEN_GUEST_HANDLE(pfarg_context_t);
-DEFINE_XEN_GUEST_HANDLE(pfarg_reg_t);
-DEFINE_XEN_GUEST_HANDLE(pfarg_load_t);
-#endif /* __ASSEMBLY__ */
-#endif /* XEN */
-
-#ifndef __ASSEMBLY__
-#include "arch-ia64/hvm/memmap.h"
-#endif
-
-#endif /* __HYPERVISOR_IF_IA64_H__ */
-
-/*
- * Local variables:
- * mode: C
- * c-set-style: "BSD"
- * c-basic-offset: 4
- * tab-width: 4
- * indent-tabs-mode: nil
- * End:
- */
diff -Nru xen-4.2.1-new/extras/mini-os/include/xen/arch-x86/cpuid.h xen-4.2.1/extras/mini-os/include/xen/arch-x86/cpuid.h
--- xen-4.2.1-new/extras/mini-os/include/xen/arch-x86/cpuid.h	2012-12-17 23:01:56.000000000 +0800
+++ xen-4.2.1/extras/mini-os/include/xen/arch-x86/cpuid.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,68 +0,0 @@
-/******************************************************************************
- * arch-x86/cpuid.h
- * 
- * CPUID interface to Xen.
- * 
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- * 
- * Copyright (c) 2007 Citrix Systems, Inc.
- * 
- * Authors:
- *    Keir Fraser <keir@xen.org>
- */
-
-#ifndef __XEN_PUBLIC_ARCH_X86_CPUID_H__
-#define __XEN_PUBLIC_ARCH_X86_CPUID_H__
-
-/* Xen identification leaves start at 0x40000000. */
-#define XEN_CPUID_FIRST_LEAF 0x40000000
-#define XEN_CPUID_LEAF(i)    (XEN_CPUID_FIRST_LEAF + (i))
-
-/*
- * Leaf 1 (0x40000000)
- * EAX: Largest Xen-information leaf. All leaves up to an including @EAX
- *      are supported by the Xen host.
- * EBX-EDX: "XenVMMXenVMM" signature, allowing positive identification
- *      of a Xen host.
- */
-#define XEN_CPUID_SIGNATURE_EBX 0x566e6558 /* "XenV" */
-#define XEN_CPUID_SIGNATURE_ECX 0x65584d4d /* "MMXe" */
-#define XEN_CPUID_SIGNATURE_EDX 0x4d4d566e /* "nVMM" */
-
-/*
- * Leaf 2 (0x40000001)
- * EAX[31:16]: Xen major version.
- * EAX[15: 0]: Xen minor version.
- * EBX-EDX: Reserved (currently all zeroes).
- */
-
-/*
- * Leaf 3 (0x40000002)
- * EAX: Number of hypercall transfer pages. This register is always guaranteed
- *      to specify one hypercall page.
- * EBX: Base address of Xen-specific MSRs.
- * ECX: Features 1. Unused bits are set to zero.
- * EDX: Features 2. Unused bits are set to zero.
- */
-
-/* Does the host support MMU_PT_UPDATE_PRESERVE_AD for this guest? */
-#define _XEN_CPUID_FEAT1_MMU_PT_UPDATE_PRESERVE_AD 0
-#define XEN_CPUID_FEAT1_MMU_PT_UPDATE_PRESERVE_AD  (1u<<0)
-
-#endif /* __XEN_PUBLIC_ARCH_X86_CPUID_H__ */
diff -Nru xen-4.2.1-new/extras/mini-os/include/xen/arch-x86/hvm/save.h xen-4.2.1/extras/mini-os/include/xen/arch-x86/hvm/save.h
--- xen-4.2.1-new/extras/mini-os/include/xen/arch-x86/hvm/save.h	2012-12-17 23:01:56.000000000 +0800
+++ xen-4.2.1/extras/mini-os/include/xen/arch-x86/hvm/save.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,589 +0,0 @@
-/* 
- * Structure definitions for HVM state that is held by Xen and must
- * be saved along with the domain's memory and device-model state.
- * 
- * Copyright (c) 2007 XenSource Ltd.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- */
-
-#ifndef __XEN_PUBLIC_HVM_SAVE_X86_H__
-#define __XEN_PUBLIC_HVM_SAVE_X86_H__
-
-/* 
- * Save/restore header: general info about the save file. 
- */
-
-#define HVM_FILE_MAGIC   0x54381286
-#define HVM_FILE_VERSION 0x00000001
-
-struct hvm_save_header {
-    uint32_t magic;             /* Must be HVM_FILE_MAGIC */
-    uint32_t version;           /* File format version */
-    uint64_t changeset;         /* Version of Xen that saved this file */
-    uint32_t cpuid;             /* CPUID[0x01][%eax] on the saving machine */
-    uint32_t gtsc_khz;        /* Guest's TSC frequency in kHz */
-};
-
-DECLARE_HVM_SAVE_TYPE(HEADER, 1, struct hvm_save_header);
-
-
-/*
- * Processor
- *
- * Compat: Pre-3.4 didn't have msr_tsc_aux
- */
-
-struct hvm_hw_cpu {
-    uint8_t  fpu_regs[512];
-
-    uint64_t rax;
-    uint64_t rbx;
-    uint64_t rcx;
-    uint64_t rdx;
-    uint64_t rbp;
-    uint64_t rsi;
-    uint64_t rdi;
-    uint64_t rsp;
-    uint64_t r8;
-    uint64_t r9;
-    uint64_t r10;
-    uint64_t r11;
-    uint64_t r12;
-    uint64_t r13;
-    uint64_t r14;
-    uint64_t r15;
-
-    uint64_t rip;
-    uint64_t rflags;
-
-    uint64_t cr0;
-    uint64_t cr2;
-    uint64_t cr3;
-    uint64_t cr4;
-
-    uint64_t dr0;
-    uint64_t dr1;
-    uint64_t dr2;
-    uint64_t dr3;
-    uint64_t dr6;
-    uint64_t dr7;    
-
-    uint32_t cs_sel;
-    uint32_t ds_sel;
-    uint32_t es_sel;
-    uint32_t fs_sel;
-    uint32_t gs_sel;
-    uint32_t ss_sel;
-    uint32_t tr_sel;
-    uint32_t ldtr_sel;
-
-    uint32_t cs_limit;
-    uint32_t ds_limit;
-    uint32_t es_limit;
-    uint32_t fs_limit;
-    uint32_t gs_limit;
-    uint32_t ss_limit;
-    uint32_t tr_limit;
-    uint32_t ldtr_limit;
-    uint32_t idtr_limit;
-    uint32_t gdtr_limit;
-
-    uint64_t cs_base;
-    uint64_t ds_base;
-    uint64_t es_base;
-    uint64_t fs_base;
-    uint64_t gs_base;
-    uint64_t ss_base;
-    uint64_t tr_base;
-    uint64_t ldtr_base;
-    uint64_t idtr_base;
-    uint64_t gdtr_base;
-
-    uint32_t cs_arbytes;
-    uint32_t ds_arbytes;
-    uint32_t es_arbytes;
-    uint32_t fs_arbytes;
-    uint32_t gs_arbytes;
-    uint32_t ss_arbytes;
-    uint32_t tr_arbytes;
-    uint32_t ldtr_arbytes;
-
-    uint64_t sysenter_cs;
-    uint64_t sysenter_esp;
-    uint64_t sysenter_eip;
-
-    /* msr for em64t */
-    uint64_t shadow_gs;
-
-    /* msr content saved/restored. */
-    uint64_t msr_flags;
-    uint64_t msr_lstar;
-    uint64_t msr_star;
-    uint64_t msr_cstar;
-    uint64_t msr_syscall_mask;
-    uint64_t msr_efer;
-    uint64_t msr_tsc_aux;
-
-    /* guest's idea of what rdtsc() would return */
-    uint64_t tsc;
-
-    /* pending event, if any */
-    union {
-        uint32_t pending_event;
-        struct {
-            uint8_t  pending_vector:8;
-            uint8_t  pending_type:3;
-            uint8_t  pending_error_valid:1;
-            uint32_t pending_reserved:19;
-            uint8_t  pending_valid:1;
-        };
-    };
-    /* error code for pending event */
-    uint32_t error_code;
-};
-
-struct hvm_hw_cpu_compat {
-    uint8_t  fpu_regs[512];
-
-    uint64_t rax;
-    uint64_t rbx;
-    uint64_t rcx;
-    uint64_t rdx;
-    uint64_t rbp;
-    uint64_t rsi;
-    uint64_t rdi;
-    uint64_t rsp;
-    uint64_t r8;
-    uint64_t r9;
-    uint64_t r10;
-    uint64_t r11;
-    uint64_t r12;
-    uint64_t r13;
-    uint64_t r14;
-    uint64_t r15;
-
-    uint64_t rip;
-    uint64_t rflags;
-
-    uint64_t cr0;
-    uint64_t cr2;
-    uint64_t cr3;
-    uint64_t cr4;
-
-    uint64_t dr0;
-    uint64_t dr1;
-    uint64_t dr2;
-    uint64_t dr3;
-    uint64_t dr6;
-    uint64_t dr7;    
-
-    uint32_t cs_sel;
-    uint32_t ds_sel;
-    uint32_t es_sel;
-    uint32_t fs_sel;
-    uint32_t gs_sel;
-    uint32_t ss_sel;
-    uint32_t tr_sel;
-    uint32_t ldtr_sel;
-
-    uint32_t cs_limit;
-    uint32_t ds_limit;
-    uint32_t es_limit;
-    uint32_t fs_limit;
-    uint32_t gs_limit;
-    uint32_t ss_limit;
-    uint32_t tr_limit;
-    uint32_t ldtr_limit;
-    uint32_t idtr_limit;
-    uint32_t gdtr_limit;
-
-    uint64_t cs_base;
-    uint64_t ds_base;
-    uint64_t es_base;
-    uint64_t fs_base;
-    uint64_t gs_base;
-    uint64_t ss_base;
-    uint64_t tr_base;
-    uint64_t ldtr_base;
-    uint64_t idtr_base;
-    uint64_t gdtr_base;
-
-    uint32_t cs_arbytes;
-    uint32_t ds_arbytes;
-    uint32_t es_arbytes;
-    uint32_t fs_arbytes;
-    uint32_t gs_arbytes;
-    uint32_t ss_arbytes;
-    uint32_t tr_arbytes;
-    uint32_t ldtr_arbytes;
-
-    uint64_t sysenter_cs;
-    uint64_t sysenter_esp;
-    uint64_t sysenter_eip;
-
-    /* msr for em64t */
-    uint64_t shadow_gs;
-
-    /* msr content saved/restored. */
-    uint64_t msr_flags;
-    uint64_t msr_lstar;
-    uint64_t msr_star;
-    uint64_t msr_cstar;
-    uint64_t msr_syscall_mask;
-    uint64_t msr_efer;
-    /*uint64_t msr_tsc_aux; COMPAT */
-
-    /* guest's idea of what rdtsc() would return */
-    uint64_t tsc;
-
-    /* pending event, if any */
-    union {
-        uint32_t pending_event;
-        struct {
-            uint8_t  pending_vector:8;
-            uint8_t  pending_type:3;
-            uint8_t  pending_error_valid:1;
-            uint32_t pending_reserved:19;
-            uint8_t  pending_valid:1;
-        };
-    };
-    /* error code for pending event */
-    uint32_t error_code;
-};
-
-static inline int _hvm_hw_fix_cpu(void *h) {
-    struct hvm_hw_cpu *new=h;
-    struct hvm_hw_cpu_compat *old=h;
-
-    /* If we copy from the end backwards, we should
-     * be able to do the modification in-place */
-    new->error_code=old->error_code;
-    new->pending_event=old->pending_event;
-    new->tsc=old->tsc;
-    new->msr_tsc_aux=0;
-
-    return 0;
-}
-
-DECLARE_HVM_SAVE_TYPE_COMPAT(CPU, 2, struct hvm_hw_cpu, \
-                             struct hvm_hw_cpu_compat, _hvm_hw_fix_cpu);
-
-/*
- * PIC
- */
-
-struct hvm_hw_vpic {
-    /* IR line bitmasks. */
-    uint8_t irr;
-    uint8_t imr;
-    uint8_t isr;
-
-    /* Line IRx maps to IRQ irq_base+x */
-    uint8_t irq_base;
-
-    /*
-     * Where are we in ICW2-4 initialisation (0 means no init in progress)?
-     * Bits 0-1 (=x): Next write at A=1 sets ICW(x+1).
-     * Bit 2: ICW1.IC4  (1 == ICW4 included in init sequence)
-     * Bit 3: ICW1.SNGL (0 == ICW3 included in init sequence)
-     */
-    uint8_t init_state:4;
-
-    /* IR line with highest priority. */
-    uint8_t priority_add:4;
-
-    /* Reads from A=0 obtain ISR or IRR? */
-    uint8_t readsel_isr:1;
-
-    /* Reads perform a polling read? */
-    uint8_t poll:1;
-
-    /* Automatically clear IRQs from the ISR during INTA? */
-    uint8_t auto_eoi:1;
-
-    /* Automatically rotate IRQ priorities during AEOI? */
-    uint8_t rotate_on_auto_eoi:1;
-
-    /* Exclude slave inputs when considering in-service IRQs? */
-    uint8_t special_fully_nested_mode:1;
-
-    /* Special mask mode excludes masked IRs from AEOI and priority checks. */
-    uint8_t special_mask_mode:1;
-
-    /* Is this a master PIC or slave PIC? (NB. This is not programmable.) */
-    uint8_t is_master:1;
-
-    /* Edge/trigger selection. */
-    uint8_t elcr;
-
-    /* Virtual INT output. */
-    uint8_t int_output;
-};
-
-DECLARE_HVM_SAVE_TYPE(PIC, 3, struct hvm_hw_vpic);
-
-
-/*
- * IO-APIC
- */
-
-#define VIOAPIC_NUM_PINS  48 /* 16 ISA IRQs, 32 non-legacy PCI IRQS. */
-
-struct hvm_hw_vioapic {
-    uint64_t base_address;
-    uint32_t ioregsel;
-    uint32_t id;
-    union vioapic_redir_entry
-    {
-        uint64_t bits;
-        struct {
-            uint8_t vector;
-            uint8_t delivery_mode:3;
-            uint8_t dest_mode:1;
-            uint8_t delivery_status:1;
-            uint8_t polarity:1;
-            uint8_t remote_irr:1;
-            uint8_t trig_mode:1;
-            uint8_t mask:1;
-            uint8_t reserve:7;
-            uint8_t reserved[4];
-            uint8_t dest_id;
-        } fields;
-    } redirtbl[VIOAPIC_NUM_PINS];
-};
-
-DECLARE_HVM_SAVE_TYPE(IOAPIC, 4, struct hvm_hw_vioapic);
-
-
-/*
- * LAPIC
- */
-
-struct hvm_hw_lapic {
-    uint64_t             apic_base_msr;
-    uint32_t             disabled; /* VLAPIC_xx_DISABLED */
-    uint32_t             timer_divisor;
-    uint64_t             tdt_msr;
-};
-
-DECLARE_HVM_SAVE_TYPE(LAPIC, 5, struct hvm_hw_lapic);
-
-struct hvm_hw_lapic_regs {
-    uint8_t data[1024];
-};
-
-DECLARE_HVM_SAVE_TYPE(LAPIC_REGS, 6, struct hvm_hw_lapic_regs);
-
-
-/*
- * IRQs
- */
-
-struct hvm_hw_pci_irqs {
-    /*
-     * Virtual interrupt wires for a single PCI bus.
-     * Indexed by: device*4 + INTx#.
-     */
-    union {
-        unsigned long i[16 / sizeof (unsigned long)]; /* DECLARE_BITMAP(i, 32*4); */
-        uint64_t pad[2];
-    };
-};
-
-DECLARE_HVM_SAVE_TYPE(PCI_IRQ, 7, struct hvm_hw_pci_irqs);
-
-struct hvm_hw_isa_irqs {
-    /*
-     * Virtual interrupt wires for ISA devices.
-     * Indexed by ISA IRQ (assumes no ISA-device IRQ sharing).
-     */
-    union {
-        unsigned long i[1];  /* DECLARE_BITMAP(i, 16); */
-        uint64_t pad[1];
-    };
-};
-
-DECLARE_HVM_SAVE_TYPE(ISA_IRQ, 8, struct hvm_hw_isa_irqs);
-
-struct hvm_hw_pci_link {
-    /*
-     * PCI-ISA interrupt router.
-     * Each PCI <device:INTx#> is 'wire-ORed' into one of four links using
-     * the traditional 'barber's pole' mapping ((device + INTx#) & 3).
-     * The router provides a programmable mapping from each link to a GSI.
-     */
-    uint8_t route[4];
-    uint8_t pad0[4];
-};
-
-DECLARE_HVM_SAVE_TYPE(PCI_LINK, 9, struct hvm_hw_pci_link);
-
-/* 
- *  PIT
- */
-
-struct hvm_hw_pit {
-    struct hvm_hw_pit_channel {
-        uint32_t count; /* can be 65536 */
-        uint16_t latched_count;
-        uint8_t count_latched;
-        uint8_t status_latched;
-        uint8_t status;
-        uint8_t read_state;
-        uint8_t write_state;
-        uint8_t write_latch;
-        uint8_t rw_mode;
-        uint8_t mode;
-        uint8_t bcd; /* not supported */
-        uint8_t gate; /* timer start */
-    } channels[3];  /* 3 x 16 bytes */
-    uint32_t speaker_data_on;
-    uint32_t pad0;
-};
-
-DECLARE_HVM_SAVE_TYPE(PIT, 10, struct hvm_hw_pit);
-
-
-/* 
- * RTC
- */ 
-
-#define RTC_CMOS_SIZE 14
-struct hvm_hw_rtc {
-    /* CMOS bytes */
-    uint8_t cmos_data[RTC_CMOS_SIZE];
-    /* Index register for 2-part operations */
-    uint8_t cmos_index;
-    uint8_t pad0;
-};
-
-DECLARE_HVM_SAVE_TYPE(RTC, 11, struct hvm_hw_rtc);
-
-
-/*
- * HPET
- */
-
-#define HPET_TIMER_NUM     3    /* 3 timers supported now */
-struct hvm_hw_hpet {
-    /* Memory-mapped, software visible registers */
-    uint64_t capability;        /* capabilities */
-    uint64_t res0;              /* reserved */
-    uint64_t config;            /* configuration */
-    uint64_t res1;              /* reserved */
-    uint64_t isr;               /* interrupt status reg */
-    uint64_t res2[25];          /* reserved */
-    uint64_t mc64;              /* main counter */
-    uint64_t res3;              /* reserved */
-    struct {                    /* timers */
-        uint64_t config;        /* configuration/cap */
-        uint64_t cmp;           /* comparator */
-        uint64_t fsb;           /* FSB route, not supported now */
-        uint64_t res4;          /* reserved */
-    } timers[HPET_TIMER_NUM];
-    uint64_t res5[4*(24-HPET_TIMER_NUM)];  /* reserved, up to 0x3ff */
-
-    /* Hidden register state */
-    uint64_t period[HPET_TIMER_NUM]; /* Last value written to comparator */
-};
-
-DECLARE_HVM_SAVE_TYPE(HPET, 12, struct hvm_hw_hpet);
-
-
-/*
- * PM timer
- */
-
-struct hvm_hw_pmtimer {
-    uint32_t tmr_val;   /* PM_TMR_BLK.TMR_VAL: 32bit free-running counter */
-    uint16_t pm1a_sts;  /* PM1a_EVT_BLK.PM1a_STS: status register */
-    uint16_t pm1a_en;   /* PM1a_EVT_BLK.PM1a_EN: enable register */
-};
-
-DECLARE_HVM_SAVE_TYPE(PMTIMER, 13, struct hvm_hw_pmtimer);
-
-/*
- * MTRR MSRs
- */
-
-struct hvm_hw_mtrr {
-#define MTRR_VCNT 8
-#define NUM_FIXED_MSR 11
-    uint64_t msr_pat_cr;
-    /* mtrr physbase & physmask msr pair*/
-    uint64_t msr_mtrr_var[MTRR_VCNT*2];
-    uint64_t msr_mtrr_fixed[NUM_FIXED_MSR];
-    uint64_t msr_mtrr_cap;
-    uint64_t msr_mtrr_def_type;
-};
-
-DECLARE_HVM_SAVE_TYPE(MTRR, 14, struct hvm_hw_mtrr);
-
-/*
- * The save area of XSAVE/XRSTOR.
- */
-
-struct hvm_hw_cpu_xsave {
-    uint64_t xfeature_mask;
-    uint64_t xcr0;                 /* Updated by XSETBV */
-    uint64_t xcr0_accum;           /* Updated by XSETBV */
-    struct {
-        struct { char x[512]; } fpu_sse;
-
-        struct {
-            uint64_t xstate_bv;         /* Updated by XRSTOR */
-            uint64_t reserved[7];
-        } xsave_hdr;                    /* The 64-byte header */
-
-        struct { char x[0]; } ymm;    /* YMM */
-    } save_area;
-};
-
-#define CPU_XSAVE_CODE  16
-
-/*
- * Viridian hypervisor context.
- */
-
-struct hvm_viridian_domain_context {
-    uint64_t hypercall_gpa;
-    uint64_t guest_os_id;
-};
-
-DECLARE_HVM_SAVE_TYPE(VIRIDIAN_DOMAIN, 15, struct hvm_viridian_domain_context);
-
-struct hvm_viridian_vcpu_context {
-    uint64_t apic_assist;
-};
-
-DECLARE_HVM_SAVE_TYPE(VIRIDIAN_VCPU, 17, struct hvm_viridian_vcpu_context);
-
-struct hvm_vmce_vcpu {
-    uint64_t caps;
-};
-
-DECLARE_HVM_SAVE_TYPE(VMCE_VCPU, 18, struct hvm_vmce_vcpu);
-
-/* 
- * Largest type-code in use
- */
-#define HVM_SAVE_CODE_MAX 18
-
-#endif /* __XEN_PUBLIC_HVM_SAVE_X86_H__ */
diff -Nru xen-4.2.1-new/extras/mini-os/include/xen/arch-x86/xen.h xen-4.2.1/extras/mini-os/include/xen/arch-x86/xen.h
--- xen-4.2.1-new/extras/mini-os/include/xen/arch-x86/xen.h	2012-12-17 23:01:56.000000000 +0800
+++ xen-4.2.1/extras/mini-os/include/xen/arch-x86/xen.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,237 +0,0 @@
-/******************************************************************************
- * arch-x86/xen.h
- * 
- * Guest OS interface to x86 Xen.
- * 
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- * Copyright (c) 2004-2006, K A Fraser
- */
-
-#include "../xen.h"
-
-#ifndef __XEN_PUBLIC_ARCH_X86_XEN_H__
-#define __XEN_PUBLIC_ARCH_X86_XEN_H__
-
-/* Structural guest handles introduced in 0x00030201. */
-#if __XEN_INTERFACE_VERSION__ >= 0x00030201
-#define ___DEFINE_XEN_GUEST_HANDLE(name, type) \
-    typedef struct { type *p; } __guest_handle_ ## name
-#else
-#define ___DEFINE_XEN_GUEST_HANDLE(name, type) \
-    typedef type * __guest_handle_ ## name
-#endif
-
-#define __DEFINE_XEN_GUEST_HANDLE(name, type) \
-    ___DEFINE_XEN_GUEST_HANDLE(name, type);   \
-    ___DEFINE_XEN_GUEST_HANDLE(const_##name, const type)
-#define DEFINE_XEN_GUEST_HANDLE(name)   __DEFINE_XEN_GUEST_HANDLE(name, name)
-#define __XEN_GUEST_HANDLE(name)        __guest_handle_ ## name
-#define XEN_GUEST_HANDLE(name)          __XEN_GUEST_HANDLE(name)
-#define set_xen_guest_handle_raw(hnd, val)  do { (hnd).p = val; } while (0)
-#ifdef __XEN_TOOLS__
-#define get_xen_guest_handle(val, hnd)  do { val = (hnd).p; } while (0)
-#endif
-#define set_xen_guest_handle(hnd, val) set_xen_guest_handle_raw(hnd, val)
-
-#if defined(__i386__)
-#include "xen-x86_32.h"
-#elif defined(__x86_64__)
-#include "xen-x86_64.h"
-#endif
-
-#ifndef __ASSEMBLY__
-typedef unsigned long xen_pfn_t;
-#define PRI_xen_pfn "lx"
-#endif
-
-/*
- * SEGMENT DESCRIPTOR TABLES
- */
-/*
- * ` enum neg_errnoval
- * ` HYPERVISOR_set_gdt(const xen_pfn_t frames[], unsigned int entries);
- * `
- */
-/*
- * A number of GDT entries are reserved by Xen. These are not situated at the
- * start of the GDT because some stupid OSes export hard-coded selector values
- * in their ABI. These hard-coded values are always near the start of the GDT,
- * so Xen places itself out of the way, at the far end of the GDT.
- */
-#define FIRST_RESERVED_GDT_PAGE  14
-#define FIRST_RESERVED_GDT_BYTE  (FIRST_RESERVED_GDT_PAGE * 4096)
-#define FIRST_RESERVED_GDT_ENTRY (FIRST_RESERVED_GDT_BYTE / 8)
-
-/* Maximum number of virtual CPUs in legacy multi-processor guests. */
-#define XEN_LEGACY_MAX_VCPUS 32
-
-#ifndef __ASSEMBLY__
-
-typedef unsigned long xen_ulong_t;
-
-/*
- * ` enum neg_errnoval
- * ` HYPERVISOR_stack_switch(unsigned long ss, unsigned long esp);
- * `
- * Sets the stack segment and pointer for the current vcpu.
- */
-
-/*
- * ` enum neg_errnoval
- * ` HYPERVISOR_set_trap_table(const struct trap_info traps[]);
- * `
- */
-/*
- * Send an array of these to HYPERVISOR_set_trap_table().
- * Terminate the array with a sentinel entry, with traps[].address==0.
- * The privilege level specifies which modes may enter a trap via a software
- * interrupt. On x86/64, since rings 1 and 2 are unavailable, we allocate
- * privilege levels as follows:
- *  Level == 0: Noone may enter
- *  Level == 1: Kernel may enter
- *  Level == 2: Kernel may enter
- *  Level == 3: Everyone may enter
- */
-#define TI_GET_DPL(_ti)      ((_ti)->flags & 3)
-#define TI_GET_IF(_ti)       ((_ti)->flags & 4)
-#define TI_SET_DPL(_ti,_dpl) ((_ti)->flags |= (_dpl))
-#define TI_SET_IF(_ti,_if)   ((_ti)->flags |= ((!!(_if))<<2))
-struct trap_info {
-    uint8_t       vector;  /* exception vector                              */
-    uint8_t       flags;   /* 0-3: privilege level; 4: clear event enable?  */
-    uint16_t      cs;      /* code selector                                 */
-    unsigned long address; /* code offset                                   */
-};
-typedef struct trap_info trap_info_t;
-DEFINE_XEN_GUEST_HANDLE(trap_info_t);
-
-typedef uint64_t tsc_timestamp_t; /* RDTSC timestamp */
-
-/*
- * The following is all CPU context. Note that the fpu_ctxt block is filled 
- * in by FXSAVE if the CPU has feature FXSR; otherwise FSAVE is used.
- */
-struct vcpu_guest_context {
-    /* FPU registers come first so they can be aligned for FXSAVE/FXRSTOR. */
-    struct { char x[512]; } fpu_ctxt;       /* User-level FPU registers     */
-#define VGCF_I387_VALID                (1<<0)
-#define VGCF_IN_KERNEL                 (1<<2)
-#define _VGCF_i387_valid               0
-#define VGCF_i387_valid                (1<<_VGCF_i387_valid)
-#define _VGCF_in_kernel                2
-#define VGCF_in_kernel                 (1<<_VGCF_in_kernel)
-#define _VGCF_failsafe_disables_events 3
-#define VGCF_failsafe_disables_events  (1<<_VGCF_failsafe_disables_events)
-#define _VGCF_syscall_disables_events  4
-#define VGCF_syscall_disables_events   (1<<_VGCF_syscall_disables_events)
-#define _VGCF_online                   5
-#define VGCF_online                    (1<<_VGCF_online)
-    unsigned long flags;                    /* VGCF_* flags                 */
-    struct cpu_user_regs user_regs;         /* User-level CPU registers     */
-    struct trap_info trap_ctxt[256];        /* Virtual IDT                  */
-    unsigned long ldt_base, ldt_ents;       /* LDT (linear address, # ents) */
-    unsigned long gdt_frames[16], gdt_ents; /* GDT (machine frames, # ents) */
-    unsigned long kernel_ss, kernel_sp;     /* Virtual TSS (only SS1/SP1)   */
-    /* NB. User pagetable on x86/64 is placed in ctrlreg[1]. */
-    unsigned long ctrlreg[8];               /* CR0-CR7 (control registers)  */
-    unsigned long debugreg[8];              /* DB0-DB7 (debug registers)    */
-#ifdef __i386__
-    unsigned long event_callback_cs;        /* CS:EIP of event callback     */
-    unsigned long event_callback_eip;
-    unsigned long failsafe_callback_cs;     /* CS:EIP of failsafe callback  */
-    unsigned long failsafe_callback_eip;
-#else
-    unsigned long event_callback_eip;
-    unsigned long failsafe_callback_eip;
-#ifdef __XEN__
-    union {
-        unsigned long syscall_callback_eip;
-        struct {
-            unsigned int event_callback_cs;    /* compat CS of event cb     */
-            unsigned int failsafe_callback_cs; /* compat CS of failsafe cb  */
-        };
-    };
-#else
-    unsigned long syscall_callback_eip;
-#endif
-#endif
-    unsigned long vm_assist;                /* VMASST_TYPE_* bitmap */
-#ifdef __x86_64__
-    /* Segment base addresses. */
-    uint64_t      fs_base;
-    uint64_t      gs_base_kernel;
-    uint64_t      gs_base_user;
-#endif
-};
-typedef struct vcpu_guest_context vcpu_guest_context_t;
-DEFINE_XEN_GUEST_HANDLE(vcpu_guest_context_t);
-
-struct arch_shared_info {
-    unsigned long max_pfn;                  /* max pfn that appears in table */
-    /* Frame containing list of mfns containing list of mfns containing p2m. */
-    xen_pfn_t     pfn_to_mfn_frame_list_list;
-    unsigned long nmi_reason;
-    uint64_t pad[32];
-};
-typedef struct arch_shared_info arch_shared_info_t;
-
-#endif /* !__ASSEMBLY__ */
-
-/*
- * ` enum neg_errnoval
- * ` HYPERVISOR_fpu_taskswitch(int set);
- * `
- * Sets (if set!=0) or clears (if set==0) CR0.TS.
- */
-
-/*
- * ` enum neg_errnoval
- * ` HYPERVISOR_set_debugreg(int regno, unsigned long value);
- *
- * ` unsigned long
- * ` HYPERVISOR_get_debugreg(int regno);
- * For 0<=reg<=7, returns the debug register value.
- * For other values of reg, returns ((unsigned long)-EINVAL).
- * (Unfortunately, this interface is defective.)
- */
-
-/*
- * Prefix forces emulation of some non-trapping instructions.
- * Currently only CPUID.
- */
-#ifdef __ASSEMBLY__
-#define XEN_EMULATE_PREFIX .byte 0x0f,0x0b,0x78,0x65,0x6e ;
-#define XEN_CPUID          XEN_EMULATE_PREFIX cpuid
-#else
-#define XEN_EMULATE_PREFIX ".byte 0x0f,0x0b,0x78,0x65,0x6e ; "
-#define XEN_CPUID          XEN_EMULATE_PREFIX "cpuid"
-#endif
-
-#endif /* __XEN_PUBLIC_ARCH_X86_XEN_H__ */
-
-/*
- * Local variables:
- * mode: C
- * c-set-style: "BSD"
- * c-basic-offset: 4
- * tab-width: 4
- * indent-tabs-mode: nil
- * End:
- */
diff -Nru xen-4.2.1-new/extras/mini-os/include/xen/arch-x86/xen-mca.h xen-4.2.1/extras/mini-os/include/xen/arch-x86/xen-mca.h
--- xen-4.2.1-new/extras/mini-os/include/xen/arch-x86/xen-mca.h	2012-12-17 23:01:56.000000000 +0800
+++ xen-4.2.1/extras/mini-os/include/xen/arch-x86/xen-mca.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,440 +0,0 @@
-/******************************************************************************
- * arch-x86/mca.h
- * 
- * Contributed by Advanced Micro Devices, Inc.
- * Author: Christoph Egger <Christoph.Egger@amd.com>
- *
- * Guest OS machine check interface to x86 Xen.
- * 
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- */
-
-/* Full MCA functionality has the following Usecases from the guest side:
- *
- * Must have's:
- * 1. Dom0 and DomU register machine check trap callback handlers
- *    (already done via "set_trap_table" hypercall)
- * 2. Dom0 registers machine check event callback handler
- *    (doable via EVTCHNOP_bind_virq)
- * 3. Dom0 and DomU fetches machine check data
- * 4. Dom0 wants Xen to notify a DomU
- * 5. Dom0 gets DomU ID from physical address
- * 6. Dom0 wants Xen to kill DomU (already done for "xm destroy")
- *
- * Nice to have's:
- * 7. Dom0 wants Xen to deactivate a physical CPU
- *    This is better done as separate task, physical CPU hotplugging,
- *    and hypercall(s) should be sysctl's
- * 8. Page migration proposed from Xen NUMA work, where Dom0 can tell Xen to
- *    move a DomU (or Dom0 itself) away from a malicious page
- *    producing correctable errors.
- * 9. offlining physical page:
- *    Xen free's and never re-uses a certain physical page.
- * 10. Testfacility: Allow Dom0 to write values into machine check MSR's
- *     and tell Xen to trigger a machine check
- */
-
-#ifndef __XEN_PUBLIC_ARCH_X86_MCA_H__
-#define __XEN_PUBLIC_ARCH_X86_MCA_H__
-
-/* Hypercall */
-#define __HYPERVISOR_mca __HYPERVISOR_arch_0
-
-/*
- * The xen-unstable repo has interface version 0x03000001; out interface
- * is incompatible with that and any future minor revisions, so we
- * choose a different version number range that is numerically less
- * than that used in xen-unstable.
- */
-#define XEN_MCA_INTERFACE_VERSION 0x01ecc003
-
-/* IN: Dom0 calls hypercall to retrieve nonurgent telemetry */
-#define XEN_MC_NONURGENT  0x0001
-/* IN: Dom0/DomU calls hypercall to retrieve urgent telemetry */
-#define XEN_MC_URGENT     0x0002
-/* IN: Dom0 acknowledges previosly-fetched telemetry */
-#define XEN_MC_ACK        0x0004
-
-/* OUT: All is ok */
-#define XEN_MC_OK           0x0
-/* OUT: Domain could not fetch data. */
-#define XEN_MC_FETCHFAILED  0x1
-/* OUT: There was no machine check data to fetch. */
-#define XEN_MC_NODATA       0x2
-/* OUT: Between notification time and this hypercall an other
- *  (most likely) correctable error happened. The fetched data,
- *  does not match the original machine check data. */
-#define XEN_MC_NOMATCH      0x4
-
-/* OUT: DomU did not register MC NMI handler. Try something else. */
-#define XEN_MC_CANNOTHANDLE 0x8
-/* OUT: Notifying DomU failed. Retry later or try something else. */
-#define XEN_MC_NOTDELIVERED 0x10
-/* Note, XEN_MC_CANNOTHANDLE and XEN_MC_NOTDELIVERED are mutually exclusive. */
-
-
-#ifndef __ASSEMBLY__
-
-#define VIRQ_MCA VIRQ_ARCH_0 /* G. (DOM0) Machine Check Architecture */
-
-/*
- * Machine Check Architecure:
- * structs are read-only and used to report all kinds of
- * correctable and uncorrectable errors detected by the HW.
- * Dom0 and DomU: register a handler to get notified.
- * Dom0 only: Correctable errors are reported via VIRQ_MCA
- * Dom0 and DomU: Uncorrectable errors are reported via nmi handlers
- */
-#define MC_TYPE_GLOBAL          0
-#define MC_TYPE_BANK            1
-#define MC_TYPE_EXTENDED        2
-#define MC_TYPE_RECOVERY        3
-
-struct mcinfo_common {
-    uint16_t type;      /* structure type */
-    uint16_t size;      /* size of this struct in bytes */
-};
-
-
-#define MC_FLAG_CORRECTABLE     (1 << 0)
-#define MC_FLAG_UNCORRECTABLE   (1 << 1)
-#define MC_FLAG_RECOVERABLE	(1 << 2)
-#define MC_FLAG_POLLED		(1 << 3)
-#define MC_FLAG_RESET		(1 << 4)
-#define MC_FLAG_CMCI		(1 << 5)
-#define MC_FLAG_MCE		(1 << 6)
-/* contains global x86 mc information */
-struct mcinfo_global {
-    struct mcinfo_common common;
-
-    /* running domain at the time in error (most likely the impacted one) */
-    uint16_t mc_domid;
-    uint16_t mc_vcpuid; /* virtual cpu scheduled for mc_domid */
-    uint32_t mc_socketid; /* physical socket of the physical core */
-    uint16_t mc_coreid; /* physical impacted core */
-    uint16_t mc_core_threadid; /* core thread of physical core */
-    uint32_t mc_apicid;
-    uint32_t mc_flags;
-    uint64_t mc_gstatus; /* global status */
-};
-
-/* contains bank local x86 mc information */
-struct mcinfo_bank {
-    struct mcinfo_common common;
-
-    uint16_t mc_bank; /* bank nr */
-    uint16_t mc_domid; /* Usecase 5: domain referenced by mc_addr on dom0
-                        * and if mc_addr is valid. Never valid on DomU. */
-    uint64_t mc_status; /* bank status */
-    uint64_t mc_addr;   /* bank address, only valid
-                         * if addr bit is set in mc_status */
-    uint64_t mc_misc;
-    uint64_t mc_ctrl2;
-    uint64_t mc_tsc;
-};
-
-
-struct mcinfo_msr {
-    uint64_t reg;   /* MSR */
-    uint64_t value; /* MSR value */
-};
-
-/* contains mc information from other
- * or additional mc MSRs */ 
-struct mcinfo_extended {
-    struct mcinfo_common common;
-
-    /* You can fill up to five registers.
-     * If you need more, then use this structure
-     * multiple times. */
-
-    uint32_t mc_msrs; /* Number of msr with valid values. */
-    /*
-     * Currently Intel extended MSR (32/64) include all gp registers
-     * and E(R)FLAGS, E(R)IP, E(R)MISC, up to 11/19 of them might be
-     * useful at present. So expand this array to 16/32 to leave room.
-     */
-    struct mcinfo_msr mc_msr[sizeof(void *) * 4];
-};
-
-/* Recovery Action flags. Giving recovery result information to DOM0 */
-
-/* Xen takes successful recovery action, the error is recovered */
-#define REC_ACTION_RECOVERED (0x1 << 0)
-/* No action is performed by XEN */
-#define REC_ACTION_NONE (0x1 << 1)
-/* It's possible DOM0 might take action ownership in some case */
-#define REC_ACTION_NEED_RESET (0x1 << 2)
-
-/* Different Recovery Action types, if the action is performed successfully,
- * REC_ACTION_RECOVERED flag will be returned.
- */
-
-/* Page Offline Action */
-#define MC_ACTION_PAGE_OFFLINE (0x1 << 0)
-/* CPU offline Action */
-#define MC_ACTION_CPU_OFFLINE (0x1 << 1)
-/* L3 cache disable Action */
-#define MC_ACTION_CACHE_SHRINK (0x1 << 2)
-
-/* Below interface used between XEN/DOM0 for passing XEN's recovery action 
- * information to DOM0. 
- * usage Senario: After offlining broken page, XEN might pass its page offline
- * recovery action result to DOM0. DOM0 will save the information in 
- * non-volatile memory for further proactive actions, such as offlining the
- * easy broken page earlier when doing next reboot.
-*/
-struct page_offline_action
-{
-    /* Params for passing the offlined page number to DOM0 */
-    uint64_t mfn;
-    uint64_t status;
-};
-
-struct cpu_offline_action
-{
-    /* Params for passing the identity of the offlined CPU to DOM0 */
-    uint32_t mc_socketid;
-    uint16_t mc_coreid;
-    uint16_t mc_core_threadid;
-};
-
-#define MAX_UNION_SIZE 16
-struct mcinfo_recovery
-{
-    struct mcinfo_common common;
-    uint16_t mc_bank; /* bank nr */
-    uint8_t action_flags;
-    uint8_t action_types;
-    union {
-        struct page_offline_action page_retire;
-        struct cpu_offline_action cpu_offline;
-        uint8_t pad[MAX_UNION_SIZE];
-    } action_info;
-};
-
-
-#define MCINFO_HYPERCALLSIZE	1024
-#define MCINFO_MAXSIZE		768
-
-#define MCINFO_FLAGS_UNCOMPLETE 0x1
-struct mc_info {
-    /* Number of mcinfo_* entries in mi_data */
-    uint32_t mi_nentries;
-    uint32_t flags;
-    uint64_t mi_data[(MCINFO_MAXSIZE - 1) / 8];
-};
-typedef struct mc_info mc_info_t;
-DEFINE_XEN_GUEST_HANDLE(mc_info_t);
-
-#define __MC_MSR_ARRAYSIZE 8
-#define __MC_NMSRS 1
-#define MC_NCAPS	7	/* 7 CPU feature flag words */
-#define MC_CAPS_STD_EDX	0	/* cpuid level 0x00000001 (%edx) */
-#define MC_CAPS_AMD_EDX	1	/* cpuid level 0x80000001 (%edx) */
-#define MC_CAPS_TM	2	/* cpuid level 0x80860001 (TransMeta) */
-#define MC_CAPS_LINUX	3	/* Linux-defined */
-#define MC_CAPS_STD_ECX	4	/* cpuid level 0x00000001 (%ecx) */
-#define MC_CAPS_VIA	5	/* cpuid level 0xc0000001 */
-#define MC_CAPS_AMD_ECX	6	/* cpuid level 0x80000001 (%ecx) */
-
-struct mcinfo_logical_cpu {
-    uint32_t mc_cpunr;          
-    uint32_t mc_chipid; 
-    uint16_t mc_coreid;
-    uint16_t mc_threadid;
-    uint32_t mc_apicid;
-    uint32_t mc_clusterid;
-    uint32_t mc_ncores;
-    uint32_t mc_ncores_active;
-    uint32_t mc_nthreads;
-    int32_t mc_cpuid_level;
-    uint32_t mc_family;
-    uint32_t mc_vendor;
-    uint32_t mc_model;
-    uint32_t mc_step;
-    char mc_vendorid[16];
-    char mc_brandid[64];
-    uint32_t mc_cpu_caps[MC_NCAPS];
-    uint32_t mc_cache_size;
-    uint32_t mc_cache_alignment;
-    int32_t mc_nmsrvals;
-    struct mcinfo_msr mc_msrvalues[__MC_MSR_ARRAYSIZE];
-};
-typedef struct mcinfo_logical_cpu xen_mc_logical_cpu_t;
-DEFINE_XEN_GUEST_HANDLE(xen_mc_logical_cpu_t);
-
-
-/* 
- * OS's should use these instead of writing their own lookup function
- * each with its own bugs and drawbacks.
- * We use macros instead of static inline functions to allow guests
- * to include this header in assembly files (*.S).
- */
-/* Prototype:
- *    uint32_t x86_mcinfo_nentries(struct mc_info *mi);
- */
-#define x86_mcinfo_nentries(_mi)    \
-    (_mi)->mi_nentries
-/* Prototype:
- *    struct mcinfo_common *x86_mcinfo_first(struct mc_info *mi);
- */
-#define x86_mcinfo_first(_mi)       \
-    ((struct mcinfo_common *)(_mi)->mi_data)
-/* Prototype:
- *    struct mcinfo_common *x86_mcinfo_next(struct mcinfo_common *mic);
- */
-#define x86_mcinfo_next(_mic)       \
-    ((struct mcinfo_common *)((uint8_t *)(_mic) + (_mic)->size))
-
-/* Prototype:
- *    void x86_mcinfo_lookup(void *ret, struct mc_info *mi, uint16_t type);
- */
-#define x86_mcinfo_lookup(_ret, _mi, _type)    \
-    do {                                                        \
-        uint32_t found, i;                                      \
-        struct mcinfo_common *_mic;                             \
-                                                                \
-        found = 0;                                              \
-	(_ret) = NULL;						\
-	if (_mi == NULL) break;					\
-        _mic = x86_mcinfo_first(_mi);                           \
-        for (i = 0; i < x86_mcinfo_nentries(_mi); i++) {        \
-            if (_mic->type == (_type)) {                        \
-                found = 1;                                      \
-                break;                                          \
-            }                                                   \
-            _mic = x86_mcinfo_next(_mic);                       \
-        }                                                       \
-        (_ret) = found ? _mic : NULL;                           \
-    } while (0)
-
-
-/* Usecase 1
- * Register machine check trap callback handler
- *    (already done via "set_trap_table" hypercall)
- */
-
-/* Usecase 2
- * Dom0 registers machine check event callback handler
- * done by EVTCHNOP_bind_virq
- */
-
-/* Usecase 3
- * Fetch machine check data from hypervisor.
- * Note, this hypercall is special, because both Dom0 and DomU must use this.
- */
-#define XEN_MC_fetch            1
-struct xen_mc_fetch {
-    /* IN/OUT variables. */
-    uint32_t flags;	/* IN: XEN_MC_NONURGENT, XEN_MC_URGENT,
-                           XEN_MC_ACK if ack'ing an earlier fetch */
-			/* OUT: XEN_MC_OK, XEN_MC_FETCHFAILED,
-			   XEN_MC_NODATA, XEN_MC_NOMATCH */
-    uint32_t _pad0;
-    uint64_t fetch_id;	/* OUT: id for ack, IN: id we are ack'ing */
-
-    /* OUT variables. */
-    XEN_GUEST_HANDLE(mc_info_t) data;
-};
-typedef struct xen_mc_fetch xen_mc_fetch_t;
-DEFINE_XEN_GUEST_HANDLE(xen_mc_fetch_t);
-
-
-/* Usecase 4
- * This tells the hypervisor to notify a DomU about the machine check error
- */
-#define XEN_MC_notifydomain     2
-struct xen_mc_notifydomain {
-    /* IN variables. */
-    uint16_t mc_domid;    /* The unprivileged domain to notify. */
-    uint16_t mc_vcpuid;   /* The vcpu in mc_domid to notify.
-                           * Usually echo'd value from the fetch hypercall. */
-
-    /* IN/OUT variables. */
-    uint32_t flags;
-
-/* IN: XEN_MC_CORRECTABLE, XEN_MC_TRAP */
-/* OUT: XEN_MC_OK, XEN_MC_CANNOTHANDLE, XEN_MC_NOTDELIVERED, XEN_MC_NOMATCH */
-};
-typedef struct xen_mc_notifydomain xen_mc_notifydomain_t;
-DEFINE_XEN_GUEST_HANDLE(xen_mc_notifydomain_t);
-
-#define XEN_MC_physcpuinfo 3
-struct xen_mc_physcpuinfo {
-	/* IN/OUT */
-	uint32_t ncpus;
-	uint32_t _pad0;
-	/* OUT */
-	XEN_GUEST_HANDLE(xen_mc_logical_cpu_t) info;
-};
-
-#define XEN_MC_msrinject    4
-#define MC_MSRINJ_MAXMSRS       8
-struct xen_mc_msrinject {
-       /* IN */
-	uint32_t mcinj_cpunr;           /* target processor id */
-	uint32_t mcinj_flags;           /* see MC_MSRINJ_F_* below */
-	uint32_t mcinj_count;           /* 0 .. count-1 in array are valid */
-	uint32_t _pad0;
-	struct mcinfo_msr mcinj_msr[MC_MSRINJ_MAXMSRS];
-};
-
-/* Flags for mcinj_flags above; bits 16-31 are reserved */
-#define MC_MSRINJ_F_INTERPOSE   0x1
-
-#define XEN_MC_mceinject    5
-struct xen_mc_mceinject {
-	unsigned int mceinj_cpunr;      /* target processor id */
-};
-
-#if defined(__XEN__) || defined(__XEN_TOOLS__)
-#define XEN_MC_inject_v2        6
-#define XEN_MC_INJECT_TYPE_MASK     0x7
-#define XEN_MC_INJECT_TYPE_MCE      0x0
-#define XEN_MC_INJECT_TYPE_CMCI     0x1
-
-#define XEN_MC_INJECT_CPU_BROADCAST 0x8
-
-struct xen_mc_inject_v2 {
-	uint32_t flags;
-	struct xenctl_cpumap cpumap;
-};
-#endif
-
-struct xen_mc {
-    uint32_t cmd;
-    uint32_t interface_version; /* XEN_MCA_INTERFACE_VERSION */
-    union {
-        struct xen_mc_fetch        mc_fetch;
-        struct xen_mc_notifydomain mc_notifydomain;
-        struct xen_mc_physcpuinfo  mc_physcpuinfo;
-        struct xen_mc_msrinject    mc_msrinject;
-        struct xen_mc_mceinject    mc_mceinject;
-#if defined(__XEN__) || defined(__XEN_TOOLS__)
-        struct xen_mc_inject_v2    mc_inject_v2;
-#endif
-    } u;
-};
-typedef struct xen_mc xen_mc_t;
-DEFINE_XEN_GUEST_HANDLE(xen_mc_t);
-
-#endif /* __ASSEMBLY__ */
-
-#endif /* __XEN_PUBLIC_ARCH_X86_MCA_H__ */
diff -Nru xen-4.2.1-new/extras/mini-os/include/xen/arch-x86/xen-x86_32.h xen-4.2.1/extras/mini-os/include/xen/arch-x86/xen-x86_32.h
--- xen-4.2.1-new/extras/mini-os/include/xen/arch-x86/xen-x86_32.h	2012-12-17 23:01:56.000000000 +0800
+++ xen-4.2.1/extras/mini-os/include/xen/arch-x86/xen-x86_32.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,171 +0,0 @@
-/******************************************************************************
- * xen-x86_32.h
- * 
- * Guest OS interface to x86 32-bit Xen.
- * 
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- * Copyright (c) 2004-2007, K A Fraser
- */
-
-#ifndef __XEN_PUBLIC_ARCH_X86_XEN_X86_32_H__
-#define __XEN_PUBLIC_ARCH_X86_XEN_X86_32_H__
-
-/*
- * Hypercall interface:
- *  Input:  %ebx, %ecx, %edx, %esi, %edi, %ebp (arguments 1-6)
- *  Output: %eax
- * Access is via hypercall page (set up by guest loader or via a Xen MSR):
- *  call hypercall_page + hypercall-number * 32
- * Clobbered: Argument registers (e.g., 2-arg hypercall clobbers %ebx,%ecx)
- */
-
-/*
- * These flat segments are in the Xen-private section of every GDT. Since these
- * are also present in the initial GDT, many OSes will be able to avoid
- * installing their own GDT.
- */
-#define FLAT_RING1_CS 0xe019    /* GDT index 259 */
-#define FLAT_RING1_DS 0xe021    /* GDT index 260 */
-#define FLAT_RING1_SS 0xe021    /* GDT index 260 */
-#define FLAT_RING3_CS 0xe02b    /* GDT index 261 */
-#define FLAT_RING3_DS 0xe033    /* GDT index 262 */
-#define FLAT_RING3_SS 0xe033    /* GDT index 262 */
-
-#define FLAT_KERNEL_CS FLAT_RING1_CS
-#define FLAT_KERNEL_DS FLAT_RING1_DS
-#define FLAT_KERNEL_SS FLAT_RING1_SS
-#define FLAT_USER_CS    FLAT_RING3_CS
-#define FLAT_USER_DS    FLAT_RING3_DS
-#define FLAT_USER_SS    FLAT_RING3_SS
-
-#define __HYPERVISOR_VIRT_START_PAE    0xF5800000
-#define __MACH2PHYS_VIRT_START_PAE     0xF5800000
-#define __MACH2PHYS_VIRT_END_PAE       0xF6800000
-#define HYPERVISOR_VIRT_START_PAE      \
-    mk_unsigned_long(__HYPERVISOR_VIRT_START_PAE)
-#define MACH2PHYS_VIRT_START_PAE       \
-    mk_unsigned_long(__MACH2PHYS_VIRT_START_PAE)
-#define MACH2PHYS_VIRT_END_PAE         \
-    mk_unsigned_long(__MACH2PHYS_VIRT_END_PAE)
-
-/* Non-PAE bounds are obsolete. */
-#define __HYPERVISOR_VIRT_START_NONPAE 0xFC000000
-#define __MACH2PHYS_VIRT_START_NONPAE  0xFC000000
-#define __MACH2PHYS_VIRT_END_NONPAE    0xFC400000
-#define HYPERVISOR_VIRT_START_NONPAE   \
-    mk_unsigned_long(__HYPERVISOR_VIRT_START_NONPAE)
-#define MACH2PHYS_VIRT_START_NONPAE    \
-    mk_unsigned_long(__MACH2PHYS_VIRT_START_NONPAE)
-#define MACH2PHYS_VIRT_END_NONPAE      \
-    mk_unsigned_long(__MACH2PHYS_VIRT_END_NONPAE)
-
-#define __HYPERVISOR_VIRT_START __HYPERVISOR_VIRT_START_PAE
-#define __MACH2PHYS_VIRT_START  __MACH2PHYS_VIRT_START_PAE
-#define __MACH2PHYS_VIRT_END    __MACH2PHYS_VIRT_END_PAE
-
-#ifndef HYPERVISOR_VIRT_START
-#define HYPERVISOR_VIRT_START mk_unsigned_long(__HYPERVISOR_VIRT_START)
-#endif
-
-#define MACH2PHYS_VIRT_START  mk_unsigned_long(__MACH2PHYS_VIRT_START)
-#define MACH2PHYS_VIRT_END    mk_unsigned_long(__MACH2PHYS_VIRT_END)
-#define MACH2PHYS_NR_ENTRIES  ((MACH2PHYS_VIRT_END-MACH2PHYS_VIRT_START)>>2)
-#ifndef machine_to_phys_mapping
-#define machine_to_phys_mapping ((unsigned long *)MACH2PHYS_VIRT_START)
-#endif
-
-/* 32-/64-bit invariability for control interfaces (domctl/sysctl). */
-#if defined(__XEN__) || defined(__XEN_TOOLS__)
-#undef ___DEFINE_XEN_GUEST_HANDLE
-#define ___DEFINE_XEN_GUEST_HANDLE(name, type)                  \
-    typedef struct { type *p; }                                 \
-        __guest_handle_ ## name;                                \
-    typedef struct { union { type *p; uint64_aligned_t q; }; }  \
-        __guest_handle_64_ ## name
-#undef set_xen_guest_handle_raw
-#define set_xen_guest_handle_raw(hnd, val)                  \
-    do { if ( sizeof(hnd) == 8 ) *(uint64_t *)&(hnd) = 0;   \
-         (hnd).p = val;                                     \
-    } while ( 0 )
-#define uint64_aligned_t uint64_t __attribute__((aligned(8)))
-#define __XEN_GUEST_HANDLE_64(name) __guest_handle_64_ ## name
-#define XEN_GUEST_HANDLE_64(name) __XEN_GUEST_HANDLE_64(name)
-#endif
-
-#ifndef __ASSEMBLY__
-
-struct cpu_user_regs {
-    uint32_t ebx;
-    uint32_t ecx;
-    uint32_t edx;
-    uint32_t esi;
-    uint32_t edi;
-    uint32_t ebp;
-    uint32_t eax;
-    uint16_t error_code;    /* private */
-    uint16_t entry_vector;  /* private */
-    uint32_t eip;
-    uint16_t cs;
-    uint8_t  saved_upcall_mask;
-    uint8_t  _pad0;
-    uint32_t eflags;        /* eflags.IF == !saved_upcall_mask */
-    uint32_t esp;
-    uint16_t ss, _pad1;
-    uint16_t es, _pad2;
-    uint16_t ds, _pad3;
-    uint16_t fs, _pad4;
-    uint16_t gs, _pad5;
-};
-typedef struct cpu_user_regs cpu_user_regs_t;
-DEFINE_XEN_GUEST_HANDLE(cpu_user_regs_t);
-
-/*
- * Page-directory addresses above 4GB do not fit into architectural %cr3.
- * When accessing %cr3, or equivalent field in vcpu_guest_context, guests
- * must use the following accessor macros to pack/unpack valid MFNs.
- */
-#define xen_pfn_to_cr3(pfn) (((unsigned)(pfn) << 12) | ((unsigned)(pfn) >> 20))
-#define xen_cr3_to_pfn(cr3) (((unsigned)(cr3) >> 12) | ((unsigned)(cr3) << 20))
-
-struct arch_vcpu_info {
-    unsigned long cr2;
-    unsigned long pad[5]; /* sizeof(vcpu_info_t) == 64 */
-};
-typedef struct arch_vcpu_info arch_vcpu_info_t;
-
-struct xen_callback {
-    unsigned long cs;
-    unsigned long eip;
-};
-typedef struct xen_callback xen_callback_t;
-
-#endif /* !__ASSEMBLY__ */
-
-#endif /* __XEN_PUBLIC_ARCH_X86_XEN_X86_32_H__ */
-
-/*
- * Local variables:
- * mode: C
- * c-set-style: "BSD"
- * c-basic-offset: 4
- * tab-width: 4
- * indent-tabs-mode: nil
- * End:
- */
diff -Nru xen-4.2.1-new/extras/mini-os/include/xen/arch-x86/xen-x86_64.h xen-4.2.1/extras/mini-os/include/xen/arch-x86/xen-x86_64.h
--- xen-4.2.1-new/extras/mini-os/include/xen/arch-x86/xen-x86_64.h	2012-12-17 23:01:56.000000000 +0800
+++ xen-4.2.1/extras/mini-os/include/xen/arch-x86/xen-x86_64.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,202 +0,0 @@
-/******************************************************************************
- * xen-x86_64.h
- * 
- * Guest OS interface to x86 64-bit Xen.
- * 
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- * Copyright (c) 2004-2006, K A Fraser
- */
-
-#ifndef __XEN_PUBLIC_ARCH_X86_XEN_X86_64_H__
-#define __XEN_PUBLIC_ARCH_X86_XEN_X86_64_H__
-
-/*
- * Hypercall interface:
- *  Input:  %rdi, %rsi, %rdx, %r10, %r8, %r9 (arguments 1-6)
- *  Output: %rax
- * Access is via hypercall page (set up by guest loader or via a Xen MSR):
- *  call hypercall_page + hypercall-number * 32
- * Clobbered: argument registers (e.g., 2-arg hypercall clobbers %rdi,%rsi)
- */
-
-/*
- * 64-bit segment selectors
- * These flat segments are in the Xen-private section of every GDT. Since these
- * are also present in the initial GDT, many OSes will be able to avoid
- * installing their own GDT.
- */
-
-#define FLAT_RING3_CS32 0xe023  /* GDT index 260 */
-#define FLAT_RING3_CS64 0xe033  /* GDT index 261 */
-#define FLAT_RING3_DS32 0xe02b  /* GDT index 262 */
-#define FLAT_RING3_DS64 0x0000  /* NULL selector */
-#define FLAT_RING3_SS32 0xe02b  /* GDT index 262 */
-#define FLAT_RING3_SS64 0xe02b  /* GDT index 262 */
-
-#define FLAT_KERNEL_DS64 FLAT_RING3_DS64
-#define FLAT_KERNEL_DS32 FLAT_RING3_DS32
-#define FLAT_KERNEL_DS   FLAT_KERNEL_DS64
-#define FLAT_KERNEL_CS64 FLAT_RING3_CS64
-#define FLAT_KERNEL_CS32 FLAT_RING3_CS32
-#define FLAT_KERNEL_CS   FLAT_KERNEL_CS64
-#define FLAT_KERNEL_SS64 FLAT_RING3_SS64
-#define FLAT_KERNEL_SS32 FLAT_RING3_SS32
-#define FLAT_KERNEL_SS   FLAT_KERNEL_SS64
-
-#define FLAT_USER_DS64 FLAT_RING3_DS64
-#define FLAT_USER_DS32 FLAT_RING3_DS32
-#define FLAT_USER_DS   FLAT_USER_DS64
-#define FLAT_USER_CS64 FLAT_RING3_CS64
-#define FLAT_USER_CS32 FLAT_RING3_CS32
-#define FLAT_USER_CS   FLAT_USER_CS64
-#define FLAT_USER_SS64 FLAT_RING3_SS64
-#define FLAT_USER_SS32 FLAT_RING3_SS32
-#define FLAT_USER_SS   FLAT_USER_SS64
-
-#define __HYPERVISOR_VIRT_START 0xFFFF800000000000
-#define __HYPERVISOR_VIRT_END   0xFFFF880000000000
-#define __MACH2PHYS_VIRT_START  0xFFFF800000000000
-#define __MACH2PHYS_VIRT_END    0xFFFF804000000000
-
-#ifndef HYPERVISOR_VIRT_START
-#define HYPERVISOR_VIRT_START mk_unsigned_long(__HYPERVISOR_VIRT_START)
-#define HYPERVISOR_VIRT_END   mk_unsigned_long(__HYPERVISOR_VIRT_END)
-#endif
-
-#define MACH2PHYS_VIRT_START  mk_unsigned_long(__MACH2PHYS_VIRT_START)
-#define MACH2PHYS_VIRT_END    mk_unsigned_long(__MACH2PHYS_VIRT_END)
-#define MACH2PHYS_NR_ENTRIES  ((MACH2PHYS_VIRT_END-MACH2PHYS_VIRT_START)>>3)
-#ifndef machine_to_phys_mapping
-#define machine_to_phys_mapping ((unsigned long *)HYPERVISOR_VIRT_START)
-#endif
-
-/*
- * int HYPERVISOR_set_segment_base(unsigned int which, unsigned long base)
- *  @which == SEGBASE_*  ;  @base == 64-bit base address
- * Returns 0 on success.
- */
-#define SEGBASE_FS          0
-#define SEGBASE_GS_USER     1
-#define SEGBASE_GS_KERNEL   2
-#define SEGBASE_GS_USER_SEL 3 /* Set user %gs specified in base[15:0] */
-
-/*
- * int HYPERVISOR_iret(void)
- * All arguments are on the kernel stack, in the following format.
- * Never returns if successful. Current kernel context is lost.
- * The saved CS is mapped as follows:
- *   RING0 -> RING3 kernel mode.
- *   RING1 -> RING3 kernel mode.
- *   RING2 -> RING3 kernel mode.
- *   RING3 -> RING3 user mode.
- * However RING0 indicates that the guest kernel should return to iteself
- * directly with
- *      orb   $3,1*8(%rsp)
- *      iretq
- * If flags contains VGCF_in_syscall:
- *   Restore RAX, RIP, RFLAGS, RSP.
- *   Discard R11, RCX, CS, SS.
- * Otherwise:
- *   Restore RAX, R11, RCX, CS:RIP, RFLAGS, SS:RSP.
- * All other registers are saved on hypercall entry and restored to user.
- */
-/* Guest exited in SYSCALL context? Return to guest with SYSRET? */
-#define _VGCF_in_syscall 8
-#define VGCF_in_syscall  (1<<_VGCF_in_syscall)
-#define VGCF_IN_SYSCALL  VGCF_in_syscall
-
-#ifndef __ASSEMBLY__
-
-struct iret_context {
-    /* Top of stack (%rsp at point of hypercall). */
-    uint64_t rax, r11, rcx, flags, rip, cs, rflags, rsp, ss;
-    /* Bottom of iret stack frame. */
-};
-
-#if defined(__GNUC__) && !defined(__STRICT_ANSI__)
-/* Anonymous union includes both 32- and 64-bit names (e.g., eax/rax). */
-#define __DECL_REG(name) union { \
-    uint64_t r ## name, e ## name; \
-    uint32_t _e ## name; \
-}
-#else
-/* Non-gcc sources must always use the proper 64-bit name (e.g., rax). */
-#define __DECL_REG(name) uint64_t r ## name
-#endif
-
-struct cpu_user_regs {
-    uint64_t r15;
-    uint64_t r14;
-    uint64_t r13;
-    uint64_t r12;
-    __DECL_REG(bp);
-    __DECL_REG(bx);
-    uint64_t r11;
-    uint64_t r10;
-    uint64_t r9;
-    uint64_t r8;
-    __DECL_REG(ax);
-    __DECL_REG(cx);
-    __DECL_REG(dx);
-    __DECL_REG(si);
-    __DECL_REG(di);
-    uint32_t error_code;    /* private */
-    uint32_t entry_vector;  /* private */
-    __DECL_REG(ip);
-    uint16_t cs, _pad0[1];
-    uint8_t  saved_upcall_mask;
-    uint8_t  _pad1[3];
-    __DECL_REG(flags);      /* rflags.IF == !saved_upcall_mask */
-    __DECL_REG(sp);
-    uint16_t ss, _pad2[3];
-    uint16_t es, _pad3[3];
-    uint16_t ds, _pad4[3];
-    uint16_t fs, _pad5[3]; /* Non-zero => takes precedence over fs_base.     */
-    uint16_t gs, _pad6[3]; /* Non-zero => takes precedence over gs_base_usr. */
-};
-typedef struct cpu_user_regs cpu_user_regs_t;
-DEFINE_XEN_GUEST_HANDLE(cpu_user_regs_t);
-
-#undef __DECL_REG
-
-#define xen_pfn_to_cr3(pfn) ((unsigned long)(pfn) << 12)
-#define xen_cr3_to_pfn(cr3) ((unsigned long)(cr3) >> 12)
-
-struct arch_vcpu_info {
-    unsigned long cr2;
-    unsigned long pad; /* sizeof(vcpu_info_t) == 64 */
-};
-typedef struct arch_vcpu_info arch_vcpu_info_t;
-
-typedef unsigned long xen_callback_t;
-
-#endif /* !__ASSEMBLY__ */
-
-#endif /* __XEN_PUBLIC_ARCH_X86_XEN_X86_64_H__ */
-
-/*
- * Local variables:
- * mode: C
- * c-set-style: "BSD"
- * c-basic-offset: 4
- * tab-width: 4
- * indent-tabs-mode: nil
- * End:
- */
diff -Nru xen-4.2.1-new/extras/mini-os/include/xen/arch-x86_32.h xen-4.2.1/extras/mini-os/include/xen/arch-x86_32.h
--- xen-4.2.1-new/extras/mini-os/include/xen/arch-x86_32.h	2014-08-23 21:01:22.000000000 +0800
+++ xen-4.2.1/extras/mini-os/include/xen/arch-x86_32.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,27 +0,0 @@
-/******************************************************************************
- * arch-x86_32.h
- * 
- * Guest OS interface to x86 32-bit Xen.
- * 
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- * Copyright (c) 2004-2006, K A Fraser
- */
-
-#include "arch-x86/xen.h"
diff -Nru xen-4.2.1-new/extras/mini-os/include/xen/arch-x86_64.h xen-4.2.1/extras/mini-os/include/xen/arch-x86_64.h
--- xen-4.2.1-new/extras/mini-os/include/xen/arch-x86_64.h	2014-08-23 21:01:22.000000000 +0800
+++ xen-4.2.1/extras/mini-os/include/xen/arch-x86_64.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,43 +0,0 @@
-/******************************************************************************
- * arch-x86_64.h
- * 
- * Guest OS interface to x86 64-bit Xen.
- * 
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- * Copyright (c) 2004-2006, K A Fraser
- */
-
-#include "arch-x86/xen.h"
-
-/*
- * ` enum neg_errnoval
- * ` HYPERVISOR_set_callbacks(unsigned long event_selector,
- * `                          unsigned long event_address,
- * `                          unsigned long failsafe_selector,
- * `                          unsigned long failsafe_address);
- * `
- * Register for callbacks on events.  When an event (from an event
- * channel) occurs, event_address is used as the value of eip.
- *
- * A similar callback occurs if the segment selectors are invalid.
- * failsafe_address is used as the value of eip.
- *
- * On x86_64, event_selector and failsafe_selector are ignored (???).
- */
diff -Nru xen-4.2.1-new/extras/mini-os/include/xen/callback.h xen-4.2.1/extras/mini-os/include/xen/callback.h
--- xen-4.2.1-new/extras/mini-os/include/xen/callback.h	2014-08-23 21:01:22.000000000 +0800
+++ xen-4.2.1/extras/mini-os/include/xen/callback.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,121 +0,0 @@
-/******************************************************************************
- * callback.h
- *
- * Register guest OS callbacks with Xen.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- * Copyright (c) 2006, Ian Campbell
- */
-
-#ifndef __XEN_PUBLIC_CALLBACK_H__
-#define __XEN_PUBLIC_CALLBACK_H__
-
-#include "xen.h"
-
-/*
- * Prototype for this hypercall is:
- *   long callback_op(int cmd, void *extra_args)
- * @cmd        == CALLBACKOP_??? (callback operation).
- * @extra_args == Operation-specific extra arguments (NULL if none).
- */
-
-/* ia64, x86: Callback for event delivery. */
-#define CALLBACKTYPE_event                 0
-
-/* x86: Failsafe callback when guest state cannot be restored by Xen. */
-#define CALLBACKTYPE_failsafe              1
-
-/* x86/64 hypervisor: Syscall by 64-bit guest app ('64-on-64-on-64'). */
-#define CALLBACKTYPE_syscall               2
-
-/*
- * x86/32 hypervisor: Only available on x86/32 when supervisor_mode_kernel
- *     feature is enabled. Do not use this callback type in new code.
- */
-#define CALLBACKTYPE_sysenter_deprecated   3
-
-/* x86: Callback for NMI delivery. */
-#define CALLBACKTYPE_nmi                   4
-
-/*
- * x86: sysenter is only available as follows:
- * - 32-bit hypervisor: with the supervisor_mode_kernel feature enabled
- * - 64-bit hypervisor: 32-bit guest applications on Intel CPUs
- *                      ('32-on-32-on-64', '32-on-64-on-64')
- *                      [nb. also 64-bit guest applications on Intel CPUs
- *                           ('64-on-64-on-64'), but syscall is preferred]
- */
-#define CALLBACKTYPE_sysenter              5
-
-/*
- * x86/64 hypervisor: Syscall by 32-bit guest app on AMD CPUs
- *                    ('32-on-32-on-64', '32-on-64-on-64')
- */
-#define CALLBACKTYPE_syscall32             7
-
-/*
- * Disable event deliver during callback? This flag is ignored for event and
- * NMI callbacks: event delivery is unconditionally disabled.
- */
-#define _CALLBACKF_mask_events             0
-#define CALLBACKF_mask_events              (1U << _CALLBACKF_mask_events)
-
-/*
- * Register a callback.
- */
-#define CALLBACKOP_register                0
-struct callback_register {
-    uint16_t type;
-    uint16_t flags;
-    xen_callback_t address;
-};
-typedef struct callback_register callback_register_t;
-DEFINE_XEN_GUEST_HANDLE(callback_register_t);
-
-/*
- * Unregister a callback.
- *
- * Not all callbacks can be unregistered. -EINVAL will be returned if
- * you attempt to unregister such a callback.
- */
-#define CALLBACKOP_unregister              1
-struct callback_unregister {
-    uint16_t type;
-    uint16_t _unused;
-};
-typedef struct callback_unregister callback_unregister_t;
-DEFINE_XEN_GUEST_HANDLE(callback_unregister_t);
-
-#if __XEN_INTERFACE_VERSION__ < 0x00030207
-#undef CALLBACKTYPE_sysenter
-#define CALLBACKTYPE_sysenter CALLBACKTYPE_sysenter_deprecated
-#endif
-
-#endif /* __XEN_PUBLIC_CALLBACK_H__ */
-
-/*
- * Local variables:
- * mode: C
- * c-set-style: "BSD"
- * c-basic-offset: 4
- * tab-width: 4
- * indent-tabs-mode: nil
- * End:
- */
diff -Nru xen-4.2.1-new/extras/mini-os/include/xen/COPYING xen-4.2.1/extras/mini-os/include/xen/COPYING
--- xen-4.2.1-new/extras/mini-os/include/xen/COPYING	2014-08-23 21:01:22.000000000 +0800
+++ xen-4.2.1/extras/mini-os/include/xen/COPYING	1970-01-01 07:00:00.000000000 +0700
@@ -1,38 +0,0 @@
-XEN NOTICE
-==========
-
-This copyright applies to all files within this subdirectory and its
-subdirectories:
-  include/public/*.h
-  include/public/hvm/*.h
-  include/public/io/*.h
-
-The intention is that these files can be freely copied into the source
-tree of an operating system when porting that OS to run on Xen. Doing
-so does *not* cause the OS to become subject to the terms of the GPL.
-
-All other files in the Xen source distribution are covered by version
-2 of the GNU General Public License except where explicitly stated
-otherwise within individual source files.
-
- -- Keir Fraser (on behalf of the Xen team)
-
-=====================================================================
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to
-deal in the Software without restriction, including without limitation the
-rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
-sell copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in
-all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
-FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
-DEALINGS IN THE SOFTWARE.
diff -Nru xen-4.2.1-new/extras/mini-os/include/xen/dom0_ops.h xen-4.2.1/extras/mini-os/include/xen/dom0_ops.h
--- xen-4.2.1-new/extras/mini-os/include/xen/dom0_ops.h	2014-08-23 21:01:22.000000000 +0800
+++ xen-4.2.1/extras/mini-os/include/xen/dom0_ops.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,120 +0,0 @@
-/******************************************************************************
- * dom0_ops.h
- * 
- * Process command requests from domain-0 guest OS.
- * 
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- * Copyright (c) 2002-2003, B Dragovic
- * Copyright (c) 2002-2006, K Fraser
- */
-
-#ifndef __XEN_PUBLIC_DOM0_OPS_H__
-#define __XEN_PUBLIC_DOM0_OPS_H__
-
-#include "xen.h"
-#include "platform.h"
-
-#if __XEN_INTERFACE_VERSION__ >= 0x00030204
-#error "dom0_ops.h is a compatibility interface only"
-#endif
-
-#define DOM0_INTERFACE_VERSION XENPF_INTERFACE_VERSION
-
-#define DOM0_SETTIME          XENPF_settime
-#define dom0_settime          xenpf_settime
-#define dom0_settime_t        xenpf_settime_t
-
-#define DOM0_ADD_MEMTYPE      XENPF_add_memtype
-#define dom0_add_memtype      xenpf_add_memtype
-#define dom0_add_memtype_t    xenpf_add_memtype_t
-
-#define DOM0_DEL_MEMTYPE      XENPF_del_memtype
-#define dom0_del_memtype      xenpf_del_memtype
-#define dom0_del_memtype_t    xenpf_del_memtype_t
-
-#define DOM0_READ_MEMTYPE     XENPF_read_memtype
-#define dom0_read_memtype     xenpf_read_memtype
-#define dom0_read_memtype_t   xenpf_read_memtype_t
-
-#define DOM0_MICROCODE        XENPF_microcode_update
-#define dom0_microcode        xenpf_microcode_update
-#define dom0_microcode_t      xenpf_microcode_update_t
-
-#define DOM0_PLATFORM_QUIRK   XENPF_platform_quirk
-#define dom0_platform_quirk   xenpf_platform_quirk
-#define dom0_platform_quirk_t xenpf_platform_quirk_t
-
-typedef uint64_t cpumap_t;
-
-/* Unsupported legacy operation -- defined for API compatibility. */
-#define DOM0_MSR                 15
-struct dom0_msr {
-    /* IN variables. */
-    uint32_t write;
-    cpumap_t cpu_mask;
-    uint32_t msr;
-    uint32_t in1;
-    uint32_t in2;
-    /* OUT variables. */
-    uint32_t out1;
-    uint32_t out2;
-};
-typedef struct dom0_msr dom0_msr_t;
-DEFINE_XEN_GUEST_HANDLE(dom0_msr_t);
-
-/* Unsupported legacy operation -- defined for API compatibility. */
-#define DOM0_PHYSICAL_MEMORY_MAP 40
-struct dom0_memory_map_entry {
-    uint64_t start, end;
-    uint32_t flags; /* reserved */
-    uint8_t  is_ram;
-};
-typedef struct dom0_memory_map_entry dom0_memory_map_entry_t;
-DEFINE_XEN_GUEST_HANDLE(dom0_memory_map_entry_t);
-
-struct dom0_op {
-    uint32_t cmd;
-    uint32_t interface_version; /* DOM0_INTERFACE_VERSION */
-    union {
-        struct dom0_msr               msr;
-        struct dom0_settime           settime;
-        struct dom0_add_memtype       add_memtype;
-        struct dom0_del_memtype       del_memtype;
-        struct dom0_read_memtype      read_memtype;
-        struct dom0_microcode         microcode;
-        struct dom0_platform_quirk    platform_quirk;
-        struct dom0_memory_map_entry  physical_memory_map;
-        uint8_t                       pad[128];
-    } u;
-};
-typedef struct dom0_op dom0_op_t;
-DEFINE_XEN_GUEST_HANDLE(dom0_op_t);
-
-#endif /* __XEN_PUBLIC_DOM0_OPS_H__ */
-
-/*
- * Local variables:
- * mode: C
- * c-set-style: "BSD"
- * c-basic-offset: 4
- * tab-width: 4
- * indent-tabs-mode: nil
- * End:
- */
diff -Nru xen-4.2.1-new/extras/mini-os/include/xen/domctl.h xen-4.2.1/extras/mini-os/include/xen/domctl.h
--- xen-4.2.1-new/extras/mini-os/include/xen/domctl.h	2014-08-23 21:01:22.000000000 +0800
+++ xen-4.2.1/extras/mini-os/include/xen/domctl.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,991 +0,0 @@
-/******************************************************************************
- * domctl.h
- * 
- * Domain management operations. For use by node control stack.
- * 
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- * Copyright (c) 2002-2003, B Dragovic
- * Copyright (c) 2002-2006, K Fraser
- */
-
-#ifndef __XEN_PUBLIC_DOMCTL_H__
-#define __XEN_PUBLIC_DOMCTL_H__
-
-#if !defined(__XEN__) && !defined(__XEN_TOOLS__)
-#error "domctl operations are intended for use by node control tools only"
-#endif
-
-#include "xen.h"
-#include "grant_table.h"
-
-#define XEN_DOMCTL_INTERFACE_VERSION 0x00000008
-
-/*
- * NB. xen_domctl.domain is an IN/OUT parameter for this operation.
- * If it is specified as zero, an id is auto-allocated and returned.
- */
-/* XEN_DOMCTL_createdomain */
-struct xen_domctl_createdomain {
-    /* IN parameters */
-    uint32_t ssidref;
-    xen_domain_handle_t handle;
- /* Is this an HVM guest (as opposed to a PV guest)? */
-#define _XEN_DOMCTL_CDF_hvm_guest     0
-#define XEN_DOMCTL_CDF_hvm_guest      (1U<<_XEN_DOMCTL_CDF_hvm_guest)
- /* Use hardware-assisted paging if available? */
-#define _XEN_DOMCTL_CDF_hap           1
-#define XEN_DOMCTL_CDF_hap            (1U<<_XEN_DOMCTL_CDF_hap)
- /* Should domain memory integrity be verifed by tboot during Sx? */
-#define _XEN_DOMCTL_CDF_s3_integrity  2
-#define XEN_DOMCTL_CDF_s3_integrity   (1U<<_XEN_DOMCTL_CDF_s3_integrity)
- /* Disable out-of-sync shadow page tables? */
-#define _XEN_DOMCTL_CDF_oos_off       3
-#define XEN_DOMCTL_CDF_oos_off        (1U<<_XEN_DOMCTL_CDF_oos_off)
-    uint32_t flags;
-};
-typedef struct xen_domctl_createdomain xen_domctl_createdomain_t;
-DEFINE_XEN_GUEST_HANDLE(xen_domctl_createdomain_t);
-
-/* XEN_DOMCTL_getdomaininfo */
-struct xen_domctl_getdomaininfo {
-    /* OUT variables. */
-    domid_t  domain;              /* Also echoed in domctl.domain */
- /* Domain is scheduled to die. */
-#define _XEN_DOMINF_dying     0
-#define XEN_DOMINF_dying      (1U<<_XEN_DOMINF_dying)
- /* Domain is an HVM guest (as opposed to a PV guest). */
-#define _XEN_DOMINF_hvm_guest 1
-#define XEN_DOMINF_hvm_guest  (1U<<_XEN_DOMINF_hvm_guest)
- /* The guest OS has shut down. */
-#define _XEN_DOMINF_shutdown  2
-#define XEN_DOMINF_shutdown   (1U<<_XEN_DOMINF_shutdown)
- /* Currently paused by control software. */
-#define _XEN_DOMINF_paused    3
-#define XEN_DOMINF_paused     (1U<<_XEN_DOMINF_paused)
- /* Currently blocked pending an event.     */
-#define _XEN_DOMINF_blocked   4
-#define XEN_DOMINF_blocked    (1U<<_XEN_DOMINF_blocked)
- /* Domain is currently running.            */
-#define _XEN_DOMINF_running   5
-#define XEN_DOMINF_running    (1U<<_XEN_DOMINF_running)
- /* Being debugged.  */
-#define _XEN_DOMINF_debugged  6
-#define XEN_DOMINF_debugged   (1U<<_XEN_DOMINF_debugged)
- /* XEN_DOMINF_shutdown guest-supplied code.  */
-#define XEN_DOMINF_shutdownmask 255
-#define XEN_DOMINF_shutdownshift 16
-    uint32_t flags;              /* XEN_DOMINF_* */
-    uint64_aligned_t tot_pages;
-    uint64_aligned_t max_pages;
-    uint64_aligned_t shr_pages;
-    uint64_aligned_t paged_pages;
-    uint64_aligned_t shared_info_frame; /* GMFN of shared_info struct */
-    uint64_aligned_t cpu_time;
-    uint32_t nr_online_vcpus;    /* Number of VCPUs currently online. */
-    uint32_t max_vcpu_id;        /* Maximum VCPUID in use by this domain. */
-    uint32_t ssidref;
-    xen_domain_handle_t handle;
-    uint32_t cpupool;
-};
-typedef struct xen_domctl_getdomaininfo xen_domctl_getdomaininfo_t;
-DEFINE_XEN_GUEST_HANDLE(xen_domctl_getdomaininfo_t);
-
-
-/* XEN_DOMCTL_getmemlist */
-struct xen_domctl_getmemlist {
-    /* IN variables. */
-    /* Max entries to write to output buffer. */
-    uint64_aligned_t max_pfns;
-    /* Start index in guest's page list. */
-    uint64_aligned_t start_pfn;
-    XEN_GUEST_HANDLE_64(uint64) buffer;
-    /* OUT variables. */
-    uint64_aligned_t num_pfns;
-};
-typedef struct xen_domctl_getmemlist xen_domctl_getmemlist_t;
-DEFINE_XEN_GUEST_HANDLE(xen_domctl_getmemlist_t);
-
-
-/* XEN_DOMCTL_getpageframeinfo */
-
-#define XEN_DOMCTL_PFINFO_LTAB_SHIFT 28
-#define XEN_DOMCTL_PFINFO_NOTAB   (0x0U<<28)
-#define XEN_DOMCTL_PFINFO_L1TAB   (0x1U<<28)
-#define XEN_DOMCTL_PFINFO_L2TAB   (0x2U<<28)
-#define XEN_DOMCTL_PFINFO_L3TAB   (0x3U<<28)
-#define XEN_DOMCTL_PFINFO_L4TAB   (0x4U<<28)
-#define XEN_DOMCTL_PFINFO_LTABTYPE_MASK (0x7U<<28)
-#define XEN_DOMCTL_PFINFO_LPINTAB (0x1U<<31)
-#define XEN_DOMCTL_PFINFO_XTAB    (0xfU<<28) /* invalid page */
-#define XEN_DOMCTL_PFINFO_XALLOC  (0xeU<<28) /* allocate-only page */
-#define XEN_DOMCTL_PFINFO_PAGEDTAB (0x8U<<28)
-#define XEN_DOMCTL_PFINFO_LTAB_MASK (0xfU<<28)
-
-struct xen_domctl_getpageframeinfo {
-    /* IN variables. */
-    uint64_aligned_t gmfn; /* GMFN to query */
-    /* OUT variables. */
-    /* Is the page PINNED to a type? */
-    uint32_t type;         /* see above type defs */
-};
-typedef struct xen_domctl_getpageframeinfo xen_domctl_getpageframeinfo_t;
-DEFINE_XEN_GUEST_HANDLE(xen_domctl_getpageframeinfo_t);
-
-
-/* XEN_DOMCTL_getpageframeinfo2 */
-struct xen_domctl_getpageframeinfo2 {
-    /* IN variables. */
-    uint64_aligned_t num;
-    /* IN/OUT variables. */
-    XEN_GUEST_HANDLE_64(uint32) array;
-};
-typedef struct xen_domctl_getpageframeinfo2 xen_domctl_getpageframeinfo2_t;
-DEFINE_XEN_GUEST_HANDLE(xen_domctl_getpageframeinfo2_t);
-
-/* XEN_DOMCTL_getpageframeinfo3 */
-struct xen_domctl_getpageframeinfo3 {
-    /* IN variables. */
-    uint64_aligned_t num;
-    /* IN/OUT variables. */
-    XEN_GUEST_HANDLE_64(xen_pfn_t) array;
-};
-
-
-/*
- * Control shadow pagetables operation
- */
-/* XEN_DOMCTL_shadow_op */
-
-/* Disable shadow mode. */
-#define XEN_DOMCTL_SHADOW_OP_OFF         0
-
-/* Enable shadow mode (mode contains ORed XEN_DOMCTL_SHADOW_ENABLE_* flags). */
-#define XEN_DOMCTL_SHADOW_OP_ENABLE      32
-
-/* Log-dirty bitmap operations. */
- /* Return the bitmap and clean internal copy for next round. */
-#define XEN_DOMCTL_SHADOW_OP_CLEAN       11
- /* Return the bitmap but do not modify internal copy. */
-#define XEN_DOMCTL_SHADOW_OP_PEEK        12
-
-/* Memory allocation accessors. */
-#define XEN_DOMCTL_SHADOW_OP_GET_ALLOCATION   30
-#define XEN_DOMCTL_SHADOW_OP_SET_ALLOCATION   31
-
-/* Legacy enable operations. */
- /* Equiv. to ENABLE with no mode flags. */
-#define XEN_DOMCTL_SHADOW_OP_ENABLE_TEST       1
- /* Equiv. to ENABLE with mode flag ENABLE_LOG_DIRTY. */
-#define XEN_DOMCTL_SHADOW_OP_ENABLE_LOGDIRTY   2
- /* Equiv. to ENABLE with mode flags ENABLE_REFCOUNT and ENABLE_TRANSLATE. */
-#define XEN_DOMCTL_SHADOW_OP_ENABLE_TRANSLATE  3
-
-/* Mode flags for XEN_DOMCTL_SHADOW_OP_ENABLE. */
- /*
-  * Shadow pagetables are refcounted: guest does not use explicit mmu
-  * operations nor write-protect its pagetables.
-  */
-#define XEN_DOMCTL_SHADOW_ENABLE_REFCOUNT  (1 << 1)
- /*
-  * Log pages in a bitmap as they are dirtied.
-  * Used for live relocation to determine which pages must be re-sent.
-  */
-#define XEN_DOMCTL_SHADOW_ENABLE_LOG_DIRTY (1 << 2)
- /*
-  * Automatically translate GPFNs into MFNs.
-  */
-#define XEN_DOMCTL_SHADOW_ENABLE_TRANSLATE (1 << 3)
- /*
-  * Xen does not steal virtual address space from the guest.
-  * Requires HVM support.
-  */
-#define XEN_DOMCTL_SHADOW_ENABLE_EXTERNAL  (1 << 4)
-
-struct xen_domctl_shadow_op_stats {
-    uint32_t fault_count;
-    uint32_t dirty_count;
-};
-typedef struct xen_domctl_shadow_op_stats xen_domctl_shadow_op_stats_t;
-DEFINE_XEN_GUEST_HANDLE(xen_domctl_shadow_op_stats_t);
-
-struct xen_domctl_shadow_op {
-    /* IN variables. */
-    uint32_t       op;       /* XEN_DOMCTL_SHADOW_OP_* */
-
-    /* OP_ENABLE */
-    uint32_t       mode;     /* XEN_DOMCTL_SHADOW_ENABLE_* */
-
-    /* OP_GET_ALLOCATION / OP_SET_ALLOCATION */
-    uint32_t       mb;       /* Shadow memory allocation in MB */
-
-    /* OP_PEEK / OP_CLEAN */
-    XEN_GUEST_HANDLE_64(uint8) dirty_bitmap;
-    uint64_aligned_t pages; /* Size of buffer. Updated with actual size. */
-    struct xen_domctl_shadow_op_stats stats;
-};
-typedef struct xen_domctl_shadow_op xen_domctl_shadow_op_t;
-DEFINE_XEN_GUEST_HANDLE(xen_domctl_shadow_op_t);
-
-
-/* XEN_DOMCTL_max_mem */
-struct xen_domctl_max_mem {
-    /* IN variables. */
-    uint64_aligned_t max_memkb;
-};
-typedef struct xen_domctl_max_mem xen_domctl_max_mem_t;
-DEFINE_XEN_GUEST_HANDLE(xen_domctl_max_mem_t);
-
-
-/* XEN_DOMCTL_setvcpucontext */
-/* XEN_DOMCTL_getvcpucontext */
-struct xen_domctl_vcpucontext {
-    uint32_t              vcpu;                  /* IN */
-    XEN_GUEST_HANDLE_64(vcpu_guest_context_t) ctxt; /* IN/OUT */
-};
-typedef struct xen_domctl_vcpucontext xen_domctl_vcpucontext_t;
-DEFINE_XEN_GUEST_HANDLE(xen_domctl_vcpucontext_t);
-
-
-/* XEN_DOMCTL_getvcpuinfo */
-struct xen_domctl_getvcpuinfo {
-    /* IN variables. */
-    uint32_t vcpu;
-    /* OUT variables. */
-    uint8_t  online;                  /* currently online (not hotplugged)? */
-    uint8_t  blocked;                 /* blocked waiting for an event? */
-    uint8_t  running;                 /* currently scheduled on its CPU? */
-    uint64_aligned_t cpu_time;        /* total cpu time consumed (ns) */
-    uint32_t cpu;                     /* current mapping   */
-};
-typedef struct xen_domctl_getvcpuinfo xen_domctl_getvcpuinfo_t;
-DEFINE_XEN_GUEST_HANDLE(xen_domctl_getvcpuinfo_t);
-
-
-/* Get/set which physical cpus a vcpu can execute on. */
-/* XEN_DOMCTL_setvcpuaffinity */
-/* XEN_DOMCTL_getvcpuaffinity */
-struct xen_domctl_vcpuaffinity {
-    uint32_t  vcpu;              /* IN */
-    struct xenctl_cpumap cpumap; /* IN/OUT */
-};
-typedef struct xen_domctl_vcpuaffinity xen_domctl_vcpuaffinity_t;
-DEFINE_XEN_GUEST_HANDLE(xen_domctl_vcpuaffinity_t);
-
-
-/* XEN_DOMCTL_max_vcpus */
-struct xen_domctl_max_vcpus {
-    uint32_t max;           /* maximum number of vcpus */
-};
-typedef struct xen_domctl_max_vcpus xen_domctl_max_vcpus_t;
-DEFINE_XEN_GUEST_HANDLE(xen_domctl_max_vcpus_t);
-
-
-/* XEN_DOMCTL_scheduler_op */
-/* Scheduler types. */
-#define XEN_SCHEDULER_SEDF     4
-#define XEN_SCHEDULER_CREDIT   5
-#define XEN_SCHEDULER_CREDIT2  6
-#define XEN_SCHEDULER_ARINC653 7
-/* Set or get info? */
-#define XEN_DOMCTL_SCHEDOP_putinfo 0
-#define XEN_DOMCTL_SCHEDOP_getinfo 1
-struct xen_domctl_scheduler_op {
-    uint32_t sched_id;  /* XEN_SCHEDULER_* */
-    uint32_t cmd;       /* XEN_DOMCTL_SCHEDOP_* */
-    union {
-        struct xen_domctl_sched_sedf {
-            uint64_aligned_t period;
-            uint64_aligned_t slice;
-            uint64_aligned_t latency;
-            uint32_t extratime;
-            uint32_t weight;
-        } sedf;
-        struct xen_domctl_sched_credit {
-            uint16_t weight;
-            uint16_t cap;
-        } credit;
-        struct xen_domctl_sched_credit2 {
-            uint16_t weight;
-        } credit2;
-    } u;
-};
-typedef struct xen_domctl_scheduler_op xen_domctl_scheduler_op_t;
-DEFINE_XEN_GUEST_HANDLE(xen_domctl_scheduler_op_t);
-
-
-/* XEN_DOMCTL_setdomainhandle */
-struct xen_domctl_setdomainhandle {
-    xen_domain_handle_t handle;
-};
-typedef struct xen_domctl_setdomainhandle xen_domctl_setdomainhandle_t;
-DEFINE_XEN_GUEST_HANDLE(xen_domctl_setdomainhandle_t);
-
-
-/* XEN_DOMCTL_setdebugging */
-struct xen_domctl_setdebugging {
-    uint8_t enable;
-};
-typedef struct xen_domctl_setdebugging xen_domctl_setdebugging_t;
-DEFINE_XEN_GUEST_HANDLE(xen_domctl_setdebugging_t);
-
-
-/* XEN_DOMCTL_irq_permission */
-struct xen_domctl_irq_permission {
-    uint8_t pirq;
-    uint8_t allow_access;    /* flag to specify enable/disable of IRQ access */
-};
-typedef struct xen_domctl_irq_permission xen_domctl_irq_permission_t;
-DEFINE_XEN_GUEST_HANDLE(xen_domctl_irq_permission_t);
-
-
-/* XEN_DOMCTL_iomem_permission */
-struct xen_domctl_iomem_permission {
-    uint64_aligned_t first_mfn;/* first page (physical page number) in range */
-    uint64_aligned_t nr_mfns;  /* number of pages in range (>0) */
-    uint8_t  allow_access;     /* allow (!0) or deny (0) access to range? */
-};
-typedef struct xen_domctl_iomem_permission xen_domctl_iomem_permission_t;
-DEFINE_XEN_GUEST_HANDLE(xen_domctl_iomem_permission_t);
-
-
-/* XEN_DOMCTL_ioport_permission */
-struct xen_domctl_ioport_permission {
-    uint32_t first_port;              /* first port int range */
-    uint32_t nr_ports;                /* size of port range */
-    uint8_t  allow_access;            /* allow or deny access to range? */
-};
-typedef struct xen_domctl_ioport_permission xen_domctl_ioport_permission_t;
-DEFINE_XEN_GUEST_HANDLE(xen_domctl_ioport_permission_t);
-
-
-/* XEN_DOMCTL_hypercall_init */
-struct xen_domctl_hypercall_init {
-    uint64_aligned_t  gmfn;           /* GMFN to be initialised */
-};
-typedef struct xen_domctl_hypercall_init xen_domctl_hypercall_init_t;
-DEFINE_XEN_GUEST_HANDLE(xen_domctl_hypercall_init_t);
-
-
-/* XEN_DOMCTL_arch_setup */
-#define _XEN_DOMAINSETUP_hvm_guest 0
-#define XEN_DOMAINSETUP_hvm_guest  (1UL<<_XEN_DOMAINSETUP_hvm_guest)
-#define _XEN_DOMAINSETUP_query 1 /* Get parameters (for save)  */
-#define XEN_DOMAINSETUP_query  (1UL<<_XEN_DOMAINSETUP_query)
-#define _XEN_DOMAINSETUP_sioemu_guest 2
-#define XEN_DOMAINSETUP_sioemu_guest  (1UL<<_XEN_DOMAINSETUP_sioemu_guest)
-typedef struct xen_domctl_arch_setup {
-    uint64_aligned_t flags;  /* XEN_DOMAINSETUP_* */
-#ifdef __ia64__
-    uint64_aligned_t bp;     /* mpaddr of boot param area */
-    uint64_aligned_t maxmem; /* Highest memory address for MDT.  */
-    uint64_aligned_t xsi_va; /* Xen shared_info area virtual address.  */
-    uint32_t hypercall_imm;  /* Break imm for Xen hypercalls.  */
-    int8_t vhpt_size_log2;   /* Log2 of VHPT size. */
-#endif
-} xen_domctl_arch_setup_t;
-DEFINE_XEN_GUEST_HANDLE(xen_domctl_arch_setup_t);
-
-
-/* XEN_DOMCTL_settimeoffset */
-struct xen_domctl_settimeoffset {
-    int32_t  time_offset_seconds; /* applied to domain wallclock time */
-};
-typedef struct xen_domctl_settimeoffset xen_domctl_settimeoffset_t;
-DEFINE_XEN_GUEST_HANDLE(xen_domctl_settimeoffset_t);
-
-/* XEN_DOMCTL_gethvmcontext */
-/* XEN_DOMCTL_sethvmcontext */
-typedef struct xen_domctl_hvmcontext {
-    uint32_t size; /* IN/OUT: size of buffer / bytes filled */
-    XEN_GUEST_HANDLE_64(uint8) buffer; /* IN/OUT: data, or call
-                                        * gethvmcontext with NULL
-                                        * buffer to get size req'd */
-} xen_domctl_hvmcontext_t;
-DEFINE_XEN_GUEST_HANDLE(xen_domctl_hvmcontext_t);
-
-
-/* XEN_DOMCTL_set_address_size */
-/* XEN_DOMCTL_get_address_size */
-typedef struct xen_domctl_address_size {
-    uint32_t size;
-} xen_domctl_address_size_t;
-DEFINE_XEN_GUEST_HANDLE(xen_domctl_address_size_t);
-
-
-/* XEN_DOMCTL_real_mode_area */
-struct xen_domctl_real_mode_area {
-    uint32_t log; /* log2 of Real Mode Area size */
-};
-typedef struct xen_domctl_real_mode_area xen_domctl_real_mode_area_t;
-DEFINE_XEN_GUEST_HANDLE(xen_domctl_real_mode_area_t);
-
-
-/* XEN_DOMCTL_sendtrigger */
-#define XEN_DOMCTL_SENDTRIGGER_NMI    0
-#define XEN_DOMCTL_SENDTRIGGER_RESET  1
-#define XEN_DOMCTL_SENDTRIGGER_INIT   2
-#define XEN_DOMCTL_SENDTRIGGER_POWER  3
-#define XEN_DOMCTL_SENDTRIGGER_SLEEP  4
-struct xen_domctl_sendtrigger {
-    uint32_t  trigger;  /* IN */
-    uint32_t  vcpu;     /* IN */
-};
-typedef struct xen_domctl_sendtrigger xen_domctl_sendtrigger_t;
-DEFINE_XEN_GUEST_HANDLE(xen_domctl_sendtrigger_t);
-
-
-/* Assign PCI device to HVM guest. Sets up IOMMU structures. */
-/* XEN_DOMCTL_assign_device */
-/* XEN_DOMCTL_test_assign_device */
-/* XEN_DOMCTL_deassign_device */
-struct xen_domctl_assign_device {
-    uint32_t  machine_sbdf;   /* machine PCI ID of assigned device */
-};
-typedef struct xen_domctl_assign_device xen_domctl_assign_device_t;
-DEFINE_XEN_GUEST_HANDLE(xen_domctl_assign_device_t);
-
-/* Retrieve sibling devices infomation of machine_sbdf */
-/* XEN_DOMCTL_get_device_group */
-struct xen_domctl_get_device_group {
-    uint32_t  machine_sbdf;     /* IN */
-    uint32_t  max_sdevs;        /* IN */
-    uint32_t  num_sdevs;        /* OUT */
-    XEN_GUEST_HANDLE_64(uint32)  sdev_array;   /* OUT */
-};
-typedef struct xen_domctl_get_device_group xen_domctl_get_device_group_t;
-DEFINE_XEN_GUEST_HANDLE(xen_domctl_get_device_group_t);
-
-/* Pass-through interrupts: bind real irq -> hvm devfn. */
-/* XEN_DOMCTL_bind_pt_irq */
-/* XEN_DOMCTL_unbind_pt_irq */
-typedef enum pt_irq_type_e {
-    PT_IRQ_TYPE_PCI,
-    PT_IRQ_TYPE_ISA,
-    PT_IRQ_TYPE_MSI,
-    PT_IRQ_TYPE_MSI_TRANSLATE,
-} pt_irq_type_t;
-struct xen_domctl_bind_pt_irq {
-    uint32_t machine_irq;
-    pt_irq_type_t irq_type;
-    uint32_t hvm_domid;
-
-    union {
-        struct {
-            uint8_t isa_irq;
-        } isa;
-        struct {
-            uint8_t bus;
-            uint8_t device;
-            uint8_t intx;
-        } pci;
-        struct {
-            uint8_t gvec;
-            uint32_t gflags;
-            uint64_aligned_t gtable;
-        } msi;
-    } u;
-};
-typedef struct xen_domctl_bind_pt_irq xen_domctl_bind_pt_irq_t;
-DEFINE_XEN_GUEST_HANDLE(xen_domctl_bind_pt_irq_t);
-
-
-/* Bind machine I/O address range -> HVM address range. */
-/* XEN_DOMCTL_memory_mapping */
-#define DPCI_ADD_MAPPING         1
-#define DPCI_REMOVE_MAPPING      0
-struct xen_domctl_memory_mapping {
-    uint64_aligned_t first_gfn; /* first page (hvm guest phys page) in range */
-    uint64_aligned_t first_mfn; /* first page (machine page) in range */
-    uint64_aligned_t nr_mfns;   /* number of pages in range (>0) */
-    uint32_t add_mapping;       /* add or remove mapping */
-    uint32_t padding;           /* padding for 64-bit aligned structure */
-};
-typedef struct xen_domctl_memory_mapping xen_domctl_memory_mapping_t;
-DEFINE_XEN_GUEST_HANDLE(xen_domctl_memory_mapping_t);
-
-
-/* Bind machine I/O port range -> HVM I/O port range. */
-/* XEN_DOMCTL_ioport_mapping */
-struct xen_domctl_ioport_mapping {
-    uint32_t first_gport;     /* first guest IO port*/
-    uint32_t first_mport;     /* first machine IO port */
-    uint32_t nr_ports;        /* size of port range */
-    uint32_t add_mapping;     /* add or remove mapping */
-};
-typedef struct xen_domctl_ioport_mapping xen_domctl_ioport_mapping_t;
-DEFINE_XEN_GUEST_HANDLE(xen_domctl_ioport_mapping_t);
-
-
-/*
- * Pin caching type of RAM space for x86 HVM domU.
- */
-/* XEN_DOMCTL_pin_mem_cacheattr */
-/* Caching types: these happen to be the same as x86 MTRR/PAT type codes. */
-#define XEN_DOMCTL_MEM_CACHEATTR_UC  0
-#define XEN_DOMCTL_MEM_CACHEATTR_WC  1
-#define XEN_DOMCTL_MEM_CACHEATTR_WT  4
-#define XEN_DOMCTL_MEM_CACHEATTR_WP  5
-#define XEN_DOMCTL_MEM_CACHEATTR_WB  6
-#define XEN_DOMCTL_MEM_CACHEATTR_UCM 7
-struct xen_domctl_pin_mem_cacheattr {
-    uint64_aligned_t start, end;
-    uint32_t type; /* XEN_DOMCTL_MEM_CACHEATTR_* */
-};
-typedef struct xen_domctl_pin_mem_cacheattr xen_domctl_pin_mem_cacheattr_t;
-DEFINE_XEN_GUEST_HANDLE(xen_domctl_pin_mem_cacheattr_t);
-
-
-/* XEN_DOMCTL_set_ext_vcpucontext */
-/* XEN_DOMCTL_get_ext_vcpucontext */
-struct xen_domctl_ext_vcpucontext {
-    /* IN: VCPU that this call applies to. */
-    uint32_t         vcpu;
-    /*
-     * SET: Size of struct (IN)
-     * GET: Size of struct (OUT, up to 128 bytes)
-     */
-    uint32_t         size;
-#if defined(__i386__) || defined(__x86_64__)
-    /* SYSCALL from 32-bit mode and SYSENTER callback information. */
-    /* NB. SYSCALL from 64-bit mode is contained in vcpu_guest_context_t */
-    uint64_aligned_t syscall32_callback_eip;
-    uint64_aligned_t sysenter_callback_eip;
-    uint16_t         syscall32_callback_cs;
-    uint16_t         sysenter_callback_cs;
-    uint8_t          syscall32_disables_events;
-    uint8_t          sysenter_disables_events;
-    uint64_aligned_t mcg_cap;
-#endif
-};
-typedef struct xen_domctl_ext_vcpucontext xen_domctl_ext_vcpucontext_t;
-DEFINE_XEN_GUEST_HANDLE(xen_domctl_ext_vcpucontext_t);
-
-/*
- * Set optimizaton features for a domain
- */
-/* XEN_DOMCTL_set_opt_feature */
-struct xen_domctl_set_opt_feature {
-#if defined(__ia64__)
-    struct xen_ia64_opt_feature optf;
-#else
-    /* Make struct non-empty: do not depend on this field name! */
-    uint64_t dummy;
-#endif
-};
-typedef struct xen_domctl_set_opt_feature xen_domctl_set_opt_feature_t;
-DEFINE_XEN_GUEST_HANDLE(xen_domctl_set_opt_feature_t);
-
-/*
- * Set the target domain for a domain
- */
-/* XEN_DOMCTL_set_target */
-struct xen_domctl_set_target {
-    domid_t target;
-};
-typedef struct xen_domctl_set_target xen_domctl_set_target_t;
-DEFINE_XEN_GUEST_HANDLE(xen_domctl_set_target_t);
-
-#if defined(__i386__) || defined(__x86_64__)
-# define XEN_CPUID_INPUT_UNUSED  0xFFFFFFFF
-/* XEN_DOMCTL_set_cpuid */
-struct xen_domctl_cpuid {
-  uint32_t input[2];
-  uint32_t eax;
-  uint32_t ebx;
-  uint32_t ecx;
-  uint32_t edx;
-};
-typedef struct xen_domctl_cpuid xen_domctl_cpuid_t;
-DEFINE_XEN_GUEST_HANDLE(xen_domctl_cpuid_t);
-#endif
-
-/* XEN_DOMCTL_subscribe */
-struct xen_domctl_subscribe {
-    uint32_t port; /* IN */
-};
-typedef struct xen_domctl_subscribe xen_domctl_subscribe_t;
-DEFINE_XEN_GUEST_HANDLE(xen_domctl_subscribe_t);
-
-/*
- * Define the maximum machine address size which should be allocated
- * to a guest.
- */
-/* XEN_DOMCTL_set_machine_address_size */
-/* XEN_DOMCTL_get_machine_address_size */
-
-/*
- * Do not inject spurious page faults into this domain.
- */
-/* XEN_DOMCTL_suppress_spurious_page_faults */
-
-/* XEN_DOMCTL_debug_op */
-#define XEN_DOMCTL_DEBUG_OP_SINGLE_STEP_OFF         0
-#define XEN_DOMCTL_DEBUG_OP_SINGLE_STEP_ON          1
-struct xen_domctl_debug_op {
-    uint32_t op;   /* IN */
-    uint32_t vcpu; /* IN */
-};
-typedef struct xen_domctl_debug_op xen_domctl_debug_op_t;
-DEFINE_XEN_GUEST_HANDLE(xen_domctl_debug_op_t);
-
-/*
- * Request a particular record from the HVM context
- */
-/* XEN_DOMCTL_gethvmcontext_partial */
-typedef struct xen_domctl_hvmcontext_partial {
-    uint32_t type;                      /* IN: Type of record required */
-    uint32_t instance;                  /* IN: Instance of that type */
-    XEN_GUEST_HANDLE_64(uint8) buffer;  /* OUT: buffer to write record into */
-} xen_domctl_hvmcontext_partial_t;
-DEFINE_XEN_GUEST_HANDLE(xen_domctl_hvmcontext_partial_t);
-
-/* XEN_DOMCTL_disable_migrate */
-typedef struct xen_domctl_disable_migrate {
-    uint32_t disable; /* IN: 1: disable migration and restore */
-} xen_domctl_disable_migrate_t;
-
-
-/* XEN_DOMCTL_gettscinfo */
-/* XEN_DOMCTL_settscinfo */
-struct xen_guest_tsc_info {
-    uint32_t tsc_mode;
-    uint32_t gtsc_khz;
-    uint32_t incarnation;
-    uint32_t pad;
-    uint64_aligned_t elapsed_nsec;
-};
-typedef struct xen_guest_tsc_info xen_guest_tsc_info_t;
-DEFINE_XEN_GUEST_HANDLE(xen_guest_tsc_info_t);
-typedef struct xen_domctl_tsc_info {
-    XEN_GUEST_HANDLE_64(xen_guest_tsc_info_t) out_info; /* OUT */
-    xen_guest_tsc_info_t info; /* IN */
-} xen_domctl_tsc_info_t;
-
-/* XEN_DOMCTL_gdbsx_guestmemio      guest mem io */
-struct xen_domctl_gdbsx_memio {
-    /* IN */
-    uint64_aligned_t pgd3val;/* optional: init_mm.pgd[3] value */
-    uint64_aligned_t gva;    /* guest virtual address */
-    uint64_aligned_t uva;    /* user buffer virtual address */
-    uint32_t         len;    /* number of bytes to read/write */
-    uint8_t          gwr;    /* 0 = read from guest. 1 = write to guest */
-    /* OUT */
-    uint32_t         remain; /* bytes remaining to be copied */
-};
-
-/* XEN_DOMCTL_gdbsx_pausevcpu */
-/* XEN_DOMCTL_gdbsx_unpausevcpu */
-struct xen_domctl_gdbsx_pauseunp_vcpu { /* pause/unpause a vcpu */
-    uint32_t         vcpu;         /* which vcpu */
-};
-
-/* XEN_DOMCTL_gdbsx_domstatus */
-struct xen_domctl_gdbsx_domstatus {
-    /* OUT */
-    uint8_t          paused;     /* is the domain paused */
-    uint32_t         vcpu_id;    /* any vcpu in an event? */
-    uint32_t         vcpu_ev;    /* if yes, what event? */
-};
-
-/*
- * Memory event operations
- */
-
-/* XEN_DOMCTL_mem_event_op */
-
-/*
- * Domain memory paging
- * Page memory in and out.
- * Domctl interface to set up and tear down the 
- * pager<->hypervisor interface. Use XENMEM_paging_op*
- * to perform per-page operations.
- *
- * The XEN_DOMCTL_MEM_EVENT_OP_PAGING_ENABLE domctl returns several
- * non-standard error codes to indicate why paging could not be enabled:
- * ENODEV - host lacks HAP support (EPT/NPT) or HAP is disabled in guest
- * EMLINK - guest has iommu passthrough enabled
- * EXDEV  - guest has PoD enabled
- * EBUSY  - guest has or had paging enabled, ring buffer still active
- */
-#define XEN_DOMCTL_MEM_EVENT_OP_PAGING            1
-
-#define XEN_DOMCTL_MEM_EVENT_OP_PAGING_ENABLE     0
-#define XEN_DOMCTL_MEM_EVENT_OP_PAGING_DISABLE    1
-
-/*
- * Access permissions.
- *
- * As with paging, use the domctl for teardown/setup of the
- * helper<->hypervisor interface.
- *
- * There are HVM hypercalls to set the per-page access permissions of every
- * page in a domain.  When one of these permissions--independent, read, 
- * write, and execute--is violated, the VCPU is paused and a memory event 
- * is sent with what happened.  (See public/mem_event.h) .
- *
- * The memory event handler can then resume the VCPU and redo the access 
- * with a XENMEM_access_op_resume hypercall.
- *
- * The XEN_DOMCTL_MEM_EVENT_OP_ACCESS_ENABLE domctl returns several
- * non-standard error codes to indicate why access could not be enabled:
- * ENODEV - host lacks HAP support (EPT/NPT) or HAP is disabled in guest
- * EBUSY  - guest has or had access enabled, ring buffer still active
- */
-#define XEN_DOMCTL_MEM_EVENT_OP_ACCESS            2
-
-#define XEN_DOMCTL_MEM_EVENT_OP_ACCESS_ENABLE     0
-#define XEN_DOMCTL_MEM_EVENT_OP_ACCESS_DISABLE    1
-
-/*
- * Sharing ENOMEM helper.
- *
- * As with paging, use the domctl for teardown/setup of the
- * helper<->hypervisor interface.
- *
- * If setup, this ring is used to communicate failed allocations
- * in the unshare path. XENMEM_sharing_op_resume is used to wake up
- * vcpus that could not unshare.
- *
- * Note that shring can be turned on (as per the domctl below)
- * *without* this ring being setup.
- */
-#define XEN_DOMCTL_MEM_EVENT_OP_SHARING           3
-
-#define XEN_DOMCTL_MEM_EVENT_OP_SHARING_ENABLE    0
-#define XEN_DOMCTL_MEM_EVENT_OP_SHARING_DISABLE   1
-
-/* Use for teardown/setup of helper<->hypervisor interface for paging, 
- * access and sharing.*/
-struct xen_domctl_mem_event_op {
-    uint32_t       op;           /* XEN_DOMCTL_MEM_EVENT_OP_*_* */
-    uint32_t       mode;         /* XEN_DOMCTL_MEM_EVENT_OP_* */
-
-    uint32_t port;              /* OUT: event channel for ring */
-};
-typedef struct xen_domctl_mem_event_op xen_domctl_mem_event_op_t;
-DEFINE_XEN_GUEST_HANDLE(xen_domctl_mem_event_op_t);
-
-/*
- * Memory sharing operations
- */
-/* XEN_DOMCTL_mem_sharing_op.
- * The CONTROL sub-domctl is used for bringup/teardown. */
-#define XEN_DOMCTL_MEM_SHARING_CONTROL          0
-
-struct xen_domctl_mem_sharing_op {
-    uint8_t op; /* XEN_DOMCTL_MEM_SHARING_* */
-
-    union {
-        uint8_t enable;                   /* CONTROL */
-    } u;
-};
-typedef struct xen_domctl_mem_sharing_op xen_domctl_mem_sharing_op_t;
-DEFINE_XEN_GUEST_HANDLE(xen_domctl_mem_sharing_op_t);
-
-struct xen_domctl_audit_p2m {
-    /* OUT error counts */
-    uint64_t orphans;
-    uint64_t m2p_bad;
-    uint64_t p2m_bad;
-};
-typedef struct xen_domctl_audit_p2m xen_domctl_audit_p2m_t;
-DEFINE_XEN_GUEST_HANDLE(xen_domctl_audit_p2m_t);
-
-struct xen_domctl_set_virq_handler {
-    uint32_t virq; /* IN */
-};
-typedef struct xen_domctl_set_virq_handler xen_domctl_set_virq_handler_t;
-DEFINE_XEN_GUEST_HANDLE(xen_domctl_set_virq_handler_t);
-
-#if defined(__i386__) || defined(__x86_64__)
-/* XEN_DOMCTL_setvcpuextstate */
-/* XEN_DOMCTL_getvcpuextstate */
-struct xen_domctl_vcpuextstate {
-    /* IN: VCPU that this call applies to. */
-    uint32_t         vcpu;
-    /*
-     * SET: xfeature support mask of struct (IN)
-     * GET: xfeature support mask of struct (IN/OUT)
-     * xfeature mask is served as identifications of the saving format
-     * so that compatible CPUs can have a check on format to decide
-     * whether it can restore.
-     */
-    uint64_aligned_t         xfeature_mask;
-    /*
-     * SET: Size of struct (IN)
-     * GET: Size of struct (IN/OUT)
-     */
-    uint64_aligned_t         size;
-    XEN_GUEST_HANDLE_64(uint64) buffer;
-};
-typedef struct xen_domctl_vcpuextstate xen_domctl_vcpuextstate_t;
-DEFINE_XEN_GUEST_HANDLE(xen_domctl_vcpuextstate_t);
-#endif
-
-/* XEN_DOMCTL_set_access_required: sets whether a memory event listener
- * must be present to handle page access events: if false, the page
- * access will revert to full permissions if no one is listening;
- *  */
-struct xen_domctl_set_access_required {
-    uint8_t access_required;
-};
-typedef struct xen_domctl_set_access_required xen_domctl_set_access_required_t;
-DEFINE_XEN_GUEST_HANDLE(xen_domctl_set_access_required_t);
-
-struct xen_domctl {
-    uint32_t cmd;
-#define XEN_DOMCTL_createdomain                   1
-#define XEN_DOMCTL_destroydomain                  2
-#define XEN_DOMCTL_pausedomain                    3
-#define XEN_DOMCTL_unpausedomain                  4
-#define XEN_DOMCTL_getdomaininfo                  5
-#define XEN_DOMCTL_getmemlist                     6
-#define XEN_DOMCTL_getpageframeinfo               7
-#define XEN_DOMCTL_getpageframeinfo2              8
-#define XEN_DOMCTL_setvcpuaffinity                9
-#define XEN_DOMCTL_shadow_op                     10
-#define XEN_DOMCTL_max_mem                       11
-#define XEN_DOMCTL_setvcpucontext                12
-#define XEN_DOMCTL_getvcpucontext                13
-#define XEN_DOMCTL_getvcpuinfo                   14
-#define XEN_DOMCTL_max_vcpus                     15
-#define XEN_DOMCTL_scheduler_op                  16
-#define XEN_DOMCTL_setdomainhandle               17
-#define XEN_DOMCTL_setdebugging                  18
-#define XEN_DOMCTL_irq_permission                19
-#define XEN_DOMCTL_iomem_permission              20
-#define XEN_DOMCTL_ioport_permission             21
-#define XEN_DOMCTL_hypercall_init                22
-#define XEN_DOMCTL_arch_setup                    23
-#define XEN_DOMCTL_settimeoffset                 24
-#define XEN_DOMCTL_getvcpuaffinity               25
-#define XEN_DOMCTL_real_mode_area                26
-#define XEN_DOMCTL_resumedomain                  27
-#define XEN_DOMCTL_sendtrigger                   28
-#define XEN_DOMCTL_subscribe                     29
-#define XEN_DOMCTL_gethvmcontext                 33
-#define XEN_DOMCTL_sethvmcontext                 34
-#define XEN_DOMCTL_set_address_size              35
-#define XEN_DOMCTL_get_address_size              36
-#define XEN_DOMCTL_assign_device                 37
-#define XEN_DOMCTL_bind_pt_irq                   38
-#define XEN_DOMCTL_memory_mapping                39
-#define XEN_DOMCTL_ioport_mapping                40
-#define XEN_DOMCTL_pin_mem_cacheattr             41
-#define XEN_DOMCTL_set_ext_vcpucontext           42
-#define XEN_DOMCTL_get_ext_vcpucontext           43
-#define XEN_DOMCTL_set_opt_feature               44
-#define XEN_DOMCTL_test_assign_device            45
-#define XEN_DOMCTL_set_target                    46
-#define XEN_DOMCTL_deassign_device               47
-#define XEN_DOMCTL_unbind_pt_irq                 48
-#define XEN_DOMCTL_set_cpuid                     49
-#define XEN_DOMCTL_get_device_group              50
-#define XEN_DOMCTL_set_machine_address_size      51
-#define XEN_DOMCTL_get_machine_address_size      52
-#define XEN_DOMCTL_suppress_spurious_page_faults 53
-#define XEN_DOMCTL_debug_op                      54
-#define XEN_DOMCTL_gethvmcontext_partial         55
-#define XEN_DOMCTL_mem_event_op                  56
-#define XEN_DOMCTL_mem_sharing_op                57
-#define XEN_DOMCTL_disable_migrate               58
-#define XEN_DOMCTL_gettscinfo                    59
-#define XEN_DOMCTL_settscinfo                    60
-#define XEN_DOMCTL_getpageframeinfo3             61
-#define XEN_DOMCTL_setvcpuextstate               62
-#define XEN_DOMCTL_getvcpuextstate               63
-#define XEN_DOMCTL_set_access_required           64
-#define XEN_DOMCTL_audit_p2m                     65
-#define XEN_DOMCTL_set_virq_handler              66
-#define XEN_DOMCTL_gdbsx_guestmemio            1000
-#define XEN_DOMCTL_gdbsx_pausevcpu             1001
-#define XEN_DOMCTL_gdbsx_unpausevcpu           1002
-#define XEN_DOMCTL_gdbsx_domstatus             1003
-    uint32_t interface_version; /* XEN_DOMCTL_INTERFACE_VERSION */
-    domid_t  domain;
-    union {
-        struct xen_domctl_createdomain      createdomain;
-        struct xen_domctl_getdomaininfo     getdomaininfo;
-        struct xen_domctl_getmemlist        getmemlist;
-        struct xen_domctl_getpageframeinfo  getpageframeinfo;
-        struct xen_domctl_getpageframeinfo2 getpageframeinfo2;
-        struct xen_domctl_getpageframeinfo3 getpageframeinfo3;
-        struct xen_domctl_vcpuaffinity      vcpuaffinity;
-        struct xen_domctl_shadow_op         shadow_op;
-        struct xen_domctl_max_mem           max_mem;
-        struct xen_domctl_vcpucontext       vcpucontext;
-        struct xen_domctl_getvcpuinfo       getvcpuinfo;
-        struct xen_domctl_max_vcpus         max_vcpus;
-        struct xen_domctl_scheduler_op      scheduler_op;
-        struct xen_domctl_setdomainhandle   setdomainhandle;
-        struct xen_domctl_setdebugging      setdebugging;
-        struct xen_domctl_irq_permission    irq_permission;
-        struct xen_domctl_iomem_permission  iomem_permission;
-        struct xen_domctl_ioport_permission ioport_permission;
-        struct xen_domctl_hypercall_init    hypercall_init;
-        struct xen_domctl_arch_setup        arch_setup;
-        struct xen_domctl_settimeoffset     settimeoffset;
-        struct xen_domctl_disable_migrate   disable_migrate;
-        struct xen_domctl_tsc_info          tsc_info;
-        struct xen_domctl_real_mode_area    real_mode_area;
-        struct xen_domctl_hvmcontext        hvmcontext;
-        struct xen_domctl_hvmcontext_partial hvmcontext_partial;
-        struct xen_domctl_address_size      address_size;
-        struct xen_domctl_sendtrigger       sendtrigger;
-        struct xen_domctl_get_device_group  get_device_group;
-        struct xen_domctl_assign_device     assign_device;
-        struct xen_domctl_bind_pt_irq       bind_pt_irq;
-        struct xen_domctl_memory_mapping    memory_mapping;
-        struct xen_domctl_ioport_mapping    ioport_mapping;
-        struct xen_domctl_pin_mem_cacheattr pin_mem_cacheattr;
-        struct xen_domctl_ext_vcpucontext   ext_vcpucontext;
-        struct xen_domctl_set_opt_feature   set_opt_feature;
-        struct xen_domctl_set_target        set_target;
-        struct xen_domctl_subscribe         subscribe;
-        struct xen_domctl_debug_op          debug_op;
-        struct xen_domctl_mem_event_op      mem_event_op;
-        struct xen_domctl_mem_sharing_op    mem_sharing_op;
-#if defined(__i386__) || defined(__x86_64__)
-        struct xen_domctl_cpuid             cpuid;
-        struct xen_domctl_vcpuextstate      vcpuextstate;
-#endif
-        struct xen_domctl_set_access_required access_required;
-        struct xen_domctl_audit_p2m         audit_p2m;
-        struct xen_domctl_set_virq_handler  set_virq_handler;
-        struct xen_domctl_gdbsx_memio       gdbsx_guest_memio;
-        struct xen_domctl_gdbsx_pauseunp_vcpu gdbsx_pauseunp_vcpu;
-        struct xen_domctl_gdbsx_domstatus   gdbsx_domstatus;
-        uint8_t                             pad[128];
-    } u;
-};
-typedef struct xen_domctl xen_domctl_t;
-DEFINE_XEN_GUEST_HANDLE(xen_domctl_t);
-
-#endif /* __XEN_PUBLIC_DOMCTL_H__ */
-
-/*
- * Local variables:
- * mode: C
- * c-set-style: "BSD"
- * c-basic-offset: 4
- * tab-width: 4
- * indent-tabs-mode: nil
- * End:
- */
diff -Nru xen-4.2.1-new/extras/mini-os/include/xen/elfnote.h xen-4.2.1/extras/mini-os/include/xen/elfnote.h
--- xen-4.2.1-new/extras/mini-os/include/xen/elfnote.h	2014-08-23 21:01:22.000000000 +0800
+++ xen-4.2.1/extras/mini-os/include/xen/elfnote.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,263 +0,0 @@
-/******************************************************************************
- * elfnote.h
- *
- * Definitions used for the Xen ELF notes.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- * Copyright (c) 2006, Ian Campbell, XenSource Ltd.
- */
-
-#ifndef __XEN_PUBLIC_ELFNOTE_H__
-#define __XEN_PUBLIC_ELFNOTE_H__
-
-/*
- * The notes should live in a PT_NOTE segment and have "Xen" in the
- * name field.
- *
- * Numeric types are either 4 or 8 bytes depending on the content of
- * the desc field.
- *
- * LEGACY indicated the fields in the legacy __xen_guest string which
- * this a note type replaces.
- */
-
-/*
- * NAME=VALUE pair (string).
- */
-#define XEN_ELFNOTE_INFO           0
-
-/*
- * The virtual address of the entry point (numeric).
- *
- * LEGACY: VIRT_ENTRY
- */
-#define XEN_ELFNOTE_ENTRY          1
-
-/* The virtual address of the hypercall transfer page (numeric).
- *
- * LEGACY: HYPERCALL_PAGE. (n.b. legacy value is a physical page
- * number not a virtual address)
- */
-#define XEN_ELFNOTE_HYPERCALL_PAGE 2
-
-/* The virtual address where the kernel image should be mapped (numeric).
- *
- * Defaults to 0.
- *
- * LEGACY: VIRT_BASE
- */
-#define XEN_ELFNOTE_VIRT_BASE      3
-
-/*
- * The offset of the ELF paddr field from the acutal required
- * psuedo-physical address (numeric).
- *
- * This is used to maintain backwards compatibility with older kernels
- * which wrote __PAGE_OFFSET into that field. This field defaults to 0
- * if not present.
- *
- * LEGACY: ELF_PADDR_OFFSET. (n.b. legacy default is VIRT_BASE)
- */
-#define XEN_ELFNOTE_PADDR_OFFSET   4
-
-/*
- * The version of Xen that we work with (string).
- *
- * LEGACY: XEN_VER
- */
-#define XEN_ELFNOTE_XEN_VERSION    5
-
-/*
- * The name of the guest operating system (string).
- *
- * LEGACY: GUEST_OS
- */
-#define XEN_ELFNOTE_GUEST_OS       6
-
-/*
- * The version of the guest operating system (string).
- *
- * LEGACY: GUEST_VER
- */
-#define XEN_ELFNOTE_GUEST_VERSION  7
-
-/*
- * The loader type (string).
- *
- * LEGACY: LOADER
- */
-#define XEN_ELFNOTE_LOADER         8
-
-/*
- * The kernel supports PAE (x86/32 only, string = "yes", "no" or
- * "bimodal").
- *
- * For compatibility with Xen 3.0.3 and earlier the "bimodal" setting
- * may be given as "yes,bimodal" which will cause older Xen to treat
- * this kernel as PAE.
- *
- * LEGACY: PAE (n.b. The legacy interface included a provision to
- * indicate 'extended-cr3' support allowing L3 page tables to be
- * placed above 4G. It is assumed that any kernel new enough to use
- * these ELF notes will include this and therefore "yes" here is
- * equivalent to "yes[entended-cr3]" in the __xen_guest interface.
- */
-#define XEN_ELFNOTE_PAE_MODE       9
-
-/*
- * The features supported/required by this kernel (string).
- *
- * The string must consist of a list of feature names (as given in
- * features.h, without the "XENFEAT_" prefix) separated by '|'
- * characters. If a feature is required for the kernel to function
- * then the feature name must be preceded by a '!' character.
- *
- * LEGACY: FEATURES
- */
-#define XEN_ELFNOTE_FEATURES      10
-
-/*
- * The kernel requires the symbol table to be loaded (string = "yes" or "no")
- * LEGACY: BSD_SYMTAB (n.b. The legacy treated the presence or absence
- * of this string as a boolean flag rather than requiring "yes" or
- * "no".
- */
-#define XEN_ELFNOTE_BSD_SYMTAB    11
-
-/*
- * The lowest address the hypervisor hole can begin at (numeric).
- *
- * This must not be set higher than HYPERVISOR_VIRT_START. Its presence
- * also indicates to the hypervisor that the kernel can deal with the
- * hole starting at a higher address.
- */
-#define XEN_ELFNOTE_HV_START_LOW  12
-
-/*
- * List of maddr_t-sized mask/value pairs describing how to recognize
- * (non-present) L1 page table entries carrying valid MFNs (numeric).
- */
-#define XEN_ELFNOTE_L1_MFN_VALID  13
-
-/*
- * Whether or not the guest supports cooperative suspend cancellation.
- */
-#define XEN_ELFNOTE_SUSPEND_CANCEL 14
-
-/*
- * The (non-default) location the initial phys-to-machine map should be
- * placed at by the hypervisor (Dom0) or the tools (DomU).
- * The kernel must be prepared for this mapping to be established using
- * large pages, despite such otherwise not being available to guests.
- * The kernel must also be able to handle the page table pages used for
- * this mapping not being accessible through the initial mapping.
- * (Only x86-64 supports this at present.)
- */
-#define XEN_ELFNOTE_INIT_P2M      15
-
-/*
- * Whether or not the guest can deal with being passed an initrd not
- * mapped through its initial page tables.
- */
-#define XEN_ELFNOTE_MOD_START_PFN 16
-
-/*
- * The features supported by this kernel (numeric).
- *
- * Other than XEN_ELFNOTE_FEATURES on pre-4.2 Xen, this note allows a
- * kernel to specify support for features that older hypervisors don't
- * know about. The set of features 4.2 and newer hypervisors will
- * consider supported by the kernel is the combination of the sets
- * specified through this and the string note.
- *
- * LEGACY: FEATURES
- */
-#define XEN_ELFNOTE_SUPPORTED_FEATURES 17
-
-/*
- * The number of the highest elfnote defined.
- */
-#define XEN_ELFNOTE_MAX XEN_ELFNOTE_SUPPORTED_FEATURES
-
-/*
- * System information exported through crash notes.
- *
- * The kexec / kdump code will create one XEN_ELFNOTE_CRASH_INFO 
- * note in case of a system crash. This note will contain various
- * information about the system, see xen/include/xen/elfcore.h.
- */
-#define XEN_ELFNOTE_CRASH_INFO 0x1000001
-
-/*
- * System registers exported through crash notes.
- *
- * The kexec / kdump code will create one XEN_ELFNOTE_CRASH_REGS 
- * note per cpu in case of a system crash. This note is architecture
- * specific and will contain registers not saved in the "CORE" note.
- * See xen/include/xen/elfcore.h for more information.
- */
-#define XEN_ELFNOTE_CRASH_REGS 0x1000002
-
-
-/*
- * xen dump-core none note.
- * xm dump-core code will create one XEN_ELFNOTE_DUMPCORE_NONE
- * in its dump file to indicate that the file is xen dump-core
- * file. This note doesn't have any other information.
- * See tools/libxc/xc_core.h for more information.
- */
-#define XEN_ELFNOTE_DUMPCORE_NONE               0x2000000
-
-/*
- * xen dump-core header note.
- * xm dump-core code will create one XEN_ELFNOTE_DUMPCORE_HEADER
- * in its dump file.
- * See tools/libxc/xc_core.h for more information.
- */
-#define XEN_ELFNOTE_DUMPCORE_HEADER             0x2000001
-
-/*
- * xen dump-core xen version note.
- * xm dump-core code will create one XEN_ELFNOTE_DUMPCORE_XEN_VERSION
- * in its dump file. It contains the xen version obtained via the
- * XENVER hypercall.
- * See tools/libxc/xc_core.h for more information.
- */
-#define XEN_ELFNOTE_DUMPCORE_XEN_VERSION        0x2000002
-
-/*
- * xen dump-core format version note.
- * xm dump-core code will create one XEN_ELFNOTE_DUMPCORE_FORMAT_VERSION
- * in its dump file. It contains a format version identifier.
- * See tools/libxc/xc_core.h for more information.
- */
-#define XEN_ELFNOTE_DUMPCORE_FORMAT_VERSION     0x2000003
-
-#endif /* __XEN_PUBLIC_ELFNOTE_H__ */
-
-/*
- * Local variables:
- * mode: C
- * c-set-style: "BSD"
- * c-basic-offset: 4
- * tab-width: 4
- * indent-tabs-mode: nil
- * End:
- */
diff -Nru xen-4.2.1-new/extras/mini-os/include/xen/event_channel.h xen-4.2.1/extras/mini-os/include/xen/event_channel.h
--- xen-4.2.1-new/extras/mini-os/include/xen/event_channel.h	2014-08-23 21:01:22.000000000 +0800
+++ xen-4.2.1/extras/mini-os/include/xen/event_channel.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,294 +0,0 @@
-/******************************************************************************
- * event_channel.h
- *
- * Event channels between domains.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- * Copyright (c) 2003-2004, K A Fraser.
- */
-
-#ifndef __XEN_PUBLIC_EVENT_CHANNEL_H__
-#define __XEN_PUBLIC_EVENT_CHANNEL_H__
-
-#include "xen.h"
-
-/*
- * `incontents 150 evtchn Event Channels
- *
- * Event channels are the basic primitive provided by Xen for event
- * notifications. An event is the Xen equivalent of a hardware
- * interrupt. They essentially store one bit of information, the event
- * of interest is signalled by transitioning this bit from 0 to 1.
- *
- * Notifications are received by a guest via an upcall from Xen,
- * indicating when an event arrives (setting the bit). Further
- * notifications are masked until the bit is cleared again (therefore,
- * guests must check the value of the bit after re-enabling event
- * delivery to ensure no missed notifications).
- *
- * Event notifications can be masked by setting a flag; this is
- * equivalent to disabling interrupts and can be used to ensure
- * atomicity of certain operations in the guest kernel.
- *
- * Event channels are represented by the evtchn_* fields in
- * struct shared_info and struct vcpu_info.
- */
-
-/*
- * ` enum neg_errnoval
- * ` HYPERVISOR_event_channel_op(enum event_channel_op cmd, void *args)
- * `
- * @cmd  == EVTCHNOP_* (event-channel operation).
- * @args == struct evtchn_* Operation-specific extra arguments (NULL if none).
- */
-
-/* ` enum event_channel_op { // EVTCHNOP_* => struct evtchn_* */
-#define EVTCHNOP_bind_interdomain 0
-#define EVTCHNOP_bind_virq        1
-#define EVTCHNOP_bind_pirq        2
-#define EVTCHNOP_close            3
-#define EVTCHNOP_send             4
-#define EVTCHNOP_status           5
-#define EVTCHNOP_alloc_unbound    6
-#define EVTCHNOP_bind_ipi         7
-#define EVTCHNOP_bind_vcpu        8
-#define EVTCHNOP_unmask           9
-#define EVTCHNOP_reset           10
-/* ` } */
-
-typedef uint32_t evtchn_port_t;
-DEFINE_XEN_GUEST_HANDLE(evtchn_port_t);
-
-/*
- * EVTCHNOP_alloc_unbound: Allocate a port in domain <dom> and mark as
- * accepting interdomain bindings from domain <remote_dom>. A fresh port
- * is allocated in <dom> and returned as <port>.
- * NOTES:
- *  1. If the caller is unprivileged then <dom> must be DOMID_SELF.
- *  2. <rdom> may be DOMID_SELF, allowing loopback connections.
- */
-struct evtchn_alloc_unbound {
-    /* IN parameters */
-    domid_t dom, remote_dom;
-    /* OUT parameters */
-    evtchn_port_t port;
-};
-typedef struct evtchn_alloc_unbound evtchn_alloc_unbound_t;
-
-/*
- * EVTCHNOP_bind_interdomain: Construct an interdomain event channel between
- * the calling domain and <remote_dom>. <remote_dom,remote_port> must identify
- * a port that is unbound and marked as accepting bindings from the calling
- * domain. A fresh port is allocated in the calling domain and returned as
- * <local_port>.
- * NOTES:
- *  1. <remote_dom> may be DOMID_SELF, allowing loopback connections.
- */
-struct evtchn_bind_interdomain {
-    /* IN parameters. */
-    domid_t remote_dom;
-    evtchn_port_t remote_port;
-    /* OUT parameters. */
-    evtchn_port_t local_port;
-};
-typedef struct evtchn_bind_interdomain evtchn_bind_interdomain_t;
-
-/*
- * EVTCHNOP_bind_virq: Bind a local event channel to VIRQ <irq> on specified
- * vcpu.
- * NOTES:
- *  1. Virtual IRQs are classified as per-vcpu or global. See the VIRQ list
- *     in xen.h for the classification of each VIRQ.
- *  2. Global VIRQs must be allocated on VCPU0 but can subsequently be
- *     re-bound via EVTCHNOP_bind_vcpu.
- *  3. Per-vcpu VIRQs may be bound to at most one event channel per vcpu.
- *     The allocated event channel is bound to the specified vcpu and the
- *     binding cannot be changed.
- */
-struct evtchn_bind_virq {
-    /* IN parameters. */
-    uint32_t virq; /* enum virq */
-    uint32_t vcpu;
-    /* OUT parameters. */
-    evtchn_port_t port;
-};
-typedef struct evtchn_bind_virq evtchn_bind_virq_t;
-
-/*
- * EVTCHNOP_bind_pirq: Bind a local event channel to a real IRQ (PIRQ <irq>).
- * NOTES:
- *  1. A physical IRQ may be bound to at most one event channel per domain.
- *  2. Only a sufficiently-privileged domain may bind to a physical IRQ.
- */
-struct evtchn_bind_pirq {
-    /* IN parameters. */
-    uint32_t pirq;
-#define BIND_PIRQ__WILL_SHARE 1
-    uint32_t flags; /* BIND_PIRQ__* */
-    /* OUT parameters. */
-    evtchn_port_t port;
-};
-typedef struct evtchn_bind_pirq evtchn_bind_pirq_t;
-
-/*
- * EVTCHNOP_bind_ipi: Bind a local event channel to receive events.
- * NOTES:
- *  1. The allocated event channel is bound to the specified vcpu. The binding
- *     may not be changed.
- */
-struct evtchn_bind_ipi {
-    uint32_t vcpu;
-    /* OUT parameters. */
-    evtchn_port_t port;
-};
-typedef struct evtchn_bind_ipi evtchn_bind_ipi_t;
-
-/*
- * EVTCHNOP_close: Close a local event channel <port>. If the channel is
- * interdomain then the remote end is placed in the unbound state
- * (EVTCHNSTAT_unbound), awaiting a new connection.
- */
-struct evtchn_close {
-    /* IN parameters. */
-    evtchn_port_t port;
-};
-typedef struct evtchn_close evtchn_close_t;
-
-/*
- * EVTCHNOP_send: Send an event to the remote end of the channel whose local
- * endpoint is <port>.
- */
-struct evtchn_send {
-    /* IN parameters. */
-    evtchn_port_t port;
-};
-typedef struct evtchn_send evtchn_send_t;
-
-/*
- * EVTCHNOP_status: Get the current status of the communication channel which
- * has an endpoint at <dom, port>.
- * NOTES:
- *  1. <dom> may be specified as DOMID_SELF.
- *  2. Only a sufficiently-privileged domain may obtain the status of an event
- *     channel for which <dom> is not DOMID_SELF.
- */
-struct evtchn_status {
-    /* IN parameters */
-    domid_t  dom;
-    evtchn_port_t port;
-    /* OUT parameters */
-#define EVTCHNSTAT_closed       0  /* Channel is not in use.                 */
-#define EVTCHNSTAT_unbound      1  /* Channel is waiting interdom connection.*/
-#define EVTCHNSTAT_interdomain  2  /* Channel is connected to remote domain. */
-#define EVTCHNSTAT_pirq         3  /* Channel is bound to a phys IRQ line.   */
-#define EVTCHNSTAT_virq         4  /* Channel is bound to a virtual IRQ line */
-#define EVTCHNSTAT_ipi          5  /* Channel is bound to a virtual IPI line */
-    uint32_t status;
-    uint32_t vcpu;                 /* VCPU to which this channel is bound.   */
-    union {
-        struct {
-            domid_t dom;
-        } unbound;                 /* EVTCHNSTAT_unbound */
-        struct {
-            domid_t dom;
-            evtchn_port_t port;
-        } interdomain;             /* EVTCHNSTAT_interdomain */
-        uint32_t pirq;             /* EVTCHNSTAT_pirq        */
-        uint32_t virq;             /* EVTCHNSTAT_virq        */
-    } u;
-};
-typedef struct evtchn_status evtchn_status_t;
-
-/*
- * EVTCHNOP_bind_vcpu: Specify which vcpu a channel should notify when an
- * event is pending.
- * NOTES:
- *  1. IPI-bound channels always notify the vcpu specified at bind time.
- *     This binding cannot be changed.
- *  2. Per-VCPU VIRQ channels always notify the vcpu specified at bind time.
- *     This binding cannot be changed.
- *  3. All other channels notify vcpu0 by default. This default is set when
- *     the channel is allocated (a port that is freed and subsequently reused
- *     has its binding reset to vcpu0).
- */
-struct evtchn_bind_vcpu {
-    /* IN parameters. */
-    evtchn_port_t port;
-    uint32_t vcpu;
-};
-typedef struct evtchn_bind_vcpu evtchn_bind_vcpu_t;
-
-/*
- * EVTCHNOP_unmask: Unmask the specified local event-channel port and deliver
- * a notification to the appropriate VCPU if an event is pending.
- */
-struct evtchn_unmask {
-    /* IN parameters. */
-    evtchn_port_t port;
-};
-typedef struct evtchn_unmask evtchn_unmask_t;
-
-/*
- * EVTCHNOP_reset: Close all event channels associated with specified domain.
- * NOTES:
- *  1. <dom> may be specified as DOMID_SELF.
- *  2. Only a sufficiently-privileged domain may specify other than DOMID_SELF.
- */
-struct evtchn_reset {
-    /* IN parameters. */
-    domid_t dom;
-};
-typedef struct evtchn_reset evtchn_reset_t;
-
-/*
- * ` enum neg_errnoval
- * ` HYPERVISOR_event_channel_op_compat(struct evtchn_op *op)
- * `
- * Superceded by new event_channel_op() hypercall since 0x00030202.
- */
-struct evtchn_op {
-    uint32_t cmd; /* enum event_channel_op */
-    union {
-        struct evtchn_alloc_unbound    alloc_unbound;
-        struct evtchn_bind_interdomain bind_interdomain;
-        struct evtchn_bind_virq        bind_virq;
-        struct evtchn_bind_pirq        bind_pirq;
-        struct evtchn_bind_ipi         bind_ipi;
-        struct evtchn_close            close;
-        struct evtchn_send             send;
-        struct evtchn_status           status;
-        struct evtchn_bind_vcpu        bind_vcpu;
-        struct evtchn_unmask           unmask;
-    } u;
-};
-typedef struct evtchn_op evtchn_op_t;
-DEFINE_XEN_GUEST_HANDLE(evtchn_op_t);
-
-#endif /* __XEN_PUBLIC_EVENT_CHANNEL_H__ */
-
-/*
- * Local variables:
- * mode: C
- * c-set-style: "BSD"
- * c-basic-offset: 4
- * tab-width: 4
- * indent-tabs-mode: nil
- * End:
- */
diff -Nru xen-4.2.1-new/extras/mini-os/include/xen/features.h xen-4.2.1/extras/mini-os/include/xen/features.h
--- xen-4.2.1-new/extras/mini-os/include/xen/features.h	2014-08-23 21:01:22.000000000 +0800
+++ xen-4.2.1/extras/mini-os/include/xen/features.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,95 +0,0 @@
-/******************************************************************************
- * features.h
- * 
- * Feature flags, reported by XENVER_get_features.
- * 
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- * Copyright (c) 2006, Keir Fraser <keir@xensource.com>
- */
-
-#ifndef __XEN_PUBLIC_FEATURES_H__
-#define __XEN_PUBLIC_FEATURES_H__
-
-/*
- * If set, the guest does not need to write-protect its pagetables, and can
- * update them via direct writes.
- */
-#define XENFEAT_writable_page_tables       0
-
-/*
- * If set, the guest does not need to write-protect its segment descriptor
- * tables, and can update them via direct writes.
- */
-#define XENFEAT_writable_descriptor_tables 1
-
-/*
- * If set, translation between the guest's 'pseudo-physical' address space
- * and the host's machine address space are handled by the hypervisor. In this
- * mode the guest does not need to perform phys-to/from-machine translations
- * when performing page table operations.
- */
-#define XENFEAT_auto_translated_physmap    2
-
-/* If set, the guest is running in supervisor mode (e.g., x86 ring 0). */
-#define XENFEAT_supervisor_mode_kernel     3
-
-/*
- * If set, the guest does not need to allocate x86 PAE page directories
- * below 4GB. This flag is usually implied by auto_translated_physmap.
- */
-#define XENFEAT_pae_pgdir_above_4gb        4
-
-/* x86: Does this Xen host support the MMU_PT_UPDATE_PRESERVE_AD hypercall? */
-#define XENFEAT_mmu_pt_update_preserve_ad  5
-
-/* x86: Does this Xen host support the MMU_{CLEAR,COPY}_PAGE hypercall? */
-#define XENFEAT_highmem_assist             6
-
-/*
- * If set, GNTTABOP_map_grant_ref honors flags to be placed into guest kernel
- * available pte bits.
- */
-#define XENFEAT_gnttab_map_avail_bits      7
-
-/* x86: Does this Xen host support the HVM callback vector type? */
-#define XENFEAT_hvm_callback_vector        8
-
-/* x86: pvclock algorithm is safe to use on HVM */
-#define XENFEAT_hvm_safe_pvclock           9
-
-/* x86: pirq can be used by HVM guests */
-#define XENFEAT_hvm_pirqs                 10
-
-/* operation as Dom0 is supported */
-#define XENFEAT_dom0                      11
-
-#define XENFEAT_NR_SUBMAPS 1
-
-#endif /* __XEN_PUBLIC_FEATURES_H__ */
-
-/*
- * Local variables:
- * mode: C
- * c-set-style: "BSD"
- * c-basic-offset: 4
- * tab-width: 4
- * indent-tabs-mode: nil
- * End:
- */
diff -Nru xen-4.2.1-new/extras/mini-os/include/xen/grant_table.h xen-4.2.1/extras/mini-os/include/xen/grant_table.h
--- xen-4.2.1-new/extras/mini-os/include/xen/grant_table.h	2014-08-23 21:01:22.000000000 +0800
+++ xen-4.2.1/extras/mini-os/include/xen/grant_table.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,660 +0,0 @@
-/******************************************************************************
- * grant_table.h
- *
- * Interface for granting foreign access to page frames, and receiving
- * page-ownership transfers.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- * Copyright (c) 2004, K A Fraser
- */
-
-#ifndef __XEN_PUBLIC_GRANT_TABLE_H__
-#define __XEN_PUBLIC_GRANT_TABLE_H__
-
-#include "xen.h"
-
-/*
- * `incontents 150 gnttab Grant Tables
- *
- * Xen's grant tables provide a generic mechanism to memory sharing
- * between domains. This shared memory interface underpins the split
- * device drivers for block and network IO.
- *
- * Each domain has its own grant table. This is a data structure that
- * is shared with Xen; it allows the domain to tell Xen what kind of
- * permissions other domains have on its pages. Entries in the grant
- * table are identified by grant references. A grant reference is an
- * integer, which indexes into the grant table. It acts as a
- * capability which the grantee can use to perform operations on the
- * granters memory.
- *
- * This capability-based system allows shared-memory communications
- * between unprivileged domains. A grant reference also encapsulates
- * the details of a shared page, removing the need for a domain to
- * know the real machine address of a page it is sharing. This makes
- * it possible to share memory correctly with domains running in
- * fully virtualised memory.
- */
-
-/***********************************
- * GRANT TABLE REPRESENTATION
- */
-
-/* Some rough guidelines on accessing and updating grant-table entries
- * in a concurrency-safe manner. For more information, Linux contains a
- * reference implementation for guest OSes (drivers/xen/grant_table.c, see
- * http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=blob;f=drivers/xen/grant-table.c;hb=HEAD
- *
- * NB. WMB is a no-op on current-generation x86 processors. However, a
- *     compiler barrier will still be required.
- *
- * Introducing a valid entry into the grant table:
- *  1. Write ent->domid.
- *  2. Write ent->frame:
- *      GTF_permit_access:   Frame to which access is permitted.
- *      GTF_accept_transfer: Pseudo-phys frame slot being filled by new
- *                           frame, or zero if none.
- *  3. Write memory barrier (WMB).
- *  4. Write ent->flags, inc. valid type.
- *
- * Invalidating an unused GTF_permit_access entry:
- *  1. flags = ent->flags.
- *  2. Observe that !(flags & (GTF_reading|GTF_writing)).
- *  3. Check result of SMP-safe CMPXCHG(&ent->flags, flags, 0).
- *  NB. No need for WMB as reuse of entry is control-dependent on success of
- *      step 3, and all architectures guarantee ordering of ctrl-dep writes.
- *
- * Invalidating an in-use GTF_permit_access entry:
- *  This cannot be done directly. Request assistance from the domain controller
- *  which can set a timeout on the use of a grant entry and take necessary
- *  action. (NB. This is not yet implemented!).
- *
- * Invalidating an unused GTF_accept_transfer entry:
- *  1. flags = ent->flags.
- *  2. Observe that !(flags & GTF_transfer_committed). [*]
- *  3. Check result of SMP-safe CMPXCHG(&ent->flags, flags, 0).
- *  NB. No need for WMB as reuse of entry is control-dependent on success of
- *      step 3, and all architectures guarantee ordering of ctrl-dep writes.
- *  [*] If GTF_transfer_committed is set then the grant entry is 'committed'.
- *      The guest must /not/ modify the grant entry until the address of the
- *      transferred frame is written. It is safe for the guest to spin waiting
- *      for this to occur (detect by observing GTF_transfer_completed in
- *      ent->flags).
- *
- * Invalidating a committed GTF_accept_transfer entry:
- *  1. Wait for (ent->flags & GTF_transfer_completed).
- *
- * Changing a GTF_permit_access from writable to read-only:
- *  Use SMP-safe CMPXCHG to set GTF_readonly, while checking !GTF_writing.
- *
- * Changing a GTF_permit_access from read-only to writable:
- *  Use SMP-safe bit-setting instruction.
- */
-
-/*
- * Reference to a grant entry in a specified domain's grant table.
- */
-typedef uint32_t grant_ref_t;
-
-/*
- * A grant table comprises a packed array of grant entries in one or more
- * page frames shared between Xen and a guest.
- * [XEN]: This field is written by Xen and read by the sharing guest.
- * [GST]: This field is written by the guest and read by Xen.
- */
-
-/*
- * Version 1 of the grant table entry structure is maintained purely
- * for backwards compatibility.  New guests should use version 2.
- */
-#if __XEN_INTERFACE_VERSION__ < 0x0003020a
-#define grant_entry_v1 grant_entry
-#define grant_entry_v1_t grant_entry_t
-#endif
-struct grant_entry_v1 {
-    /* GTF_xxx: various type and flag information.  [XEN,GST] */
-    uint16_t flags;
-    /* The domain being granted foreign privileges. [GST] */
-    domid_t  domid;
-    /*
-     * GTF_permit_access: Frame that @domid is allowed to map and access. [GST]
-     * GTF_accept_transfer: Frame whose ownership transferred by @domid. [XEN]
-     */
-    uint32_t frame;
-};
-typedef struct grant_entry_v1 grant_entry_v1_t;
-
-/* The first few grant table entries will be preserved across grant table
- * version changes and may be pre-populated at domain creation by tools.
- */
-#define GNTTAB_NR_RESERVED_ENTRIES     8
-#define GNTTAB_RESERVED_CONSOLE        0
-#define GNTTAB_RESERVED_XENSTORE       1
-
-/*
- * Type of grant entry.
- *  GTF_invalid: This grant entry grants no privileges.
- *  GTF_permit_access: Allow @domid to map/access @frame.
- *  GTF_accept_transfer: Allow @domid to transfer ownership of one page frame
- *                       to this guest. Xen writes the page number to @frame.
- *  GTF_transitive: Allow @domid to transitively access a subrange of
- *                  @trans_grant in @trans_domid.  No mappings are allowed.
- */
-#define GTF_invalid         (0U<<0)
-#define GTF_permit_access   (1U<<0)
-#define GTF_accept_transfer (2U<<0)
-#define GTF_transitive      (3U<<0)
-#define GTF_type_mask       (3U<<0)
-
-/*
- * Subflags for GTF_permit_access.
- *  GTF_readonly: Restrict @domid to read-only mappings and accesses. [GST]
- *  GTF_reading: Grant entry is currently mapped for reading by @domid. [XEN]
- *  GTF_writing: Grant entry is currently mapped for writing by @domid. [XEN]
- *  GTF_PAT, GTF_PWT, GTF_PCD: (x86) cache attribute flags for the grant [GST]
- *  GTF_sub_page: Grant access to only a subrange of the page.  @domid
- *                will only be allowed to copy from the grant, and not
- *                map it. [GST]
- */
-#define _GTF_readonly       (2)
-#define GTF_readonly        (1U<<_GTF_readonly)
-#define _GTF_reading        (3)
-#define GTF_reading         (1U<<_GTF_reading)
-#define _GTF_writing        (4)
-#define GTF_writing         (1U<<_GTF_writing)
-#define _GTF_PWT            (5)
-#define GTF_PWT             (1U<<_GTF_PWT)
-#define _GTF_PCD            (6)
-#define GTF_PCD             (1U<<_GTF_PCD)
-#define _GTF_PAT            (7)
-#define GTF_PAT             (1U<<_GTF_PAT)
-#define _GTF_sub_page       (8)
-#define GTF_sub_page        (1U<<_GTF_sub_page)
-
-/*
- * Subflags for GTF_accept_transfer:
- *  GTF_transfer_committed: Xen sets this flag to indicate that it is committed
- *      to transferring ownership of a page frame. When a guest sees this flag
- *      it must /not/ modify the grant entry until GTF_transfer_completed is
- *      set by Xen.
- *  GTF_transfer_completed: It is safe for the guest to spin-wait on this flag
- *      after reading GTF_transfer_committed. Xen will always write the frame
- *      address, followed by ORing this flag, in a timely manner.
- */
-#define _GTF_transfer_committed (2)
-#define GTF_transfer_committed  (1U<<_GTF_transfer_committed)
-#define _GTF_transfer_completed (3)
-#define GTF_transfer_completed  (1U<<_GTF_transfer_completed)
-
-/*
- * Version 2 grant table entries.  These fulfil the same role as
- * version 1 entries, but can represent more complicated operations.
- * Any given domain will have either a version 1 or a version 2 table,
- * and every entry in the table will be the same version.
- *
- * The interface by which domains use grant references does not depend
- * on the grant table version in use by the other domain.
- */
-#if __XEN_INTERFACE_VERSION__ >= 0x0003020a
-/*
- * Version 1 and version 2 grant entries share a common prefix.  The
- * fields of the prefix are documented as part of struct
- * grant_entry_v1.
- */
-struct grant_entry_header {
-    uint16_t flags;
-    domid_t  domid;
-};
-typedef struct grant_entry_header grant_entry_header_t;
-
-/*
- * Version 2 of the grant entry structure.
- */
-union grant_entry_v2 {
-    grant_entry_header_t hdr;
-
-    /*
-     * This member is used for V1-style full page grants, where either:
-     *
-     * -- hdr.type is GTF_accept_transfer, or
-     * -- hdr.type is GTF_permit_access and GTF_sub_page is not set.
-     *
-     * In that case, the frame field has the same semantics as the
-     * field of the same name in the V1 entry structure.
-     */
-    struct {
-        grant_entry_header_t hdr;
-        uint32_t pad0;
-        uint64_t frame;
-    } full_page;
-
-    /*
-     * If the grant type is GTF_grant_access and GTF_sub_page is set,
-     * @domid is allowed to access bytes [@page_off,@page_off+@length)
-     * in frame @frame.
-     */
-    struct {
-        grant_entry_header_t hdr;
-        uint16_t page_off;
-        uint16_t length;
-        uint64_t frame;
-    } sub_page;
-
-    /*
-     * If the grant is GTF_transitive, @domid is allowed to use the
-     * grant @gref in domain @trans_domid, as if it was the local
-     * domain.  Obviously, the transitive access must be compatible
-     * with the original grant.
-     *
-     * The current version of Xen does not allow transitive grants
-     * to be mapped.
-     */
-    struct {
-        grant_entry_header_t hdr;
-        domid_t trans_domid;
-        uint16_t pad0;
-        grant_ref_t gref;
-    } transitive;
-
-    uint32_t __spacer[4]; /* Pad to a power of two */
-};
-typedef union grant_entry_v2 grant_entry_v2_t;
-
-typedef uint16_t grant_status_t;
-
-#endif /* __XEN_INTERFACE_VERSION__ */
-
-/***********************************
- * GRANT TABLE QUERIES AND USES
- */
-
-/* ` enum neg_errnoval
- * ` HYPERVISOR_grant_table_op(enum grant_table_op cmd,
- * `                           void *args,
- * `                           unsigned int count)
- * `
- *
- * @args points to an array of a per-command data structure. The array
- * has @count members
- */
-
-/* ` enum grant_table_op { // GNTTABOP_* => struct gnttab_* */
-#define GNTTABOP_map_grant_ref        0
-#define GNTTABOP_unmap_grant_ref      1
-#define GNTTABOP_setup_table          2
-#define GNTTABOP_dump_table           3
-#define GNTTABOP_transfer             4
-#define GNTTABOP_copy                 5
-#define GNTTABOP_query_size           6
-#define GNTTABOP_unmap_and_replace    7
-#if __XEN_INTERFACE_VERSION__ >= 0x0003020a
-#define GNTTABOP_set_version          8
-#define GNTTABOP_get_status_frames    9
-#define GNTTABOP_get_version          10
-#define GNTTABOP_swap_grant_ref	      11
-#endif /* __XEN_INTERFACE_VERSION__ */
-/* ` } */
-
-/*
- * Handle to track a mapping created via a grant reference.
- */
-typedef uint32_t grant_handle_t;
-
-/*
- * GNTTABOP_map_grant_ref: Map the grant entry (<dom>,<ref>) for access
- * by devices and/or host CPUs. If successful, <handle> is a tracking number
- * that must be presented later to destroy the mapping(s). On error, <handle>
- * is a negative status code.
- * NOTES:
- *  1. If GNTMAP_device_map is specified then <dev_bus_addr> is the address
- *     via which I/O devices may access the granted frame.
- *  2. If GNTMAP_host_map is specified then a mapping will be added at
- *     either a host virtual address in the current address space, or at
- *     a PTE at the specified machine address.  The type of mapping to
- *     perform is selected through the GNTMAP_contains_pte flag, and the
- *     address is specified in <host_addr>.
- *  3. Mappings should only be destroyed via GNTTABOP_unmap_grant_ref. If a
- *     host mapping is destroyed by other means then it is *NOT* guaranteed
- *     to be accounted to the correct grant reference!
- */
-struct gnttab_map_grant_ref {
-    /* IN parameters. */
-    uint64_t host_addr;
-    uint32_t flags;               /* GNTMAP_* */
-    grant_ref_t ref;
-    domid_t  dom;
-    /* OUT parameters. */
-    int16_t  status;              /* => enum grant_status */
-    grant_handle_t handle;
-    uint64_t dev_bus_addr;
-};
-typedef struct gnttab_map_grant_ref gnttab_map_grant_ref_t;
-DEFINE_XEN_GUEST_HANDLE(gnttab_map_grant_ref_t);
-
-/*
- * GNTTABOP_unmap_grant_ref: Destroy one or more grant-reference mappings
- * tracked by <handle>. If <host_addr> or <dev_bus_addr> is zero, that
- * field is ignored. If non-zero, they must refer to a device/host mapping
- * that is tracked by <handle>
- * NOTES:
- *  1. The call may fail in an undefined manner if either mapping is not
- *     tracked by <handle>.
- *  3. After executing a batch of unmaps, it is guaranteed that no stale
- *     mappings will remain in the device or host TLBs.
- */
-struct gnttab_unmap_grant_ref {
-    /* IN parameters. */
-    uint64_t host_addr;
-    uint64_t dev_bus_addr;
-    grant_handle_t handle;
-    /* OUT parameters. */
-    int16_t  status;              /* => enum grant_status */
-};
-typedef struct gnttab_unmap_grant_ref gnttab_unmap_grant_ref_t;
-DEFINE_XEN_GUEST_HANDLE(gnttab_unmap_grant_ref_t);
-
-/*
- * GNTTABOP_setup_table: Set up a grant table for <dom> comprising at least
- * <nr_frames> pages. The frame addresses are written to the <frame_list>.
- * Only <nr_frames> addresses are written, even if the table is larger.
- * NOTES:
- *  1. <dom> may be specified as DOMID_SELF.
- *  2. Only a sufficiently-privileged domain may specify <dom> != DOMID_SELF.
- *  3. Xen may not support more than a single grant-table page per domain.
- */
-struct gnttab_setup_table {
-    /* IN parameters. */
-    domid_t  dom;
-    uint32_t nr_frames;
-    /* OUT parameters. */
-    int16_t  status;              /* => enum grant_status */
-    XEN_GUEST_HANDLE(ulong) frame_list;
-};
-typedef struct gnttab_setup_table gnttab_setup_table_t;
-DEFINE_XEN_GUEST_HANDLE(gnttab_setup_table_t);
-
-/*
- * GNTTABOP_dump_table: Dump the contents of the grant table to the
- * xen console. Debugging use only.
- */
-struct gnttab_dump_table {
-    /* IN parameters. */
-    domid_t dom;
-    /* OUT parameters. */
-    int16_t status;               /* => enum grant_status */
-};
-typedef struct gnttab_dump_table gnttab_dump_table_t;
-DEFINE_XEN_GUEST_HANDLE(gnttab_dump_table_t);
-
-/*
- * GNTTABOP_transfer_grant_ref: Transfer <frame> to a foreign domain. The
- * foreign domain has previously registered its interest in the transfer via
- * <domid, ref>.
- *
- * Note that, even if the transfer fails, the specified page no longer belongs
- * to the calling domain *unless* the error is GNTST_bad_page.
- */
-struct gnttab_transfer {
-    /* IN parameters. */
-    xen_pfn_t     mfn;
-    domid_t       domid;
-    grant_ref_t   ref;
-    /* OUT parameters. */
-    int16_t       status;
-};
-typedef struct gnttab_transfer gnttab_transfer_t;
-DEFINE_XEN_GUEST_HANDLE(gnttab_transfer_t);
-
-
-/*
- * GNTTABOP_copy: Hypervisor based copy
- * source and destinations can be eithers MFNs or, for foreign domains,
- * grant references. the foreign domain has to grant read/write access
- * in its grant table.
- *
- * The flags specify what type source and destinations are (either MFN
- * or grant reference).
- *
- * Note that this can also be used to copy data between two domains
- * via a third party if the source and destination domains had previously
- * grant appropriate access to their pages to the third party.
- *
- * source_offset specifies an offset in the source frame, dest_offset
- * the offset in the target frame and  len specifies the number of
- * bytes to be copied.
- */
-
-#define _GNTCOPY_source_gref      (0)
-#define GNTCOPY_source_gref       (1<<_GNTCOPY_source_gref)
-#define _GNTCOPY_dest_gref        (1)
-#define GNTCOPY_dest_gref         (1<<_GNTCOPY_dest_gref)
-#define _GNTCOPY_can_fail         (2)
-#define GNTCOPY_can_fail          (1<<_GNTCOPY_can_fail)
-
-struct gnttab_copy {
-    /* IN parameters. */
-    struct {
-        union {
-            grant_ref_t ref;
-            xen_pfn_t   gmfn;
-        } u;
-        domid_t  domid;
-        uint16_t offset;
-    } source, dest;
-    uint16_t      len;
-    uint16_t      flags;          /* GNTCOPY_* */
-    /* OUT parameters. */
-    int16_t       status;
-};
-typedef struct gnttab_copy  gnttab_copy_t;
-DEFINE_XEN_GUEST_HANDLE(gnttab_copy_t);
-
-/*
- * GNTTABOP_query_size: Query the current and maximum sizes of the shared
- * grant table.
- * NOTES:
- *  1. <dom> may be specified as DOMID_SELF.
- *  2. Only a sufficiently-privileged domain may specify <dom> != DOMID_SELF.
- */
-struct gnttab_query_size {
-    /* IN parameters. */
-    domid_t  dom;
-    /* OUT parameters. */
-    uint32_t nr_frames;
-    uint32_t max_nr_frames;
-    int16_t  status;              /* => enum grant_status */
-};
-typedef struct gnttab_query_size gnttab_query_size_t;
-DEFINE_XEN_GUEST_HANDLE(gnttab_query_size_t);
-
-/*
- * GNTTABOP_unmap_and_replace: Destroy one or more grant-reference mappings
- * tracked by <handle> but atomically replace the page table entry with one
- * pointing to the machine address under <new_addr>.  <new_addr> will be
- * redirected to the null entry.
- * NOTES:
- *  1. The call may fail in an undefined manner if either mapping is not
- *     tracked by <handle>.
- *  2. After executing a batch of unmaps, it is guaranteed that no stale
- *     mappings will remain in the device or host TLBs.
- */
-struct gnttab_unmap_and_replace {
-    /* IN parameters. */
-    uint64_t host_addr;
-    uint64_t new_addr;
-    grant_handle_t handle;
-    /* OUT parameters. */
-    int16_t  status;              /* => enum grant_status */
-};
-typedef struct gnttab_unmap_and_replace gnttab_unmap_and_replace_t;
-DEFINE_XEN_GUEST_HANDLE(gnttab_unmap_and_replace_t);
-
-#if __XEN_INTERFACE_VERSION__ >= 0x0003020a
-/*
- * GNTTABOP_set_version: Request a particular version of the grant
- * table shared table structure.  This operation can only be performed
- * once in any given domain.  It must be performed before any grants
- * are activated; otherwise, the domain will be stuck with version 1.
- * The only defined versions are 1 and 2.
- */
-struct gnttab_set_version {
-    /* IN/OUT parameters */
-    uint32_t version;
-};
-typedef struct gnttab_set_version gnttab_set_version_t;
-DEFINE_XEN_GUEST_HANDLE(gnttab_set_version_t);
-
-
-/*
- * GNTTABOP_get_status_frames: Get the list of frames used to store grant
- * status for <dom>. In grant format version 2, the status is separated
- * from the other shared grant fields to allow more efficient synchronization
- * using barriers instead of atomic cmpexch operations.
- * <nr_frames> specify the size of vector <frame_list>.
- * The frame addresses are returned in the <frame_list>.
- * Only <nr_frames> addresses are returned, even if the table is larger.
- * NOTES:
- *  1. <dom> may be specified as DOMID_SELF.
- *  2. Only a sufficiently-privileged domain may specify <dom> != DOMID_SELF.
- */
-struct gnttab_get_status_frames {
-    /* IN parameters. */
-    uint32_t nr_frames;
-    domid_t  dom;
-    /* OUT parameters. */
-    int16_t  status;              /* => enum grant_status */
-    XEN_GUEST_HANDLE(uint64_t) frame_list;
-};
-typedef struct gnttab_get_status_frames gnttab_get_status_frames_t;
-DEFINE_XEN_GUEST_HANDLE(gnttab_get_status_frames_t);
-
-/*
- * GNTTABOP_get_version: Get the grant table version which is in
- * effect for domain <dom>.
- */
-struct gnttab_get_version {
-    /* IN parameters */
-    domid_t dom;
-    uint16_t pad;
-    /* OUT parameters */
-    uint32_t version;
-};
-typedef struct gnttab_get_version gnttab_get_version_t;
-DEFINE_XEN_GUEST_HANDLE(gnttab_get_version_t);
-
-/*
- * GNTTABOP_swap_grant_ref: Swap the contents of two grant entries.
- */
-struct gnttab_swap_grant_ref {
-    /* IN parameters */
-    grant_ref_t ref_a;
-    grant_ref_t ref_b;
-    /* OUT parameters */
-    int16_t status;             /* => enum grant_status */
-};
-typedef struct gnttab_swap_grant_ref gnttab_swap_grant_ref_t;
-DEFINE_XEN_GUEST_HANDLE(gnttab_swap_grant_ref_t);
-
-#endif /* __XEN_INTERFACE_VERSION__ */
-
-/*
- * Bitfield values for gnttab_map_grant_ref.flags.
- */
- /* Map the grant entry for access by I/O devices. */
-#define _GNTMAP_device_map      (0)
-#define GNTMAP_device_map       (1<<_GNTMAP_device_map)
- /* Map the grant entry for access by host CPUs. */
-#define _GNTMAP_host_map        (1)
-#define GNTMAP_host_map         (1<<_GNTMAP_host_map)
- /* Accesses to the granted frame will be restricted to read-only access. */
-#define _GNTMAP_readonly        (2)
-#define GNTMAP_readonly         (1<<_GNTMAP_readonly)
- /*
-  * GNTMAP_host_map subflag:
-  *  0 => The host mapping is usable only by the guest OS.
-  *  1 => The host mapping is usable by guest OS + current application.
-  */
-#define _GNTMAP_application_map (3)
-#define GNTMAP_application_map  (1<<_GNTMAP_application_map)
-
- /*
-  * GNTMAP_contains_pte subflag:
-  *  0 => This map request contains a host virtual address.
-  *  1 => This map request contains the machine addess of the PTE to update.
-  */
-#define _GNTMAP_contains_pte    (4)
-#define GNTMAP_contains_pte     (1<<_GNTMAP_contains_pte)
-
-#define _GNTMAP_can_fail        (5)
-#define GNTMAP_can_fail         (1<<_GNTMAP_can_fail)
-
-/*
- * Bits to be placed in guest kernel available PTE bits (architecture
- * dependent; only supported when XENFEAT_gnttab_map_avail_bits is set).
- */
-#define _GNTMAP_guest_avail0    (16)
-#define GNTMAP_guest_avail_mask ((uint32_t)~0 << _GNTMAP_guest_avail0)
-
-/*
- * Values for error status returns. All errors are -ve.
- */
-/* ` enum grant_status { */
-#define GNTST_okay             (0)  /* Normal return.                        */
-#define GNTST_general_error    (-1) /* General undefined error.              */
-#define GNTST_bad_domain       (-2) /* Unrecognsed domain id.                */
-#define GNTST_bad_gntref       (-3) /* Unrecognised or inappropriate gntref. */
-#define GNTST_bad_handle       (-4) /* Unrecognised or inappropriate handle. */
-#define GNTST_bad_virt_addr    (-5) /* Inappropriate virtual address to map. */
-#define GNTST_bad_dev_addr     (-6) /* Inappropriate device address to unmap.*/
-#define GNTST_no_device_space  (-7) /* Out of space in I/O MMU.              */
-#define GNTST_permission_denied (-8) /* Not enough privilege for operation.  */
-#define GNTST_bad_page         (-9) /* Specified page was invalid for op.    */
-#define GNTST_bad_copy_arg    (-10) /* copy arguments cross page boundary.   */
-#define GNTST_address_too_big (-11) /* transfer page address too large.      */
-#define GNTST_eagain          (-12) /* Operation not done; try again.        */
-/* ` } */
-
-#define GNTTABOP_error_msgs {                   \
-    "okay",                                     \
-    "undefined error",                          \
-    "unrecognised domain id",                   \
-    "invalid grant reference",                  \
-    "invalid mapping handle",                   \
-    "invalid virtual address",                  \
-    "invalid device address",                   \
-    "no spare translation slot in the I/O MMU", \
-    "permission denied",                        \
-    "bad page",                                 \
-    "copy arguments cross page boundary",       \
-    "page address size too large",              \
-    "operation not done; try again"             \
-}
-
-#endif /* __XEN_PUBLIC_GRANT_TABLE_H__ */
-
-/*
- * Local variables:
- * mode: C
- * c-set-style: "BSD"
- * c-basic-offset: 4
- * tab-width: 4
- * indent-tabs-mode: nil
- * End:
- */
diff -Nru xen-4.2.1-new/extras/mini-os/include/xen/hvm/e820.h xen-4.2.1/extras/mini-os/include/xen/hvm/e820.h
--- xen-4.2.1-new/extras/mini-os/include/xen/hvm/e820.h	2012-12-17 23:01:56.000000000 +0800
+++ xen-4.2.1/extras/mini-os/include/xen/hvm/e820.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,34 +0,0 @@
-
-/*
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- */
-
-#ifndef __XEN_PUBLIC_HVM_E820_H__
-#define __XEN_PUBLIC_HVM_E820_H__
-
-/* E820 location in HVM virtual address space. */
-#define HVM_E820_PAGE        0x00090000
-#define HVM_E820_NR_OFFSET   0x000001E8
-#define HVM_E820_OFFSET      0x000002D0
-
-#define HVM_BELOW_4G_RAM_END        0xF0000000
-#define HVM_BELOW_4G_MMIO_START     HVM_BELOW_4G_RAM_END
-#define HVM_BELOW_4G_MMIO_LENGTH    ((1ULL << 32) - HVM_BELOW_4G_MMIO_START)
-
-#endif /* __XEN_PUBLIC_HVM_E820_H__ */
diff -Nru xen-4.2.1-new/extras/mini-os/include/xen/hvm/hvm_info_table.h xen-4.2.1/extras/mini-os/include/xen/hvm/hvm_info_table.h
--- xen-4.2.1-new/extras/mini-os/include/xen/hvm/hvm_info_table.h	2012-12-17 23:01:56.000000000 +0800
+++ xen-4.2.1/extras/mini-os/include/xen/hvm/hvm_info_table.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,72 +0,0 @@
-/******************************************************************************
- * hvm/hvm_info_table.h
- * 
- * HVM parameter and information table, written into guest memory map.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- */
-
-#ifndef __XEN_PUBLIC_HVM_HVM_INFO_TABLE_H__
-#define __XEN_PUBLIC_HVM_HVM_INFO_TABLE_H__
-
-#define HVM_INFO_PFN         0x09F
-#define HVM_INFO_OFFSET      0x800
-#define HVM_INFO_PADDR       ((HVM_INFO_PFN << 12) + HVM_INFO_OFFSET)
-
-/* Maximum we can support with current vLAPIC ID mapping. */
-#define HVM_MAX_VCPUS        128
-
-struct hvm_info_table {
-    char        signature[8]; /* "HVM INFO" */
-    uint32_t    length;
-    uint8_t     checksum;
-
-    /* Should firmware build APIC descriptors (APIC MADT / MP BIOS)? */
-    uint8_t     apic_mode;
-
-    /* How many CPUs does this domain have? */
-    uint32_t    nr_vcpus;
-
-    /*
-     * MEMORY MAP provided by HVM domain builder.
-     * Notes:
-     *  1. page_to_phys(x) = x << 12
-     *  2. If a field is zero, the corresponding range does not exist.
-     */
-    /*
-     *  0x0 to page_to_phys(low_mem_pgend)-1:
-     *    RAM below 4GB (except for VGA hole 0xA0000-0xBFFFF)
-     */
-    uint32_t    low_mem_pgend;
-    /*
-     *  page_to_phys(reserved_mem_pgstart) to 0xFFFFFFFF:
-     *    Reserved for special memory mappings
-     */
-    uint32_t    reserved_mem_pgstart;
-    /*
-     *  0x100000000 to page_to_phys(high_mem_pgend)-1:
-     *    RAM above 4GB
-     */
-    uint32_t    high_mem_pgend;
-
-    /* Bitmap of which CPUs are online at boot time. */
-    uint8_t     vcpu_online[(HVM_MAX_VCPUS + 7)/8];
-};
-
-#endif /* __XEN_PUBLIC_HVM_HVM_INFO_TABLE_H__ */
diff -Nru xen-4.2.1-new/extras/mini-os/include/xen/hvm/hvm_op.h xen-4.2.1/extras/mini-os/include/xen/hvm/hvm_op.h
--- xen-4.2.1-new/extras/mini-os/include/xen/hvm/hvm_op.h	2012-12-17 23:01:56.000000000 +0800
+++ xen-4.2.1/extras/mini-os/include/xen/hvm/hvm_op.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,275 +0,0 @@
-/*
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- */
-
-#ifndef __XEN_PUBLIC_HVM_HVM_OP_H__
-#define __XEN_PUBLIC_HVM_HVM_OP_H__
-
-#include "../xen.h"
-#include "../trace.h"
-
-/* Get/set subcommands: extra argument == pointer to xen_hvm_param struct. */
-#define HVMOP_set_param           0
-#define HVMOP_get_param           1
-struct xen_hvm_param {
-    domid_t  domid;    /* IN */
-    uint32_t index;    /* IN */
-    uint64_t value;    /* IN/OUT */
-};
-typedef struct xen_hvm_param xen_hvm_param_t;
-DEFINE_XEN_GUEST_HANDLE(xen_hvm_param_t);
-
-/* Set the logical level of one of a domain's PCI INTx wires. */
-#define HVMOP_set_pci_intx_level  2
-struct xen_hvm_set_pci_intx_level {
-    /* Domain to be updated. */
-    domid_t  domid;
-    /* PCI INTx identification in PCI topology (domain:bus:device:intx). */
-    uint8_t  domain, bus, device, intx;
-    /* Assertion level (0 = unasserted, 1 = asserted). */
-    uint8_t  level;
-};
-typedef struct xen_hvm_set_pci_intx_level xen_hvm_set_pci_intx_level_t;
-DEFINE_XEN_GUEST_HANDLE(xen_hvm_set_pci_intx_level_t);
-
-/* Set the logical level of one of a domain's ISA IRQ wires. */
-#define HVMOP_set_isa_irq_level   3
-struct xen_hvm_set_isa_irq_level {
-    /* Domain to be updated. */
-    domid_t  domid;
-    /* ISA device identification, by ISA IRQ (0-15). */
-    uint8_t  isa_irq;
-    /* Assertion level (0 = unasserted, 1 = asserted). */
-    uint8_t  level;
-};
-typedef struct xen_hvm_set_isa_irq_level xen_hvm_set_isa_irq_level_t;
-DEFINE_XEN_GUEST_HANDLE(xen_hvm_set_isa_irq_level_t);
-
-#define HVMOP_set_pci_link_route  4
-struct xen_hvm_set_pci_link_route {
-    /* Domain to be updated. */
-    domid_t  domid;
-    /* PCI link identifier (0-3). */
-    uint8_t  link;
-    /* ISA IRQ (1-15), or 0 (disable link). */
-    uint8_t  isa_irq;
-};
-typedef struct xen_hvm_set_pci_link_route xen_hvm_set_pci_link_route_t;
-DEFINE_XEN_GUEST_HANDLE(xen_hvm_set_pci_link_route_t);
-
-/* Flushes all VCPU TLBs: @arg must be NULL. */
-#define HVMOP_flush_tlbs          5
-
-typedef enum {
-    HVMMEM_ram_rw,             /* Normal read/write guest RAM */
-    HVMMEM_ram_ro,             /* Read-only; writes are discarded */
-    HVMMEM_mmio_dm,            /* Reads and write go to the device model */
-} hvmmem_type_t;
-
-/* Following tools-only interfaces may change in future. */
-#if defined(__XEN__) || defined(__XEN_TOOLS__)
-
-/* Track dirty VRAM. */
-#define HVMOP_track_dirty_vram    6
-struct xen_hvm_track_dirty_vram {
-    /* Domain to be tracked. */
-    domid_t  domid;
-    /* First pfn to track. */
-    uint64_aligned_t first_pfn;
-    /* Number of pages to track. */
-    uint64_aligned_t nr;
-    /* OUT variable. */
-    /* Dirty bitmap buffer. */
-    XEN_GUEST_HANDLE_64(uint8) dirty_bitmap;
-};
-typedef struct xen_hvm_track_dirty_vram xen_hvm_track_dirty_vram_t;
-DEFINE_XEN_GUEST_HANDLE(xen_hvm_track_dirty_vram_t);
-
-/* Notify that some pages got modified by the Device Model. */
-#define HVMOP_modified_memory    7
-struct xen_hvm_modified_memory {
-    /* Domain to be updated. */
-    domid_t  domid;
-    /* First pfn. */
-    uint64_aligned_t first_pfn;
-    /* Number of pages. */
-    uint64_aligned_t nr;
-};
-typedef struct xen_hvm_modified_memory xen_hvm_modified_memory_t;
-DEFINE_XEN_GUEST_HANDLE(xen_hvm_modified_memory_t);
-
-#define HVMOP_set_mem_type    8
-/* Notify that a region of memory is to be treated in a specific way. */
-struct xen_hvm_set_mem_type {
-    /* Domain to be updated. */
-    domid_t domid;
-    /* Memory type */
-    uint16_t hvmmem_type;
-    /* Number of pages. */
-    uint32_t nr;
-    /* First pfn. */
-    uint64_aligned_t first_pfn;
-};
-typedef struct xen_hvm_set_mem_type xen_hvm_set_mem_type_t;
-DEFINE_XEN_GUEST_HANDLE(xen_hvm_set_mem_type_t);
-
-#endif /* defined(__XEN__) || defined(__XEN_TOOLS__) */
-
-/* Hint from PV drivers for pagetable destruction. */
-#define HVMOP_pagetable_dying        9
-struct xen_hvm_pagetable_dying {
-    /* Domain with a pagetable about to be destroyed. */
-    domid_t  domid;
-    uint16_t pad[3]; /* align next field on 8-byte boundary */
-    /* guest physical address of the toplevel pagetable dying */
-    uint64_t gpa;
-};
-typedef struct xen_hvm_pagetable_dying xen_hvm_pagetable_dying_t;
-DEFINE_XEN_GUEST_HANDLE(xen_hvm_pagetable_dying_t);
-
-/* Get the current Xen time, in nanoseconds since system boot. */
-#define HVMOP_get_time              10
-struct xen_hvm_get_time {
-    uint64_t now;      /* OUT */
-};
-typedef struct xen_hvm_get_time xen_hvm_get_time_t;
-DEFINE_XEN_GUEST_HANDLE(xen_hvm_get_time_t);
-
-#define HVMOP_xentrace              11
-struct xen_hvm_xentrace {
-    uint16_t event, extra_bytes;
-    uint8_t extra[TRACE_EXTRA_MAX * sizeof(uint32_t)];
-};
-typedef struct xen_hvm_xentrace xen_hvm_xentrace_t;
-DEFINE_XEN_GUEST_HANDLE(xen_hvm_xentrace_t);
-
-/* Following tools-only interfaces may change in future. */
-#if defined(__XEN__) || defined(__XEN_TOOLS__)
-
-#define HVMOP_set_mem_access        12
-typedef enum {
-    HVMMEM_access_n,
-    HVMMEM_access_r,
-    HVMMEM_access_w,
-    HVMMEM_access_rw,
-    HVMMEM_access_x,
-    HVMMEM_access_rx,
-    HVMMEM_access_wx,
-    HVMMEM_access_rwx,
-    HVMMEM_access_rx2rw,       /* Page starts off as r-x, but automatically
-                                * change to r-w on a write */
-    HVMMEM_access_n2rwx,       /* Log access: starts off as n, automatically 
-                                * goes to rwx, generating an event without
-                                * pausing the vcpu */
-    HVMMEM_access_default      /* Take the domain default */
-} hvmmem_access_t;
-/* Notify that a region of memory is to have specific access types */
-struct xen_hvm_set_mem_access {
-    /* Domain to be updated. */
-    domid_t domid;
-    /* Memory type */
-    uint16_t hvmmem_access; /* hvm_access_t */
-    /* Number of pages, ignored on setting default access */
-    uint32_t nr;
-    /* First pfn, or ~0ull to set the default access for new pages */
-    uint64_aligned_t first_pfn;
-};
-typedef struct xen_hvm_set_mem_access xen_hvm_set_mem_access_t;
-DEFINE_XEN_GUEST_HANDLE(xen_hvm_set_mem_access_t);
-
-#define HVMOP_get_mem_access        13
-/* Get the specific access type for that region of memory */
-struct xen_hvm_get_mem_access {
-    /* Domain to be queried. */
-    domid_t domid;
-    /* Memory type: OUT */
-    uint16_t hvmmem_access; /* hvm_access_t */
-    /* pfn, or ~0ull for default access for new pages.  IN */
-    uint64_aligned_t pfn;
-};
-typedef struct xen_hvm_get_mem_access xen_hvm_get_mem_access_t;
-DEFINE_XEN_GUEST_HANDLE(xen_hvm_get_mem_access_t);
-
-#define HVMOP_inject_trap            14
-/* Inject a trap into a VCPU, which will get taken up on the next
- * scheduling of it. Note that the caller should know enough of the
- * state of the CPU before injecting, to know what the effect of
- * injecting the trap will be.
- */
-struct xen_hvm_inject_trap {
-    /* Domain to be queried. */
-    domid_t domid;
-    /* VCPU */
-    uint32_t vcpuid;
-    /* Vector number */
-    uint32_t vector;
-    /* Trap type (HVMOP_TRAP_*) */
-    uint32_t type;
-/* NB. This enumeration precisely matches hvm.h:X86_EVENTTYPE_* */
-# define HVMOP_TRAP_ext_int    0 /* external interrupt */
-# define HVMOP_TRAP_nmi        2 /* nmi */
-# define HVMOP_TRAP_hw_exc     3 /* hardware exception */
-# define HVMOP_TRAP_sw_int     4 /* software interrupt (CD nn) */
-# define HVMOP_TRAP_pri_sw_exc 5 /* ICEBP (F1) */
-# define HVMOP_TRAP_sw_exc     6 /* INT3 (CC), INTO (CE) */
-    /* Error code, or ~0u to skip */
-    uint32_t error_code;
-    /* Intruction length */
-    uint32_t insn_len;
-    /* CR2 for page faults */
-    uint64_aligned_t cr2;
-};
-typedef struct xen_hvm_inject_trap xen_hvm_inject_trap_t;
-DEFINE_XEN_GUEST_HANDLE(xen_hvm_inject_trap_t);
-
-#endif /* defined(__XEN__) || defined(__XEN_TOOLS__) */
-
-#define HVMOP_get_mem_type    15
-/* Return hvmmem_type_t for the specified pfn. */
-struct xen_hvm_get_mem_type {
-    /* Domain to be queried. */
-    domid_t domid;
-    /* OUT variable. */
-    uint16_t mem_type;
-    uint16_t pad[2]; /* align next field on 8-byte boundary */
-    /* IN variable. */
-    uint64_t pfn;
-};
-typedef struct xen_hvm_get_mem_type xen_hvm_get_mem_type_t;
-DEFINE_XEN_GUEST_HANDLE(xen_hvm_get_mem_type_t);
-
-/* Following tools-only interfaces may change in future. */
-#if defined(__XEN__) || defined(__XEN_TOOLS__)
-
-/* MSI injection for emulated devices */
-#define HVMOP_inject_msi         16
-struct xen_hvm_inject_msi {
-    /* Domain to be injected */
-    domid_t   domid;
-    /* Data -- lower 32 bits */
-    uint32_t  data;
-    /* Address (0xfeexxxxx) */
-    uint64_t  addr;
-};
-typedef struct xen_hvm_inject_msi xen_hvm_inject_msi_t;
-DEFINE_XEN_GUEST_HANDLE(xen_hvm_inject_msi_t);
-
-#endif /* defined(__XEN__) || defined(__XEN_TOOLS__) */
-
-#endif /* __XEN_PUBLIC_HVM_HVM_OP_H__ */
diff -Nru xen-4.2.1-new/extras/mini-os/include/xen/hvm/ioreq.h xen-4.2.1/extras/mini-os/include/xen/hvm/ioreq.h
--- xen-4.2.1-new/extras/mini-os/include/xen/hvm/ioreq.h	2012-12-17 23:01:56.000000000 +0800
+++ xen-4.2.1/extras/mini-os/include/xen/hvm/ioreq.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,140 +0,0 @@
-/*
- * ioreq.h: I/O request definitions for device models
- * Copyright (c) 2004, Intel Corporation.
- * 
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- */
-
-#ifndef _IOREQ_H_
-#define _IOREQ_H_
-
-#define IOREQ_READ      1
-#define IOREQ_WRITE     0
-
-#define STATE_IOREQ_NONE        0
-#define STATE_IOREQ_READY       1
-#define STATE_IOREQ_INPROCESS   2
-#define STATE_IORESP_READY      3
-
-#define IOREQ_TYPE_PIO          0 /* pio */
-#define IOREQ_TYPE_COPY         1 /* mmio ops */
-#define IOREQ_TYPE_TIMEOFFSET   7
-#define IOREQ_TYPE_INVALIDATE   8 /* mapcache */
-
-/*
- * VMExit dispatcher should cooperate with instruction decoder to
- * prepare this structure and notify service OS and DM by sending
- * virq
- */
-struct ioreq {
-    uint64_t addr;          /* physical address */
-    uint64_t data;          /* data (or paddr of data) */
-    uint32_t count;         /* for rep prefixes */
-    uint32_t size;          /* size in bytes */
-    uint32_t vp_eport;      /* evtchn for notifications to/from device model */
-    uint16_t _pad0;
-    uint8_t state:4;
-    uint8_t data_is_ptr:1;  /* if 1, data above is the guest paddr 
-                             * of the real data to use. */
-    uint8_t dir:1;          /* 1=read, 0=write */
-    uint8_t df:1;
-    uint8_t _pad1:1;
-    uint8_t type;           /* I/O type */
-};
-typedef struct ioreq ioreq_t;
-
-struct shared_iopage {
-    struct ioreq vcpu_ioreq[1];
-};
-typedef struct shared_iopage shared_iopage_t;
-
-struct buf_ioreq {
-    uint8_t  type;   /* I/O type                    */
-    uint8_t  pad:1;
-    uint8_t  dir:1;  /* 1=read, 0=write             */
-    uint8_t  size:2; /* 0=>1, 1=>2, 2=>4, 3=>8. If 8, use two buf_ioreqs */
-    uint32_t addr:20;/* physical address            */
-    uint32_t data;   /* data                        */
-};
-typedef struct buf_ioreq buf_ioreq_t;
-
-#define IOREQ_BUFFER_SLOT_NUM     511 /* 8 bytes each, plus 2 4-byte indexes */
-struct buffered_iopage {
-    unsigned int read_pointer;
-    unsigned int write_pointer;
-    buf_ioreq_t buf_ioreq[IOREQ_BUFFER_SLOT_NUM];
-}; /* NB. Size of this structure must be no greater than one page. */
-typedef struct buffered_iopage buffered_iopage_t;
-
-#if defined(__ia64__)
-struct pio_buffer {
-    uint32_t page_offset;
-    uint32_t pointer;
-    uint32_t data_end;
-    uint32_t buf_size;
-    void *opaque;
-};
-
-#define PIO_BUFFER_IDE_PRIMARY   0 /* I/O port = 0x1F0 */
-#define PIO_BUFFER_IDE_SECONDARY 1 /* I/O port = 0x170 */
-#define PIO_BUFFER_ENTRY_NUM     2
-struct buffered_piopage {
-    struct pio_buffer pio[PIO_BUFFER_ENTRY_NUM];
-    uint8_t buffer[1];
-};
-#endif /* defined(__ia64__) */
-
-/*
- * ACPI Control/Event register locations. Location is controlled by a 
- * version number in HVM_PARAM_ACPI_IOPORTS_LOCATION.
- */
-
-/* Version 0 (default): Traditional Xen locations. */
-#define ACPI_PM1A_EVT_BLK_ADDRESS_V0 0x1f40
-#define ACPI_PM1A_CNT_BLK_ADDRESS_V0 (ACPI_PM1A_EVT_BLK_ADDRESS_V0 + 0x04)
-#define ACPI_PM_TMR_BLK_ADDRESS_V0   (ACPI_PM1A_EVT_BLK_ADDRESS_V0 + 0x08)
-#define ACPI_GPE0_BLK_ADDRESS_V0     (ACPI_PM_TMR_BLK_ADDRESS_V0 + 0x20)
-#define ACPI_GPE0_BLK_LEN_V0         0x08
-
-/* Version 1: Locations preferred by modern Qemu. */
-#define ACPI_PM1A_EVT_BLK_ADDRESS_V1 0xb000
-#define ACPI_PM1A_CNT_BLK_ADDRESS_V1 (ACPI_PM1A_EVT_BLK_ADDRESS_V1 + 0x04)
-#define ACPI_PM_TMR_BLK_ADDRESS_V1   (ACPI_PM1A_EVT_BLK_ADDRESS_V1 + 0x08)
-#define ACPI_GPE0_BLK_ADDRESS_V1     0xafe0
-#define ACPI_GPE0_BLK_LEN_V1         0x04
-
-/* Compatibility definitions for the default location (version 0). */
-#define ACPI_PM1A_EVT_BLK_ADDRESS    ACPI_PM1A_EVT_BLK_ADDRESS_V0
-#define ACPI_PM1A_CNT_BLK_ADDRESS    ACPI_PM1A_CNT_BLK_ADDRESS_V0
-#define ACPI_PM_TMR_BLK_ADDRESS      ACPI_PM_TMR_BLK_ADDRESS_V0
-#define ACPI_GPE0_BLK_ADDRESS        ACPI_GPE0_BLK_ADDRESS_V0
-#define ACPI_GPE0_BLK_LEN            ACPI_GPE0_BLK_LEN_V0
-
-
-#endif /* _IOREQ_H_ */
-
-/*
- * Local variables:
- * mode: C
- * c-set-style: "BSD"
- * c-basic-offset: 4
- * tab-width: 4
- * indent-tabs-mode: nil
- * End:
- */
diff -Nru xen-4.2.1-new/extras/mini-os/include/xen/hvm/params.h xen-4.2.1/extras/mini-os/include/xen/hvm/params.h
--- xen-4.2.1-new/extras/mini-os/include/xen/hvm/params.h	2012-12-17 23:01:56.000000000 +0800
+++ xen-4.2.1/extras/mini-os/include/xen/hvm/params.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,152 +0,0 @@
-/*
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- */
-
-#ifndef __XEN_PUBLIC_HVM_PARAMS_H__
-#define __XEN_PUBLIC_HVM_PARAMS_H__
-
-#include "hvm_op.h"
-
-/*
- * Parameter space for HVMOP_{set,get}_param.
- */
-
-/*
- * How should CPU0 event-channel notifications be delivered?
- * val[63:56] == 0: val[55:0] is a delivery GSI (Global System Interrupt).
- * val[63:56] == 1: val[55:0] is a delivery PCI INTx line, as follows:
- *                  Domain = val[47:32], Bus  = val[31:16],
- *                  DevFn  = val[15: 8], IntX = val[ 1: 0]
- * val[63:56] == 2: val[7:0] is a vector number, check for
- *                  XENFEAT_hvm_callback_vector to know if this delivery
- *                  method is available.
- * If val == 0 then CPU0 event-channel notifications are not delivered.
- */
-#define HVM_PARAM_CALLBACK_IRQ 0
-
-/*
- * These are not used by Xen. They are here for convenience of HVM-guest
- * xenbus implementations.
- */
-#define HVM_PARAM_STORE_PFN    1
-#define HVM_PARAM_STORE_EVTCHN 2
-
-#define HVM_PARAM_PAE_ENABLED  4
-
-#define HVM_PARAM_IOREQ_PFN    5
-
-#define HVM_PARAM_BUFIOREQ_PFN 6
-#define HVM_PARAM_BUFIOREQ_EVTCHN 26
-
-#ifdef __ia64__
-
-#define HVM_PARAM_NVRAM_FD     7
-#define HVM_PARAM_VHPT_SIZE    8
-#define HVM_PARAM_BUFPIOREQ_PFN	9
-
-#elif defined(__i386__) || defined(__x86_64__)
-
-/* Expose Viridian interfaces to this HVM guest? */
-#define HVM_PARAM_VIRIDIAN     9
-
-#endif
-
-/*
- * Set mode for virtual timers (currently x86 only):
- *  delay_for_missed_ticks (default):
- *   Do not advance a vcpu's time beyond the correct delivery time for
- *   interrupts that have been missed due to preemption. Deliver missed
- *   interrupts when the vcpu is rescheduled and advance the vcpu's virtual
- *   time stepwise for each one.
- *  no_delay_for_missed_ticks:
- *   As above, missed interrupts are delivered, but guest time always tracks
- *   wallclock (i.e., real) time while doing so.
- *  no_missed_ticks_pending:
- *   No missed interrupts are held pending. Instead, to ensure ticks are
- *   delivered at some non-zero rate, if we detect missed ticks then the
- *   internal tick alarm is not disabled if the VCPU is preempted during the
- *   next tick period.
- *  one_missed_tick_pending:
- *   Missed interrupts are collapsed together and delivered as one 'late tick'.
- *   Guest time always tracks wallclock (i.e., real) time.
- */
-#define HVM_PARAM_TIMER_MODE   10
-#define HVMPTM_delay_for_missed_ticks    0
-#define HVMPTM_no_delay_for_missed_ticks 1
-#define HVMPTM_no_missed_ticks_pending   2
-#define HVMPTM_one_missed_tick_pending   3
-
-/* Boolean: Enable virtual HPET (high-precision event timer)? (x86-only) */
-#define HVM_PARAM_HPET_ENABLED 11
-
-/* Identity-map page directory used by Intel EPT when CR0.PG=0. */
-#define HVM_PARAM_IDENT_PT     12
-
-/* Device Model domain, defaults to 0. */
-#define HVM_PARAM_DM_DOMAIN    13
-
-/* ACPI S state: currently support S0 and S3 on x86. */
-#define HVM_PARAM_ACPI_S_STATE 14
-
-/* TSS used on Intel when CR0.PE=0. */
-#define HVM_PARAM_VM86_TSS     15
-
-/* Boolean: Enable aligning all periodic vpts to reduce interrupts */
-#define HVM_PARAM_VPT_ALIGN    16
-
-/* Console debug shared memory ring and event channel */
-#define HVM_PARAM_CONSOLE_PFN    17
-#define HVM_PARAM_CONSOLE_EVTCHN 18
-
-/*
- * Select location of ACPI PM1a and TMR control blocks. Currently two locations
- * are supported, specified by version 0 or 1 in this parameter:
- *   - 0: default, use the old addresses
- *        PM1A_EVT == 0x1f40; PM1A_CNT == 0x1f44; PM_TMR == 0x1f48
- *   - 1: use the new default qemu addresses
- *        PM1A_EVT == 0xb000; PM1A_CNT == 0xb004; PM_TMR == 0xb008
- * You can find these address definitions in <hvm/ioreq.h>
- */
-#define HVM_PARAM_ACPI_IOPORTS_LOCATION 19
-
-/* Enable blocking memory events, async or sync (pause vcpu until response) 
- * onchangeonly indicates messages only on a change of value */
-#define HVM_PARAM_MEMORY_EVENT_CR0          20
-#define HVM_PARAM_MEMORY_EVENT_CR3          21
-#define HVM_PARAM_MEMORY_EVENT_CR4          22
-#define HVM_PARAM_MEMORY_EVENT_INT3         23
-#define HVM_PARAM_MEMORY_EVENT_SINGLE_STEP  25
-
-#define HVMPME_MODE_MASK       (3 << 0)
-#define HVMPME_mode_disabled   0
-#define HVMPME_mode_async      1
-#define HVMPME_mode_sync       2
-#define HVMPME_onchangeonly    (1 << 2)
-
-/* Boolean: Enable nestedhvm (hvm only) */
-#define HVM_PARAM_NESTEDHVM    24
-
-/* Params for the mem event rings */
-#define HVM_PARAM_PAGING_RING_PFN   27
-#define HVM_PARAM_ACCESS_RING_PFN   28
-#define HVM_PARAM_SHARING_RING_PFN  29
-
-#define HVM_NR_PARAMS          30
-
-#endif /* __XEN_PUBLIC_HVM_PARAMS_H__ */
diff -Nru xen-4.2.1-new/extras/mini-os/include/xen/hvm/save.h xen-4.2.1/extras/mini-os/include/xen/hvm/save.h
--- xen-4.2.1-new/extras/mini-os/include/xen/hvm/save.h	2012-12-17 23:01:56.000000000 +0800
+++ xen-4.2.1/extras/mini-os/include/xen/hvm/save.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,113 +0,0 @@
-/* 
- * hvm/save.h
- *
- * Structure definitions for HVM state that is held by Xen and must
- * be saved along with the domain's memory and device-model state.
- * 
- * Copyright (c) 2007 XenSource Ltd.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- */
-
-#ifndef __XEN_PUBLIC_HVM_SAVE_H__
-#define __XEN_PUBLIC_HVM_SAVE_H__
-
-/*
- * Structures in this header *must* have the same layout in 32bit 
- * and 64bit environments: this means that all fields must be explicitly 
- * sized types and aligned to their sizes, and the structs must be 
- * a multiple of eight bytes long.
- *
- * Only the state necessary for saving and restoring (i.e. fields 
- * that are analogous to actual hardware state) should go in this file. 
- * Internal mechanisms should be kept in Xen-private headers.
- */
-
-#if !defined(__GNUC__) || defined(__STRICT_ANSI__)
-#error "Anonymous structs/unions are a GNU extension."
-#endif
-
-/* 
- * Each entry is preceded by a descriptor giving its type and length
- */
-struct hvm_save_descriptor {
-    uint16_t typecode;          /* Used to demux the various types below */
-    uint16_t instance;          /* Further demux within a type */
-    uint32_t length;            /* In bytes, *not* including this descriptor */
-};
-
-
-/* 
- * Each entry has a datatype associated with it: for example, the CPU state 
- * is saved as a HVM_SAVE_TYPE(CPU), which has HVM_SAVE_LENGTH(CPU), 
- * and is identified by a descriptor with typecode HVM_SAVE_CODE(CPU).
- * DECLARE_HVM_SAVE_TYPE binds these things together with some type-system
- * ugliness.
- */
-
-#ifdef __XEN__
-# define DECLARE_HVM_SAVE_TYPE_COMPAT(_x, _code, _type, _ctype, _fix)     \
-    static inline int __HVM_SAVE_FIX_COMPAT_##_x(void *h) { return _fix(h); } \
-    struct __HVM_SAVE_TYPE_##_x { _type t; char c[_code]; char cpt[2];}; \
-    struct __HVM_SAVE_TYPE_COMPAT_##_x { _ctype t; }                   
-
-# include <xen/lib.h> /* BUG() */
-# define DECLARE_HVM_SAVE_TYPE(_x, _code, _type)                         \
-    static inline int __HVM_SAVE_FIX_COMPAT_##_x(void *h) { BUG(); return -1; } \
-    struct __HVM_SAVE_TYPE_##_x { _type t; char c[_code]; char cpt[1];}; \
-    struct __HVM_SAVE_TYPE_COMPAT_##_x { _type t; }                   
-#else
-# define DECLARE_HVM_SAVE_TYPE_COMPAT(_x, _code, _type, _ctype, _fix)     \
-    struct __HVM_SAVE_TYPE_##_x { _type t; char c[_code]; char cpt[2];} 
-
-# define DECLARE_HVM_SAVE_TYPE(_x, _code, _type)                         \
-    struct __HVM_SAVE_TYPE_##_x { _type t; char c[_code]; char cpt[1];} 
-#endif
-
-#define HVM_SAVE_TYPE(_x) typeof (((struct __HVM_SAVE_TYPE_##_x *)(0))->t)
-#define HVM_SAVE_LENGTH(_x) (sizeof (HVM_SAVE_TYPE(_x)))
-#define HVM_SAVE_CODE(_x) (sizeof (((struct __HVM_SAVE_TYPE_##_x *)(0))->c))
-
-#ifdef __XEN__
-# define HVM_SAVE_TYPE_COMPAT(_x) typeof (((struct __HVM_SAVE_TYPE_COMPAT_##_x *)(0))->t)
-# define HVM_SAVE_LENGTH_COMPAT(_x) (sizeof (HVM_SAVE_TYPE_COMPAT(_x)))
-
-# define HVM_SAVE_HAS_COMPAT(_x) (sizeof (((struct __HVM_SAVE_TYPE_##_x *)(0))->cpt)-1)
-# define HVM_SAVE_FIX_COMPAT(_x, _dst) __HVM_SAVE_FIX_COMPAT_##_x(_dst)
-#endif
-
-/* 
- * The series of save records is teminated by a zero-type, zero-length 
- * descriptor.
- */
-
-struct hvm_save_end {};
-DECLARE_HVM_SAVE_TYPE(END, 0, struct hvm_save_end);
-
-#if defined(__i386__) || defined(__x86_64__)
-#include "../arch-x86/hvm/save.h"
-#elif defined(__ia64__)
-#include "../arch-ia64/hvm/save.h"
-#elif defined(__arm__)
-#include "../arch-arm/hvm/save.h"
-#else
-#error "unsupported architecture"
-#endif
-
-#endif /* __XEN_PUBLIC_HVM_SAVE_H__ */
diff -Nru xen-4.2.1-new/extras/mini-os/include/xen/io/blkif.h xen-4.2.1/extras/mini-os/include/xen/io/blkif.h
--- xen-4.2.1-new/extras/mini-os/include/xen/io/blkif.h	2012-12-17 23:01:56.000000000 +0800
+++ xen-4.2.1/extras/mini-os/include/xen/io/blkif.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,490 +0,0 @@
-/******************************************************************************
- * blkif.h
- *
- * Unified block-device I/O interface for Xen guest OSes.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- * Copyright (c) 2003-2004, Keir Fraser
- * Copyright (c) 2012, Spectra Logic Corporation
- */
-
-#ifndef __XEN_PUBLIC_IO_BLKIF_H__
-#define __XEN_PUBLIC_IO_BLKIF_H__
-
-#include "ring.h"
-#include "../grant_table.h"
-
-/*
- * Front->back notifications: When enqueuing a new request, sending a
- * notification can be made conditional on req_event (i.e., the generic
- * hold-off mechanism provided by the ring macros). Backends must set
- * req_event appropriately (e.g., using RING_FINAL_CHECK_FOR_REQUESTS()).
- *
- * Back->front notifications: When enqueuing a new response, sending a
- * notification can be made conditional on rsp_event (i.e., the generic
- * hold-off mechanism provided by the ring macros). Frontends must set
- * rsp_event appropriately (e.g., using RING_FINAL_CHECK_FOR_RESPONSES()).
- */
-
-#ifndef blkif_vdev_t
-#define blkif_vdev_t   uint16_t
-#endif
-#define blkif_sector_t uint64_t
-
-/*
- * Feature and Parameter Negotiation
- * =================================
- * The two halves of a Xen block driver utilize nodes within the XenStore to
- * communicate capabilities and to negotiate operating parameters.  This
- * section enumerates these nodes which reside in the respective front and
- * backend portions of the XenStore, following the XenBus convention.
- *
- * All data in the XenStore is stored as strings.  Nodes specifying numeric
- * values are encoded in decimal.  Integer value ranges listed below are
- * expressed as fixed sized integer types capable of storing the conversion
- * of a properly formated node string, without loss of information.
- *
- * Any specified default value is in effect if the corresponding XenBus node
- * is not present in the XenStore.
- *
- * XenStore nodes in sections marked "PRIVATE" are solely for use by the
- * driver side whose XenBus tree contains them.
- *
- * XenStore nodes marked "DEPRECATED" in their notes section should only be
- * used to provide interoperability with legacy implementations.
- *
- * See the XenBus state transition diagram below for details on when XenBus
- * nodes must be published and when they can be queried.
- *
- *****************************************************************************
- *                            Backend XenBus Nodes
- *****************************************************************************
- *
- *------------------ Backend Device Identification (PRIVATE) ------------------
- *
- * mode
- *      Values:         "r" (read only), "w" (writable)
- *
- *      The read or write access permissions to the backing store to be
- *      granted to the frontend.
- *
- * params
- *      Values:         string
- *
- *      A free formatted string providing sufficient information for the
- *      backend driver to open the backing device.  (e.g. the path to the
- *      file or block device representing the backing store.)
- *
- * type
- *      Values:         "file", "phy", "tap"
- *
- *      The type of the backing device/object.
- *
- *--------------------------------- Features ---------------------------------
- *
- * feature-barrier
- *      Values:         0/1 (boolean)
- *      Default Value:  0
- *
- *      A value of "1" indicates that the backend can process requests
- *      containing the BLKIF_OP_WRITE_BARRIER request opcode.  Requests
- *      of this type may still be returned at any time with the
- *      BLKIF_RSP_EOPNOTSUPP result code.
- *
- * feature-flush-cache
- *      Values:         0/1 (boolean)
- *      Default Value:  0
- *
- *      A value of "1" indicates that the backend can process requests
- *      containing the BLKIF_OP_FLUSH_DISKCACHE request opcode.  Requests
- *      of this type may still be returned at any time with the
- *      BLKIF_RSP_EOPNOTSUPP result code.
- *
- * feature-discard
- *      Values:         0/1 (boolean)
- *      Default Value:  0
- *
- *      A value of "1" indicates that the backend can process requests
- *      containing the BLKIF_OP_DISCARD request opcode.  Requests
- *      of this type may still be returned at any time with the
- *      BLKIF_RSP_EOPNOTSUPP result code.
- *
- *----------------------- Request Transport Parameters ------------------------
- *
- * max-ring-page-order
- *      Values:         <uint32_t>
- *      Default Value:  0
- *      Notes:          1, 3
- *
- *      The maximum supported size of the request ring buffer in units of
- *      lb(machine pages). (e.g. 0 == 1 page,  1 = 2 pages, 2 == 4 pages,
- *      etc.).
- *
- * max-ring-pages
- *      Values:         <uint32_t>
- *      Default Value:  1
- *      Notes:          DEPRECATED, 2, 3
- *
- *      The maximum supported size of the request ring buffer in units of
- *      machine pages.  The value must be a power of 2.
- *
- *------------------------- Backend Device Properties -------------------------
- *
- * discard-aligment
- *      Values:         <uint32_t>
- *      Default Value:  0
- *      Notes:          4, 5
- *
- *      The offset, in bytes from the beginning of the virtual block device,
- *      to the first, addressable, discard extent on the underlying device.
- *
- * discard-granularity
- *      Values:         <uint32_t>
- *      Default Value:  <"sector-size">
- *      Notes:          4
- *
- *      The size, in bytes, of the individually addressable discard extents
- *      of the underlying device.
- *
- * discard-secure
- *      Values:         0/1 (boolean)
- *      Default Value:  0
- *
- *      A value of "1" indicates that the backend can process BLKIF_OP_DISCARD
- *      requests with the BLKIF_DISCARD_SECURE flag set.
- *
- * info
- *      Values:         <uint32_t> (bitmap)
- *
- *      A collection of bit flags describing attributes of the backing
- *      device.  The VDISK_* macros define the meaning of each bit
- *      location.
- *
- * sector-size
- *      Values:         <uint32_t>
- *
- *      The native sector size, in bytes, of the backend device.
- *
- * sectors
- *      Values:         <uint64_t>
- *
- *      The size of the backend device, expressed in units of its native
- *      sector size ("sector-size").
- *
- *****************************************************************************
- *                            Frontend XenBus Nodes
- *****************************************************************************
- *
- *----------------------- Request Transport Parameters -----------------------
- *
- * event-channel
- *      Values:         <uint32_t>
- *
- *      The identifier of the Xen event channel used to signal activity
- *      in the ring buffer.
- *
- * ring-ref
- *      Values:         <uint32_t>
- *      Notes:          6
- *
- *      The Xen grant reference granting permission for the backend to map
- *      the sole page in a single page sized ring buffer.
- *
- * ring-ref%u
- *      Values:         <uint32_t>
- *      Notes:          6
- *
- *      For a frontend providing a multi-page ring, a "number of ring pages"
- *      sized list of nodes, each containing a Xen grant reference granting
- *      permission for the backend to map the page of the ring located
- *      at page index "%u".  Page indexes are zero based.
- *
- * protocol
- *      Values:         string (XEN_IO_PROTO_ABI_*)
- *      Default Value:  XEN_IO_PROTO_ABI_NATIVE
- *
- *      The machine ABI rules governing the format of all ring request and
- *      response structures.
- *
- * ring-page-order
- *      Values:         <uint32_t>
- *      Default Value:  0
- *      Maximum Value:  MAX(ffs(max-ring-pages) - 1, max-ring-page-order)
- *      Notes:          1, 3
- *
- *      The size of the frontend allocated request ring buffer in units
- *      of lb(machine pages). (e.g. 0 == 1 page, 1 = 2 pages, 2 == 4 pages,
- *      etc.).
- *
- * num-ring-pages
- *      Values:         <uint32_t>
- *      Default Value:  1
- *      Maximum Value:  MAX(max-ring-pages,(0x1 << max-ring-page-order))
- *      Notes:          DEPRECATED, 2, 3
- *
- *      The size of the frontend allocated request ring buffer in units of
- *      machine pages.  The value must be a power of 2.
- *
- *------------------------- Virtual Device Properties -------------------------
- *
- * device-type
- *      Values:         "disk", "cdrom", "floppy", etc.
- *
- * virtual-device
- *      Values:         <uint32_t>
- *
- *      A value indicating the physical device to virtualize within the
- *      frontend's domain.  (e.g. "The first ATA disk", "The third SCSI
- *      disk", etc.)
- *
- *      See docs/misc/vbd-interface.txt for details on the format of this
- *      value.
- *
- * Notes
- * -----
- * (1) Multi-page ring buffer scheme first developed in the Citrix XenServer
- *     PV drivers.
- * (2) Multi-page ring buffer scheme first used in some RedHat distributions
- *     including a distribution deployed on certain nodes of the Amazon
- *     EC2 cluster.
- * (3) Support for multi-page ring buffers was implemented independently,
- *     in slightly different forms, by both Citrix and RedHat/Amazon.
- *     For full interoperability, block front and backends should publish
- *     identical ring parameters, adjusted for unit differences, to the
- *     XenStore nodes used in both schemes.
- * (4) Devices that support discard functionality may internally allocate
- *     space (discardable extents) in units that are larger than the
- *     exported logical block size.
- * (5) The discard-alignment parameter allows a physical device to be
- *     partitioned into virtual devices that do not necessarily begin or
- *     end on a discardable extent boundary.
- * (6) When there is only a single page allocated to the request ring,
- *     'ring-ref' is used to communicate the grant reference for this
- *     page to the backend.  When using a multi-page ring, the 'ring-ref'
- *     node is not created.  Instead 'ring-ref0' - 'ring-refN' are used.
- */
-
-/*
- * STATE DIAGRAMS
- *
- *****************************************************************************
- *                                   Startup                                 *
- *****************************************************************************
- *
- * Tool stack creates front and back nodes with state XenbusStateInitialising.
- *
- * Front                                Back
- * =================================    =====================================
- * XenbusStateInitialising              XenbusStateInitialising
- *  o Query virtual device               o Query backend device identification
- *    properties.                          data.
- *  o Setup OS device instance.          o Open and validate backend device.
- *                                       o Publish backend features and
- *                                         transport parameters.
- *                                                      |
- *                                                      |
- *                                                      V
- *                                      XenbusStateInitWait
- *
- * o Query backend features and
- *   transport parameters.
- * o Allocate and initialize the
- *   request ring.
- * o Publish transport parameters
- *   that will be in effect during
- *   this connection.
- *              |
- *              |
- *              V
- * XenbusStateInitialised
- *
- *                                       o Query frontend transport parameters.
- *                                       o Connect to the request ring and
- *                                         event channel.
- *                                       o Publish backend device properties.
- *                                                      |
- *                                                      |
- *                                                      V
- *                                      XenbusStateConnected
- *
- *  o Query backend device properties.
- *  o Finalize OS virtual device
- *    instance.
- *              |
- *              |
- *              V
- * XenbusStateConnected
- *
- * Note: Drivers that do not support any optional features, or the negotiation
- *       of transport parameters, can skip certain states in the state machine:
- *
- *       o A frontend may transition to XenbusStateInitialised without
- *         waiting for the backend to enter XenbusStateInitWait.  In this
- *         case, default transport parameters are in effect and any
- *         transport parameters published by the frontend must contain
- *         their default values.
- *
- *       o A backend may transition to XenbusStateInitialised, bypassing
- *         XenbusStateInitWait, without waiting for the frontend to first
- *         enter the XenbusStateInitialised state.  In this case, default
- *         transport parameters are in effect and any transport parameters
- *         published by the backend must contain their default values.
- *
- *       Drivers that support optional features and/or transport parameter
- *       negotiation must tolerate these additional state transition paths.
- *       In general this means performing the work of any skipped state
- *       transition, if it has not already been performed, in addition to the
- *       work associated with entry into the current state.
- */
-
-/*
- * REQUEST CODES.
- */
-#define BLKIF_OP_READ              0
-#define BLKIF_OP_WRITE             1
-/*
- * All writes issued prior to a request with the BLKIF_OP_WRITE_BARRIER
- * operation code ("barrier request") must be completed prior to the
- * execution of the barrier request.  All writes issued after the barrier
- * request must not execute until after the completion of the barrier request.
- *
- * Optional.  See "feature-barrier" XenBus node documentation above.
- */
-#define BLKIF_OP_WRITE_BARRIER     2
-/*
- * Commit any uncommitted contents of the backing device's volatile cache
- * to stable storage.
- *
- * Optional.  See "feature-flush-cache" XenBus node documentation above.
- */
-#define BLKIF_OP_FLUSH_DISKCACHE   3
-/*
- * Used in SLES sources for device specific command packet
- * contained within the request. Reserved for that purpose.
- */
-#define BLKIF_OP_RESERVED_1        4
-/*
- * Indicate to the backend device that a region of storage is no longer in
- * use, and may be discarded at any time without impact to the client.  If
- * the BLKIF_DISCARD_SECURE flag is set on the request, all copies of the
- * discarded region on the device must be rendered unrecoverable before the
- * command returns.
- *
- * This operation is analogous to performing a trim (ATA) or unamp (SCSI),
- * command on a native device.
- *
- * More information about trim/unmap operations can be found at:
- * http://t13.org/Documents/UploadedDocuments/docs2008/
- *     e07154r6-Data_Set_Management_Proposal_for_ATA-ACS2.doc
- * http://www.seagate.com/staticfiles/support/disc/manuals/
- *     Interface%20manuals/100293068c.pdf
- *
- * Optional.  See "feature-discard", "discard-alignment",
- * "discard-granularity", and "discard-secure" in the XenBus node
- * documentation above.
- */
-#define BLKIF_OP_DISCARD           5
-
-/*
- * Maximum scatter/gather segments per request.
- * This is carefully chosen so that sizeof(blkif_ring_t) <= PAGE_SIZE.
- * NB. This could be 12 if the ring indexes weren't stored in the same page.
- */
-#define BLKIF_MAX_SEGMENTS_PER_REQUEST 11
-
-/*
- * NB. first_sect and last_sect in blkif_request_segment, as well as
- * sector_number in blkif_request, are always expressed in 512-byte units.
- * However they must be properly aligned to the real sector size of the
- * physical disk, which is reported in the "sector-size" node in the backend
- * xenbus info. Also the xenbus "sectors" node is expressed in 512-byte units.
- */
-struct blkif_request_segment {
-    grant_ref_t gref;        /* reference to I/O buffer frame        */
-    /* @first_sect: first sector in frame to transfer (inclusive).   */
-    /* @last_sect: last sector in frame to transfer (inclusive).     */
-    uint8_t     first_sect, last_sect;
-};
-
-/*
- * Starting ring element for any I/O request.
- */
-struct blkif_request {
-    uint8_t        operation;    /* BLKIF_OP_???                         */
-    uint8_t        nr_segments;  /* number of segments                   */
-    blkif_vdev_t   handle;       /* only for read/write requests         */
-    uint64_t       id;           /* private guest value, echoed in resp  */
-    blkif_sector_t sector_number;/* start sector idx on disk (r/w only)  */
-    struct blkif_request_segment seg[BLKIF_MAX_SEGMENTS_PER_REQUEST];
-};
-typedef struct blkif_request blkif_request_t;
-
-/*
- * Cast to this structure when blkif_request.operation == BLKIF_OP_DISCARD
- * sizeof(struct blkif_request_discard) <= sizeof(struct blkif_request)
- */
-struct blkif_request_discard {
-    uint8_t        operation;    /* BLKIF_OP_DISCARD                     */
-    uint8_t        flag;         /* BLKIF_DISCARD_SECURE or zero         */
-#define BLKIF_DISCARD_SECURE (1<<0)  /* ignored if discard-secure=0      */
-    blkif_vdev_t   handle;       /* same as for read/write requests      */
-    uint64_t       id;           /* private guest value, echoed in resp  */
-    blkif_sector_t sector_number;/* start sector idx on disk             */
-    uint64_t       nr_sectors;   /* number of contiguous sectors to discard*/
-};
-typedef struct blkif_request_discard blkif_request_discard_t;
-
-struct blkif_response {
-    uint64_t        id;              /* copied from request */
-    uint8_t         operation;       /* copied from request */
-    int16_t         status;          /* BLKIF_RSP_???       */
-};
-typedef struct blkif_response blkif_response_t;
-
-/*
- * STATUS RETURN CODES.
- */
- /* Operation not supported (only happens on barrier writes). */
-#define BLKIF_RSP_EOPNOTSUPP  -2
- /* Operation failed for some unspecified reason (-EIO). */
-#define BLKIF_RSP_ERROR       -1
- /* Operation completed successfully. */
-#define BLKIF_RSP_OKAY         0
-
-/*
- * Generate blkif ring structures and types.
- */
-DEFINE_RING_TYPES(blkif, struct blkif_request, struct blkif_response);
-
-#define VDISK_CDROM        0x1
-#define VDISK_REMOVABLE    0x2
-#define VDISK_READONLY     0x4
-
-#endif /* __XEN_PUBLIC_IO_BLKIF_H__ */
-
-/*
- * Local variables:
- * mode: C
- * c-set-style: "BSD"
- * c-basic-offset: 4
- * tab-width: 4
- * indent-tabs-mode: nil
- * End:
- */
diff -Nru xen-4.2.1-new/extras/mini-os/include/xen/io/console.h xen-4.2.1/extras/mini-os/include/xen/io/console.h
--- xen-4.2.1-new/extras/mini-os/include/xen/io/console.h	2012-12-17 23:01:56.000000000 +0800
+++ xen-4.2.1/extras/mini-os/include/xen/io/console.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,51 +0,0 @@
-/******************************************************************************
- * console.h
- * 
- * Console I/O interface for Xen guest OSes.
- * 
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- * Copyright (c) 2005, Keir Fraser
- */
-
-#ifndef __XEN_PUBLIC_IO_CONSOLE_H__
-#define __XEN_PUBLIC_IO_CONSOLE_H__
-
-typedef uint32_t XENCONS_RING_IDX;
-
-#define MASK_XENCONS_IDX(idx, ring) ((idx) & (sizeof(ring)-1))
-
-struct xencons_interface {
-    char in[1024];
-    char out[2048];
-    XENCONS_RING_IDX in_cons, in_prod;
-    XENCONS_RING_IDX out_cons, out_prod;
-};
-
-#endif /* __XEN_PUBLIC_IO_CONSOLE_H__ */
-
-/*
- * Local variables:
- * mode: C
- * c-set-style: "BSD"
- * c-basic-offset: 4
- * tab-width: 4
- * indent-tabs-mode: nil
- * End:
- */
diff -Nru xen-4.2.1-new/extras/mini-os/include/xen/io/fbif.h xen-4.2.1/extras/mini-os/include/xen/io/fbif.h
--- xen-4.2.1-new/extras/mini-os/include/xen/io/fbif.h	2012-12-17 23:01:56.000000000 +0800
+++ xen-4.2.1/extras/mini-os/include/xen/io/fbif.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,176 +0,0 @@
-/*
- * fbif.h -- Xen virtual frame buffer device
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- * Copyright (C) 2005 Anthony Liguori <aliguori@us.ibm.com>
- * Copyright (C) 2006 Red Hat, Inc., Markus Armbruster <armbru@redhat.com>
- */
-
-#ifndef __XEN_PUBLIC_IO_FBIF_H__
-#define __XEN_PUBLIC_IO_FBIF_H__
-
-/* Out events (frontend -> backend) */
-
-/*
- * Out events may be sent only when requested by backend, and receipt
- * of an unknown out event is an error.
- */
-
-/* Event type 1 currently not used */
-/*
- * Framebuffer update notification event
- * Capable frontend sets feature-update in xenstore.
- * Backend requests it by setting request-update in xenstore.
- */
-#define XENFB_TYPE_UPDATE 2
-
-struct xenfb_update
-{
-    uint8_t type;    /* XENFB_TYPE_UPDATE */
-    int32_t x;      /* source x */
-    int32_t y;      /* source y */
-    int32_t width;  /* rect width */
-    int32_t height; /* rect height */
-};
-
-/*
- * Framebuffer resize notification event
- * Capable backend sets feature-resize in xenstore.
- */
-#define XENFB_TYPE_RESIZE 3
-
-struct xenfb_resize
-{
-    uint8_t type;    /* XENFB_TYPE_RESIZE */
-    int32_t width;   /* width in pixels */
-    int32_t height;  /* height in pixels */
-    int32_t stride;  /* stride in bytes */
-    int32_t depth;   /* depth in bits */
-    int32_t offset;  /* offset of the framebuffer in bytes */
-};
-
-#define XENFB_OUT_EVENT_SIZE 40
-
-union xenfb_out_event
-{
-    uint8_t type;
-    struct xenfb_update update;
-    struct xenfb_resize resize;
-    char pad[XENFB_OUT_EVENT_SIZE];
-};
-
-/* In events (backend -> frontend) */
-
-/*
- * Frontends should ignore unknown in events.
- */
-
-/*
- * Framebuffer refresh period advice
- * Backend sends it to advise the frontend their preferred period of
- * refresh.  Frontends that keep the framebuffer constantly up-to-date
- * just ignore it.  Frontends that use the advice should immediately
- * refresh the framebuffer (and send an update notification event if
- * those have been requested), then use the update frequency to guide
- * their periodical refreshs.
- */
-#define XENFB_TYPE_REFRESH_PERIOD 1
-#define XENFB_NO_REFRESH 0
-
-struct xenfb_refresh_period
-{
-    uint8_t type;    /* XENFB_TYPE_UPDATE_PERIOD */
-    uint32_t period; /* period of refresh, in ms,
-                      * XENFB_NO_REFRESH if no refresh is needed */
-};
-
-#define XENFB_IN_EVENT_SIZE 40
-
-union xenfb_in_event
-{
-    uint8_t type;
-    struct xenfb_refresh_period refresh_period;
-    char pad[XENFB_IN_EVENT_SIZE];
-};
-
-/* shared page */
-
-#define XENFB_IN_RING_SIZE 1024
-#define XENFB_IN_RING_LEN (XENFB_IN_RING_SIZE / XENFB_IN_EVENT_SIZE)
-#define XENFB_IN_RING_OFFS 1024
-#define XENFB_IN_RING(page) \
-    ((union xenfb_in_event *)((char *)(page) + XENFB_IN_RING_OFFS))
-#define XENFB_IN_RING_REF(page, idx) \
-    (XENFB_IN_RING((page))[(idx) % XENFB_IN_RING_LEN])
-
-#define XENFB_OUT_RING_SIZE 2048
-#define XENFB_OUT_RING_LEN (XENFB_OUT_RING_SIZE / XENFB_OUT_EVENT_SIZE)
-#define XENFB_OUT_RING_OFFS (XENFB_IN_RING_OFFS + XENFB_IN_RING_SIZE)
-#define XENFB_OUT_RING(page) \
-    ((union xenfb_out_event *)((char *)(page) + XENFB_OUT_RING_OFFS))
-#define XENFB_OUT_RING_REF(page, idx) \
-    (XENFB_OUT_RING((page))[(idx) % XENFB_OUT_RING_LEN])
-
-struct xenfb_page
-{
-    uint32_t in_cons, in_prod;
-    uint32_t out_cons, out_prod;
-
-    int32_t width;          /* the width of the framebuffer (in pixels) */
-    int32_t height;         /* the height of the framebuffer (in pixels) */
-    uint32_t line_length;   /* the length of a row of pixels (in bytes) */
-    uint32_t mem_length;    /* the length of the framebuffer (in bytes) */
-    uint8_t depth;          /* the depth of a pixel (in bits) */
-
-    /*
-     * Framebuffer page directory
-     *
-     * Each directory page holds PAGE_SIZE / sizeof(*pd)
-     * framebuffer pages, and can thus map up to PAGE_SIZE *
-     * PAGE_SIZE / sizeof(*pd) bytes.  With PAGE_SIZE == 4096 and
-     * sizeof(unsigned long) == 4/8, that's 4 Megs 32 bit and 2 Megs
-     * 64 bit.  256 directories give enough room for a 512 Meg
-     * framebuffer with a max resolution of 12,800x10,240.  Should
-     * be enough for a while with room leftover for expansion.
-     */
-    unsigned long pd[256];
-};
-
-/*
- * Wart: xenkbd needs to know default resolution.  Put it here until a
- * better solution is found, but don't leak it to the backend.
- */
-#ifdef __KERNEL__
-#define XENFB_WIDTH 800
-#define XENFB_HEIGHT 600
-#define XENFB_DEPTH 32
-#endif
-
-#endif
-
-/*
- * Local variables:
- * mode: C
- * c-set-style: "BSD"
- * c-basic-offset: 4
- * tab-width: 4
- * indent-tabs-mode: nil
- * End:
- */
diff -Nru xen-4.2.1-new/extras/mini-os/include/xen/io/fsif.h xen-4.2.1/extras/mini-os/include/xen/io/fsif.h
--- xen-4.2.1-new/extras/mini-os/include/xen/io/fsif.h	2012-12-17 23:01:56.000000000 +0800
+++ xen-4.2.1/extras/mini-os/include/xen/io/fsif.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,192 +0,0 @@
-/******************************************************************************
- * fsif.h
- * 
- * Interface to FS level split device drivers.
- * 
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- * Copyright (c) 2007, Grzegorz Milos, <gm281@cam.ac.uk>.
- */
-
-#ifndef __XEN_PUBLIC_IO_FSIF_H__
-#define __XEN_PUBLIC_IO_FSIF_H__
-
-#include "ring.h"
-#include "../grant_table.h"
-
-#define REQ_FILE_OPEN        1
-#define REQ_FILE_CLOSE       2
-#define REQ_FILE_READ        3
-#define REQ_FILE_WRITE       4
-#define REQ_STAT             5
-#define REQ_FILE_TRUNCATE    6
-#define REQ_REMOVE           7
-#define REQ_RENAME           8
-#define REQ_CREATE           9
-#define REQ_DIR_LIST        10
-#define REQ_CHMOD           11
-#define REQ_FS_SPACE        12
-#define REQ_FILE_SYNC       13
-
-struct fsif_open_request {
-    grant_ref_t gref;
-};
-
-struct fsif_close_request {
-    uint32_t fd;
-};
-
-struct fsif_read_request {
-    uint32_t fd;
-    int32_t pad;
-    uint64_t len;
-    uint64_t offset;
-    grant_ref_t grefs[1];  /* Variable length */
-};
-
-struct fsif_write_request {
-    uint32_t fd;
-    int32_t pad;
-    uint64_t len;
-    uint64_t offset;
-    grant_ref_t grefs[1];  /* Variable length */
-};
-
-struct fsif_stat_request {
-    uint32_t fd;
-};
-
-/* This structure is a copy of some fields from stat structure, returned
- * via the ring. */
-struct fsif_stat_response {
-    int32_t  stat_mode;
-    uint32_t stat_uid;
-    uint32_t stat_gid;
-    int32_t  stat_ret;
-    int64_t  stat_size;
-    int64_t  stat_atime;
-    int64_t  stat_mtime;
-    int64_t  stat_ctime;
-};
-
-struct fsif_truncate_request {
-    uint32_t fd;
-    int32_t pad;
-    int64_t length;
-};
-
-struct fsif_remove_request {
-    grant_ref_t gref;
-};
-
-struct fsif_rename_request {
-    uint16_t old_name_offset;
-    uint16_t new_name_offset;
-    grant_ref_t gref;
-};
-
-struct fsif_create_request {
-    int8_t directory;
-    int8_t pad;
-    int16_t pad2;
-    int32_t mode;
-    grant_ref_t gref;
-};
-
-struct fsif_list_request {
-    uint32_t offset;
-    grant_ref_t gref;
-};
-
-#define NR_FILES_SHIFT  0
-#define NR_FILES_SIZE   16   /* 16 bits for the number of files mask */
-#define NR_FILES_MASK   (((1ULL << NR_FILES_SIZE) - 1) << NR_FILES_SHIFT)
-#define ERROR_SIZE      32   /* 32 bits for the error mask */
-#define ERROR_SHIFT     (NR_FILES_SIZE + NR_FILES_SHIFT)
-#define ERROR_MASK      (((1ULL << ERROR_SIZE) - 1) << ERROR_SHIFT)
-#define HAS_MORE_SHIFT  (ERROR_SHIFT + ERROR_SIZE)    
-#define HAS_MORE_FLAG   (1ULL << HAS_MORE_SHIFT)
-
-struct fsif_chmod_request {
-    uint32_t fd;
-    int32_t mode;
-};
-
-struct fsif_space_request {
-    grant_ref_t gref;
-};
-
-struct fsif_sync_request {
-    uint32_t fd;
-};
-
-
-/* FS operation request */
-struct fsif_request {
-    uint8_t type;                 /* Type of the request                  */
-    uint8_t pad;
-    uint16_t id;                  /* Request ID, copied to the response   */
-    uint32_t pad2;
-    union {
-        struct fsif_open_request     fopen;
-        struct fsif_close_request    fclose;
-        struct fsif_read_request     fread;
-        struct fsif_write_request    fwrite;
-        struct fsif_stat_request     fstat;
-        struct fsif_truncate_request ftruncate;
-        struct fsif_remove_request   fremove;
-        struct fsif_rename_request   frename;
-        struct fsif_create_request   fcreate;
-        struct fsif_list_request     flist;
-        struct fsif_chmod_request    fchmod;
-        struct fsif_space_request    fspace;
-        struct fsif_sync_request     fsync;
-    } u;
-};
-typedef struct fsif_request fsif_request_t;
-
-/* FS operation response */
-struct fsif_response {
-    uint16_t id;
-    uint16_t pad1;
-    uint32_t pad2;
-    union {
-        uint64_t ret_val;
-        struct fsif_stat_response fstat;
-    } u;
-};
-
-typedef struct fsif_response fsif_response_t;
-
-#define FSIF_RING_ENTRY_SIZE   64
-
-#define FSIF_NR_READ_GNTS  ((FSIF_RING_ENTRY_SIZE - sizeof(struct fsif_read_request)) /  \
-                                sizeof(grant_ref_t) + 1)
-#define FSIF_NR_WRITE_GNTS ((FSIF_RING_ENTRY_SIZE - sizeof(struct fsif_write_request)) / \
-                                sizeof(grant_ref_t) + 1)
-
-DEFINE_RING_TYPES(fsif, struct fsif_request, struct fsif_response);
-
-#define STATE_INITIALISED     "init"
-#define STATE_READY           "ready"
-#define STATE_CLOSING         "closing"
-#define STATE_CLOSED          "closed"
-
-
-#endif
diff -Nru xen-4.2.1-new/extras/mini-os/include/xen/io/kbdif.h xen-4.2.1/extras/mini-os/include/xen/io/kbdif.h
--- xen-4.2.1-new/extras/mini-os/include/xen/io/kbdif.h	2012-12-17 23:01:56.000000000 +0800
+++ xen-4.2.1/extras/mini-os/include/xen/io/kbdif.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,132 +0,0 @@
-/*
- * kbdif.h -- Xen virtual keyboard/mouse
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- * Copyright (C) 2005 Anthony Liguori <aliguori@us.ibm.com>
- * Copyright (C) 2006 Red Hat, Inc., Markus Armbruster <armbru@redhat.com>
- */
-
-#ifndef __XEN_PUBLIC_IO_KBDIF_H__
-#define __XEN_PUBLIC_IO_KBDIF_H__
-
-/* In events (backend -> frontend) */
-
-/*
- * Frontends should ignore unknown in events.
- */
-
-/* Pointer movement event */
-#define XENKBD_TYPE_MOTION  1
-/* Event type 2 currently not used */
-/* Key event (includes pointer buttons) */
-#define XENKBD_TYPE_KEY     3
-/*
- * Pointer position event
- * Capable backend sets feature-abs-pointer in xenstore.
- * Frontend requests ot instead of XENKBD_TYPE_MOTION by setting
- * request-abs-update in xenstore.
- */
-#define XENKBD_TYPE_POS     4
-
-struct xenkbd_motion
-{
-    uint8_t type;        /* XENKBD_TYPE_MOTION */
-    int32_t rel_x;       /* relative X motion */
-    int32_t rel_y;       /* relative Y motion */
-    int32_t rel_z;       /* relative Z motion (wheel) */
-};
-
-struct xenkbd_key
-{
-    uint8_t type;         /* XENKBD_TYPE_KEY */
-    uint8_t pressed;      /* 1 if pressed; 0 otherwise */
-    uint32_t keycode;     /* KEY_* from linux/input.h */
-};
-
-struct xenkbd_position
-{
-    uint8_t type;        /* XENKBD_TYPE_POS */
-    int32_t abs_x;       /* absolute X position (in FB pixels) */
-    int32_t abs_y;       /* absolute Y position (in FB pixels) */
-    int32_t rel_z;       /* relative Z motion (wheel) */
-};
-
-#define XENKBD_IN_EVENT_SIZE 40
-
-union xenkbd_in_event
-{
-    uint8_t type;
-    struct xenkbd_motion motion;
-    struct xenkbd_key key;
-    struct xenkbd_position pos;
-    char pad[XENKBD_IN_EVENT_SIZE];
-};
-
-/* Out events (frontend -> backend) */
-
-/*
- * Out events may be sent only when requested by backend, and receipt
- * of an unknown out event is an error.
- * No out events currently defined.
- */
-
-#define XENKBD_OUT_EVENT_SIZE 40
-
-union xenkbd_out_event
-{
-    uint8_t type;
-    char pad[XENKBD_OUT_EVENT_SIZE];
-};
-
-/* shared page */
-
-#define XENKBD_IN_RING_SIZE 2048
-#define XENKBD_IN_RING_LEN (XENKBD_IN_RING_SIZE / XENKBD_IN_EVENT_SIZE)
-#define XENKBD_IN_RING_OFFS 1024
-#define XENKBD_IN_RING(page) \
-    ((union xenkbd_in_event *)((char *)(page) + XENKBD_IN_RING_OFFS))
-#define XENKBD_IN_RING_REF(page, idx) \
-    (XENKBD_IN_RING((page))[(idx) % XENKBD_IN_RING_LEN])
-
-#define XENKBD_OUT_RING_SIZE 1024
-#define XENKBD_OUT_RING_LEN (XENKBD_OUT_RING_SIZE / XENKBD_OUT_EVENT_SIZE)
-#define XENKBD_OUT_RING_OFFS (XENKBD_IN_RING_OFFS + XENKBD_IN_RING_SIZE)
-#define XENKBD_OUT_RING(page) \
-    ((union xenkbd_out_event *)((char *)(page) + XENKBD_OUT_RING_OFFS))
-#define XENKBD_OUT_RING_REF(page, idx) \
-    (XENKBD_OUT_RING((page))[(idx) % XENKBD_OUT_RING_LEN])
-
-struct xenkbd_page
-{
-    uint32_t in_cons, in_prod;
-    uint32_t out_cons, out_prod;
-};
-
-#endif
-
-/*
- * Local variables:
- * mode: C
- * c-set-style: "BSD"
- * c-basic-offset: 4
- * tab-width: 4
- * indent-tabs-mode: nil
- * End:
- */
diff -Nru xen-4.2.1-new/extras/mini-os/include/xen/io/libxenvchan.h xen-4.2.1/extras/mini-os/include/xen/io/libxenvchan.h
--- xen-4.2.1-new/extras/mini-os/include/xen/io/libxenvchan.h	2012-12-17 23:01:56.000000000 +0800
+++ xen-4.2.1/extras/mini-os/include/xen/io/libxenvchan.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,97 +0,0 @@
-/**
- * @file
- * @section AUTHORS
- *
- * Copyright (C) 2010  Rafal Wojtczuk  <rafal@invisiblethingslab.com>
- *
- *  Authors:
- *       Rafal Wojtczuk  <rafal@invisiblethingslab.com>
- *       Daniel De Graaf <dgdegra@tycho.nsa.gov>
- *
- * @section LICENSE
- *
- *  This library is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU Lesser General Public
- *  License as published by the Free Software Foundation; either
- *  version 2.1 of the License, or (at your option) any later version.
- *
- *  This library is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  Lesser General Public License for more details.
- *
- *  You should have received a copy of the GNU Lesser General Public
- *  License along with this library; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301 USA
- *
- * @section DESCRIPTION
- *
- *  Originally borrowed from the Qubes OS Project, http://www.qubes-os.org,
- *  this code has been substantially rewritten to use the gntdev and gntalloc
- *  devices instead of raw MFNs and map_foreign_range.
- *
- *  This is a library for inter-domain communication.  A standard Xen ring
- *  buffer is used, with a datagram-based interface built on top.  The grant
- *  reference and event channels are shared in XenStore under a user-specified
- *  path.
- *
- *  The ring.h macros define an asymmetric interface to a shared data structure
- *  that assumes all rings reside in a single contiguous memory space. This is
- *  not suitable for vchan because the interface to the ring is symmetric except
- *  for the setup. Unlike the producer-consumer rings defined in ring.h, the
- *  size of the rings used in vchan are determined at execution time instead of
- *  compile time, so the macros in ring.h cannot be used to access the rings.
- */
-
-#include <stdint.h>
-#include <sys/types.h>
-
-struct ring_shared {
-	uint32_t cons, prod;
-};
-
-#define VCHAN_NOTIFY_WRITE 0x1
-#define VCHAN_NOTIFY_READ 0x2
-
-/**
- * vchan_interface: primary shared data structure
- */
-struct vchan_interface {
-	/**
-	 * Standard consumer/producer interface, one pair per buffer
-	 * left is client write, server read
-	 * right is client read, server write
-	 */
-	struct ring_shared left, right;
-	/**
-	 * size of the rings, which determines their location
-	 * 10   - at offset 1024 in ring's page
-	 * 11   - at offset 2048 in ring's page
-	 * 12+  - uses 2^(N-12) grants to describe the multi-page ring
-	 * These should remain constant once the page is shared.
-	 * Only one of the two orders can be 10 (or 11).
-	 */
-	uint16_t left_order, right_order;
-	/**
-	 * Shutdown detection:
-	 *  0: client (or server) has exited
-	 *  1: client (or server) is connected
-	 *  2: client has not yet connected
-	 */
-	uint8_t cli_live, srv_live;
-	/**
-	 * Notification bits:
-	 *  VCHAN_NOTIFY_WRITE: send notify when data is written
-	 *  VCHAN_NOTIFY_READ: send notify when data is read (consumed)
-	 * cli_notify is used for the client to inform the server of its action
-	 */
-	uint8_t cli_notify, srv_notify;
-	/**
-	 * Grant list: ordering is left, right. Must not extend into actual ring
-	 * or grow beyond the end of the initial shared page.
-	 * These should remain constant once the page is shared, to allow
-	 * for possible remapping by a client that restarts.
-	 */
-	uint32_t grants[0];
-};
-
diff -Nru xen-4.2.1-new/extras/mini-os/include/xen/io/netif.h xen-4.2.1/extras/mini-os/include/xen/io/netif.h
--- xen-4.2.1-new/extras/mini-os/include/xen/io/netif.h	2012-12-17 23:01:56.000000000 +0800
+++ xen-4.2.1/extras/mini-os/include/xen/io/netif.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,205 +0,0 @@
-/******************************************************************************
- * netif.h
- * 
- * Unified network-device I/O interface for Xen guest OSes.
- * 
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- * Copyright (c) 2003-2004, Keir Fraser
- */
-
-#ifndef __XEN_PUBLIC_IO_NETIF_H__
-#define __XEN_PUBLIC_IO_NETIF_H__
-
-#include "ring.h"
-#include "../grant_table.h"
-
-/*
- * Notifications after enqueuing any type of message should be conditional on
- * the appropriate req_event or rsp_event field in the shared ring.
- * If the client sends notification for rx requests then it should specify
- * feature 'feature-rx-notify' via xenbus. Otherwise the backend will assume
- * that it cannot safely queue packets (as it may not be kicked to send them).
- */
-
-/*
- * This is the 'wire' format for packets:
- *  Request 1: netif_tx_request -- NETTXF_* (any flags)
- * [Request 2: netif_tx_extra]  (only if request 1 has NETTXF_extra_info)
- * [Request 3: netif_tx_extra]  (only if request 2 has XEN_NETIF_EXTRA_MORE)
- *  Request 4: netif_tx_request -- NETTXF_more_data
- *  Request 5: netif_tx_request -- NETTXF_more_data
- *  ...
- *  Request N: netif_tx_request -- 0
- */
-
-/* Protocol checksum field is blank in the packet (hardware offload)? */
-#define _NETTXF_csum_blank     (0)
-#define  NETTXF_csum_blank     (1U<<_NETTXF_csum_blank)
-
-/* Packet data has been validated against protocol checksum. */
-#define _NETTXF_data_validated (1)
-#define  NETTXF_data_validated (1U<<_NETTXF_data_validated)
-
-/* Packet continues in the next request descriptor. */
-#define _NETTXF_more_data      (2)
-#define  NETTXF_more_data      (1U<<_NETTXF_more_data)
-
-/* Packet to be followed by extra descriptor(s). */
-#define _NETTXF_extra_info     (3)
-#define  NETTXF_extra_info     (1U<<_NETTXF_extra_info)
-
-struct netif_tx_request {
-    grant_ref_t gref;      /* Reference to buffer page */
-    uint16_t offset;       /* Offset within buffer page */
-    uint16_t flags;        /* NETTXF_* */
-    uint16_t id;           /* Echoed in response message. */
-    uint16_t size;         /* Packet size in bytes.       */
-};
-typedef struct netif_tx_request netif_tx_request_t;
-
-/* Types of netif_extra_info descriptors. */
-#define XEN_NETIF_EXTRA_TYPE_NONE      (0)  /* Never used - invalid */
-#define XEN_NETIF_EXTRA_TYPE_GSO       (1)  /* u.gso */
-#define XEN_NETIF_EXTRA_TYPE_MCAST_ADD (2)  /* u.mcast */
-#define XEN_NETIF_EXTRA_TYPE_MCAST_DEL (3)  /* u.mcast */
-#define XEN_NETIF_EXTRA_TYPE_MAX       (4)
-
-/* netif_extra_info flags. */
-#define _XEN_NETIF_EXTRA_FLAG_MORE (0)
-#define XEN_NETIF_EXTRA_FLAG_MORE  (1U<<_XEN_NETIF_EXTRA_FLAG_MORE)
-
-/* GSO types - only TCPv4 currently supported. */
-#define XEN_NETIF_GSO_TYPE_TCPV4        (1)
-
-/*
- * This structure needs to fit within both netif_tx_request and
- * netif_rx_response for compatibility.
- */
-struct netif_extra_info {
-    uint8_t type;  /* XEN_NETIF_EXTRA_TYPE_* */
-    uint8_t flags; /* XEN_NETIF_EXTRA_FLAG_* */
-
-    union {
-        /*
-         * XEN_NETIF_EXTRA_TYPE_GSO:
-         */
-        struct {
-            /*
-             * Maximum payload size of each segment. For example, for TCP this
-             * is just the path MSS.
-             */
-            uint16_t size;
-
-            /*
-             * GSO type. This determines the protocol of the packet and any
-             * extra features required to segment the packet properly.
-             */
-            uint8_t type; /* XEN_NETIF_GSO_TYPE_* */
-
-            /* Future expansion. */
-            uint8_t pad;
-
-            /*
-             * GSO features. This specifies any extra GSO features required
-             * to process this packet, such as ECN support for TCPv4.
-             */
-            uint16_t features; /* XEN_NETIF_GSO_FEAT_* */
-        } gso;
-
-        /*
-         * XEN_NETIF_EXTRA_TYPE_MCAST_{ADD,DEL}:
-         * Backend advertises availability via 'feature-multicast-control'
-         * xenbus node containing value '1'.
-         * Frontend requests this feature by advertising
-         * 'request-multicast-control' xenbus node containing value '1'.
-         * If multicast control is requested then multicast flooding is
-         * disabled and the frontend must explicitly register its interest
-         * in multicast groups using dummy transmit requests containing
-         * MCAST_{ADD,DEL} extra-info fragments.
-         */
-        struct {
-            uint8_t addr[6]; /* Address to add/remove. */
-        } mcast;
-
-        uint16_t pad[3];
-    } u;
-};
-typedef struct netif_extra_info netif_extra_info_t;
-
-struct netif_tx_response {
-    uint16_t id;
-    int16_t  status;       /* NETIF_RSP_* */
-};
-typedef struct netif_tx_response netif_tx_response_t;
-
-struct netif_rx_request {
-    uint16_t    id;        /* Echoed in response message.        */
-    grant_ref_t gref;      /* Reference to incoming granted frame */
-};
-typedef struct netif_rx_request netif_rx_request_t;
-
-/* Packet data has been validated against protocol checksum. */
-#define _NETRXF_data_validated (0)
-#define  NETRXF_data_validated (1U<<_NETRXF_data_validated)
-
-/* Protocol checksum field is blank in the packet (hardware offload)? */
-#define _NETRXF_csum_blank     (1)
-#define  NETRXF_csum_blank     (1U<<_NETRXF_csum_blank)
-
-/* Packet continues in the next request descriptor. */
-#define _NETRXF_more_data      (2)
-#define  NETRXF_more_data      (1U<<_NETRXF_more_data)
-
-/* Packet to be followed by extra descriptor(s). */
-#define _NETRXF_extra_info     (3)
-#define  NETRXF_extra_info     (1U<<_NETRXF_extra_info)
-
-struct netif_rx_response {
-    uint16_t id;
-    uint16_t offset;       /* Offset in page of start of received packet  */
-    uint16_t flags;        /* NETRXF_* */
-    int16_t  status;       /* -ve: BLKIF_RSP_* ; +ve: Rx'ed pkt size. */
-};
-typedef struct netif_rx_response netif_rx_response_t;
-
-/*
- * Generate netif ring structures and types.
- */
-
-DEFINE_RING_TYPES(netif_tx, struct netif_tx_request, struct netif_tx_response);
-DEFINE_RING_TYPES(netif_rx, struct netif_rx_request, struct netif_rx_response);
-
-#define NETIF_RSP_DROPPED         -2
-#define NETIF_RSP_ERROR           -1
-#define NETIF_RSP_OKAY             0
-/* No response: used for auxiliary requests (e.g., netif_tx_extra). */
-#define NETIF_RSP_NULL             1
-
-#endif
-
-/*
- * Local variables:
- * mode: C
- * c-set-style: "BSD"
- * c-basic-offset: 4
- * tab-width: 4
- * indent-tabs-mode: nil
- * End:
- */
diff -Nru xen-4.2.1-new/extras/mini-os/include/xen/io/pciif.h xen-4.2.1/extras/mini-os/include/xen/io/pciif.h
--- xen-4.2.1-new/extras/mini-os/include/xen/io/pciif.h	2012-12-17 23:01:56.000000000 +0800
+++ xen-4.2.1/extras/mini-os/include/xen/io/pciif.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,124 +0,0 @@
-/*
- * PCI Backend/Frontend Common Data Structures & Macros
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- *   Author: Ryan Wilson <hap9@epoch.ncsc.mil>
- */
-#ifndef __XEN_PCI_COMMON_H__
-#define __XEN_PCI_COMMON_H__
-
-/* Be sure to bump this number if you change this file */
-#define XEN_PCI_MAGIC "7"
-
-/* xen_pci_sharedinfo flags */
-#define _XEN_PCIF_active     (0)
-#define XEN_PCIF_active      (1<<_XEN_PCIF_active)
-#define _XEN_PCIB_AERHANDLER (1)
-#define XEN_PCIB_AERHANDLER  (1<<_XEN_PCIB_AERHANDLER)
-#define _XEN_PCIB_active     (2)
-#define XEN_PCIB_active      (1<<_XEN_PCIB_active)
-
-/* xen_pci_op commands */
-#define XEN_PCI_OP_conf_read    	(0)
-#define XEN_PCI_OP_conf_write   	(1)
-#define XEN_PCI_OP_enable_msi   	(2)
-#define XEN_PCI_OP_disable_msi  	(3)
-#define XEN_PCI_OP_enable_msix  	(4)
-#define XEN_PCI_OP_disable_msix 	(5)
-#define XEN_PCI_OP_aer_detected 	(6)
-#define XEN_PCI_OP_aer_resume		(7)
-#define XEN_PCI_OP_aer_mmio		(8)
-#define XEN_PCI_OP_aer_slotreset	(9)
-
-/* xen_pci_op error numbers */
-#define XEN_PCI_ERR_success          (0)
-#define XEN_PCI_ERR_dev_not_found   (-1)
-#define XEN_PCI_ERR_invalid_offset  (-2)
-#define XEN_PCI_ERR_access_denied   (-3)
-#define XEN_PCI_ERR_not_implemented (-4)
-/* XEN_PCI_ERR_op_failed - backend failed to complete the operation */
-#define XEN_PCI_ERR_op_failed       (-5)
-
-/*
- * it should be PAGE_SIZE-sizeof(struct xen_pci_op))/sizeof(struct msix_entry))
- * Should not exceed 128
- */
-#define SH_INFO_MAX_VEC     128
-
-struct xen_msix_entry {
-    uint16_t vector;
-    uint16_t entry;
-};
-struct xen_pci_op {
-    /* IN: what action to perform: XEN_PCI_OP_* */
-    uint32_t cmd;
-
-    /* OUT: will contain an error number (if any) from errno.h */
-    int32_t err;
-
-    /* IN: which device to touch */
-    uint32_t domain; /* PCI Domain/Segment */
-    uint32_t bus;
-    uint32_t devfn;
-
-    /* IN: which configuration registers to touch */
-    int32_t offset;
-    int32_t size;
-
-    /* IN/OUT: Contains the result after a READ or the value to WRITE */
-    uint32_t value;
-    /* IN: Contains extra infor for this operation */
-    uint32_t info;
-    /*IN:  param for msi-x */
-    struct xen_msix_entry msix_entries[SH_INFO_MAX_VEC];
-};
-
-/*used for pcie aer handling*/
-struct xen_pcie_aer_op
-{
-
-    /* IN: what action to perform: XEN_PCI_OP_* */
-    uint32_t cmd;
-    /*IN/OUT: return aer_op result or carry error_detected state as input*/
-    int32_t err;
-
-    /* IN: which device to touch */
-    uint32_t domain; /* PCI Domain/Segment*/
-    uint32_t bus;
-    uint32_t devfn;
-};
-struct xen_pci_sharedinfo {
-    /* flags - XEN_PCIF_* */
-    uint32_t flags;
-    struct xen_pci_op op;
-    struct xen_pcie_aer_op aer_op;
-};
-
-#endif /* __XEN_PCI_COMMON_H__ */
-
-/*
- * Local variables:
- * mode: C
- * c-set-style: "BSD"
- * c-basic-offset: 4
- * tab-width: 4
- * indent-tabs-mode: nil
- * End:
- */
diff -Nru xen-4.2.1-new/extras/mini-os/include/xen/io/protocols.h xen-4.2.1/extras/mini-os/include/xen/io/protocols.h
--- xen-4.2.1-new/extras/mini-os/include/xen/io/protocols.h	2012-12-17 23:01:56.000000000 +0800
+++ xen-4.2.1/extras/mini-os/include/xen/io/protocols.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,43 +0,0 @@
-/******************************************************************************
- * protocols.h
- * 
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- */
-
-#ifndef __XEN_PROTOCOLS_H__
-#define __XEN_PROTOCOLS_H__
-
-#define XEN_IO_PROTO_ABI_X86_32     "x86_32-abi"
-#define XEN_IO_PROTO_ABI_X86_64     "x86_64-abi"
-#define XEN_IO_PROTO_ABI_IA64       "ia64-abi"
-#define XEN_IO_PROTO_ABI_ARM        "arm-abi"
-
-#if defined(__i386__)
-# define XEN_IO_PROTO_ABI_NATIVE XEN_IO_PROTO_ABI_X86_32
-#elif defined(__x86_64__)
-# define XEN_IO_PROTO_ABI_NATIVE XEN_IO_PROTO_ABI_X86_64
-#elif defined(__ia64__)
-# define XEN_IO_PROTO_ABI_NATIVE XEN_IO_PROTO_ABI_IA64
-#elif defined(__arm__)
-# define XEN_IO_PROTO_ABI_NATIVE XEN_IO_PROTO_ABI_ARM
-#else
-# error arch fixup needed here
-#endif
-
-#endif
diff -Nru xen-4.2.1-new/extras/mini-os/include/xen/io/ring.h xen-4.2.1/extras/mini-os/include/xen/io/ring.h
--- xen-4.2.1-new/extras/mini-os/include/xen/io/ring.h	2012-12-17 23:01:56.000000000 +0800
+++ xen-4.2.1/extras/mini-os/include/xen/io/ring.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,323 +0,0 @@
-/******************************************************************************
- * ring.h
- * 
- * Shared producer-consumer ring macros.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- * Tim Deegan and Andrew Warfield November 2004.
- */
-
-#ifndef __XEN_PUBLIC_IO_RING_H__
-#define __XEN_PUBLIC_IO_RING_H__
-
-#include "../xen-compat.h"
-
-#if __XEN_INTERFACE_VERSION__ < 0x00030208
-#define xen_mb()  mb()
-#define xen_rmb() rmb()
-#define xen_wmb() wmb()
-#endif
-
-typedef unsigned int RING_IDX;
-
-/* Round a 32-bit unsigned constant down to the nearest power of two. */
-#define __RD2(_x)  (((_x) & 0x00000002) ? 0x2                  : ((_x) & 0x1))
-#define __RD4(_x)  (((_x) & 0x0000000c) ? __RD2((_x)>>2)<<2    : __RD2(_x))
-#define __RD8(_x)  (((_x) & 0x000000f0) ? __RD4((_x)>>4)<<4    : __RD4(_x))
-#define __RD16(_x) (((_x) & 0x0000ff00) ? __RD8((_x)>>8)<<8    : __RD8(_x))
-#define __RD32(_x) (((_x) & 0xffff0000) ? __RD16((_x)>>16)<<16 : __RD16(_x))
-
-/*
- * Calculate size of a shared ring, given the total available space for the
- * ring and indexes (_sz), and the name tag of the request/response structure.
- * A ring contains as many entries as will fit, rounded down to the nearest 
- * power of two (so we can mask with (size-1) to loop around).
- */
-#define __CONST_RING_SIZE(_s, _sz) \
-    (__RD32(((_sz) - offsetof(struct _s##_sring, ring)) / \
-	    sizeof(((struct _s##_sring *)0)->ring[0])))
-/*
- * The same for passing in an actual pointer instead of a name tag.
- */
-#define __RING_SIZE(_s, _sz) \
-    (__RD32(((_sz) - (long)(_s)->ring + (long)(_s)) / sizeof((_s)->ring[0])))
-
-/*
- * Macros to make the correct C datatypes for a new kind of ring.
- * 
- * To make a new ring datatype, you need to have two message structures,
- * let's say request_t, and response_t already defined.
- *
- * In a header where you want the ring datatype declared, you then do:
- *
- *     DEFINE_RING_TYPES(mytag, request_t, response_t);
- *
- * These expand out to give you a set of types, as you can see below.
- * The most important of these are:
- * 
- *     mytag_sring_t      - The shared ring.
- *     mytag_front_ring_t - The 'front' half of the ring.
- *     mytag_back_ring_t  - The 'back' half of the ring.
- *
- * To initialize a ring in your code you need to know the location and size
- * of the shared memory area (PAGE_SIZE, for instance). To initialise
- * the front half:
- *
- *     mytag_front_ring_t front_ring;
- *     SHARED_RING_INIT((mytag_sring_t *)shared_page);
- *     FRONT_RING_INIT(&front_ring, (mytag_sring_t *)shared_page, PAGE_SIZE);
- *
- * Initializing the back follows similarly (note that only the front
- * initializes the shared ring):
- *
- *     mytag_back_ring_t back_ring;
- *     BACK_RING_INIT(&back_ring, (mytag_sring_t *)shared_page, PAGE_SIZE);
- */
-
-#define DEFINE_RING_TYPES(__name, __req_t, __rsp_t)                     \
-                                                                        \
-/* Shared ring entry */                                                 \
-union __name##_sring_entry {                                            \
-    __req_t req;                                                        \
-    __rsp_t rsp;                                                        \
-};                                                                      \
-                                                                        \
-/* Shared ring page */                                                  \
-struct __name##_sring {                                                 \
-    RING_IDX req_prod, req_event;                                       \
-    RING_IDX rsp_prod, rsp_event;                                       \
-    union {                                                             \
-        struct {                                                        \
-            uint8_t smartpoll_active;                                   \
-        } netif;                                                        \
-        struct {                                                        \
-            uint8_t msg;                                                \
-        } tapif_user;                                                   \
-        uint8_t pvt_pad[4];                                             \
-    } private;                                                          \
-    uint8_t __pad[44];                                                  \
-    union __name##_sring_entry ring[1]; /* variable-length */           \
-};                                                                      \
-                                                                        \
-/* "Front" end's private variables */                                   \
-struct __name##_front_ring {                                            \
-    RING_IDX req_prod_pvt;                                              \
-    RING_IDX rsp_cons;                                                  \
-    unsigned int nr_ents;                                               \
-    struct __name##_sring *sring;                                       \
-};                                                                      \
-                                                                        \
-/* "Back" end's private variables */                                    \
-struct __name##_back_ring {                                             \
-    RING_IDX rsp_prod_pvt;                                              \
-    RING_IDX req_cons;                                                  \
-    unsigned int nr_ents;                                               \
-    struct __name##_sring *sring;                                       \
-};                                                                      \
-                                                                        \
-/* Syntactic sugar */                                                   \
-typedef struct __name##_sring __name##_sring_t;                         \
-typedef struct __name##_front_ring __name##_front_ring_t;               \
-typedef struct __name##_back_ring __name##_back_ring_t
-
-/*
- * Macros for manipulating rings.
- * 
- * FRONT_RING_whatever works on the "front end" of a ring: here 
- * requests are pushed on to the ring and responses taken off it.
- * 
- * BACK_RING_whatever works on the "back end" of a ring: here 
- * requests are taken off the ring and responses put on.
- * 
- * N.B. these macros do NO INTERLOCKS OR FLOW CONTROL. 
- * This is OK in 1-for-1 request-response situations where the 
- * requestor (front end) never has more than RING_SIZE()-1
- * outstanding requests.
- */
-
-/* Initialising empty rings */
-#define SHARED_RING_INIT(_s) do {                                       \
-    (_s)->req_prod  = (_s)->rsp_prod  = 0;                              \
-    (_s)->req_event = (_s)->rsp_event = 1;                              \
-    (void)memset((_s)->private.pvt_pad, 0, sizeof((_s)->private.pvt_pad)); \
-    (void)memset((_s)->__pad, 0, sizeof((_s)->__pad));                  \
-} while(0)
-
-#define FRONT_RING_INIT(_r, _s, __size) do {                            \
-    (_r)->req_prod_pvt = 0;                                             \
-    (_r)->rsp_cons = 0;                                                 \
-    (_r)->nr_ents = __RING_SIZE(_s, __size);                            \
-    (_r)->sring = (_s);                                                 \
-} while (0)
-
-#define BACK_RING_INIT(_r, _s, __size) do {                             \
-    (_r)->rsp_prod_pvt = 0;                                             \
-    (_r)->req_cons = 0;                                                 \
-    (_r)->nr_ents = __RING_SIZE(_s, __size);                            \
-    (_r)->sring = (_s);                                                 \
-} while (0)
-
-/* Initialize to existing shared indexes -- for recovery */
-#define FRONT_RING_ATTACH(_r, _s, __size) do {                          \
-    (_r)->sring = (_s);                                                 \
-    (_r)->req_prod_pvt = (_s)->req_prod;                                \
-    (_r)->rsp_cons = (_s)->rsp_prod;                                    \
-    (_r)->nr_ents = __RING_SIZE(_s, __size);                            \
-} while (0)
-
-#define BACK_RING_ATTACH(_r, _s, __size) do {                           \
-    (_r)->sring = (_s);                                                 \
-    (_r)->rsp_prod_pvt = (_s)->rsp_prod;                                \
-    (_r)->req_cons = (_s)->req_prod;                                    \
-    (_r)->nr_ents = __RING_SIZE(_s, __size);                            \
-} while (0)
-
-/* How big is this ring? */
-#define RING_SIZE(_r)                                                   \
-    ((_r)->nr_ents)
-
-/* Number of free requests (for use on front side only). */
-#define RING_FREE_REQUESTS(_r)                                          \
-    (RING_SIZE(_r) - ((_r)->req_prod_pvt - (_r)->rsp_cons))
-
-/* Test if there is an empty slot available on the front ring.
- * (This is only meaningful from the front. )
- */
-#define RING_FULL(_r)                                                   \
-    (RING_FREE_REQUESTS(_r) == 0)
-
-/* Test if there are outstanding messages to be processed on a ring. */
-#define RING_HAS_UNCONSUMED_RESPONSES(_r)                               \
-    ((_r)->sring->rsp_prod - (_r)->rsp_cons)
-
-#ifdef __GNUC__
-#define RING_HAS_UNCONSUMED_REQUESTS(_r) ({                             \
-    unsigned int req = (_r)->sring->req_prod - (_r)->req_cons;          \
-    unsigned int rsp = RING_SIZE(_r) -                                  \
-        ((_r)->req_cons - (_r)->rsp_prod_pvt);                          \
-    req < rsp ? req : rsp;                                              \
-})
-#else
-/* Same as above, but without the nice GCC ({ ... }) syntax. */
-#define RING_HAS_UNCONSUMED_REQUESTS(_r)                                \
-    ((((_r)->sring->req_prod - (_r)->req_cons) <                        \
-      (RING_SIZE(_r) - ((_r)->req_cons - (_r)->rsp_prod_pvt))) ?        \
-     ((_r)->sring->req_prod - (_r)->req_cons) :                         \
-     (RING_SIZE(_r) - ((_r)->req_cons - (_r)->rsp_prod_pvt)))
-#endif
-
-/* Direct access to individual ring elements, by index. */
-#define RING_GET_REQUEST(_r, _idx)                                      \
-    (&((_r)->sring->ring[((_idx) & (RING_SIZE(_r) - 1))].req))
-
-#define RING_GET_RESPONSE(_r, _idx)                                     \
-    (&((_r)->sring->ring[((_idx) & (RING_SIZE(_r) - 1))].rsp))
-
-/* Loop termination condition: Would the specified index overflow the ring? */
-#define RING_REQUEST_CONS_OVERFLOW(_r, _cons)                           \
-    (((_cons) - (_r)->rsp_prod_pvt) >= RING_SIZE(_r))
-
-#define RING_PUSH_REQUESTS(_r) do {                                     \
-    xen_wmb(); /* back sees requests /before/ updated producer index */ \
-    (_r)->sring->req_prod = (_r)->req_prod_pvt;                         \
-} while (0)
-
-#define RING_PUSH_RESPONSES(_r) do {                                    \
-    xen_wmb(); /* front sees resps /before/ updated producer index */   \
-    (_r)->sring->rsp_prod = (_r)->rsp_prod_pvt;                         \
-} while (0)
-
-/*
- * Notification hold-off (req_event and rsp_event):
- * 
- * When queueing requests or responses on a shared ring, it may not always be
- * necessary to notify the remote end. For example, if requests are in flight
- * in a backend, the front may be able to queue further requests without
- * notifying the back (if the back checks for new requests when it queues
- * responses).
- * 
- * When enqueuing requests or responses:
- * 
- *  Use RING_PUSH_{REQUESTS,RESPONSES}_AND_CHECK_NOTIFY(). The second argument
- *  is a boolean return value. True indicates that the receiver requires an
- *  asynchronous notification.
- * 
- * After dequeuing requests or responses (before sleeping the connection):
- * 
- *  Use RING_FINAL_CHECK_FOR_REQUESTS() or RING_FINAL_CHECK_FOR_RESPONSES().
- *  The second argument is a boolean return value. True indicates that there
- *  are pending messages on the ring (i.e., the connection should not be put
- *  to sleep).
- * 
- *  These macros will set the req_event/rsp_event field to trigger a
- *  notification on the very next message that is enqueued. If you want to
- *  create batches of work (i.e., only receive a notification after several
- *  messages have been enqueued) then you will need to create a customised
- *  version of the FINAL_CHECK macro in your own code, which sets the event
- *  field appropriately.
- */
-
-#define RING_PUSH_REQUESTS_AND_CHECK_NOTIFY(_r, _notify) do {           \
-    RING_IDX __old = (_r)->sring->req_prod;                             \
-    RING_IDX __new = (_r)->req_prod_pvt;                                \
-    xen_wmb(); /* back sees requests /before/ updated producer index */ \
-    (_r)->sring->req_prod = __new;                                      \
-    xen_mb(); /* back sees new requests /before/ we check req_event */  \
-    (_notify) = ((RING_IDX)(__new - (_r)->sring->req_event) <           \
-                 (RING_IDX)(__new - __old));                            \
-} while (0)
-
-#define RING_PUSH_RESPONSES_AND_CHECK_NOTIFY(_r, _notify) do {          \
-    RING_IDX __old = (_r)->sring->rsp_prod;                             \
-    RING_IDX __new = (_r)->rsp_prod_pvt;                                \
-    xen_wmb(); /* front sees resps /before/ updated producer index */   \
-    (_r)->sring->rsp_prod = __new;                                      \
-    xen_mb(); /* front sees new resps /before/ we check rsp_event */    \
-    (_notify) = ((RING_IDX)(__new - (_r)->sring->rsp_event) <           \
-                 (RING_IDX)(__new - __old));                            \
-} while (0)
-
-#define RING_FINAL_CHECK_FOR_REQUESTS(_r, _work_to_do) do {             \
-    (_work_to_do) = RING_HAS_UNCONSUMED_REQUESTS(_r);                   \
-    if (_work_to_do) break;                                             \
-    (_r)->sring->req_event = (_r)->req_cons + 1;                        \
-    xen_mb();                                                           \
-    (_work_to_do) = RING_HAS_UNCONSUMED_REQUESTS(_r);                   \
-} while (0)
-
-#define RING_FINAL_CHECK_FOR_RESPONSES(_r, _work_to_do) do {            \
-    (_work_to_do) = RING_HAS_UNCONSUMED_RESPONSES(_r);                  \
-    if (_work_to_do) break;                                             \
-    (_r)->sring->rsp_event = (_r)->rsp_cons + 1;                        \
-    xen_mb();                                                           \
-    (_work_to_do) = RING_HAS_UNCONSUMED_RESPONSES(_r);                  \
-} while (0)
-
-#endif /* __XEN_PUBLIC_IO_RING_H__ */
-
-/*
- * Local variables:
- * mode: C
- * c-set-style: "BSD"
- * c-basic-offset: 4
- * tab-width: 4
- * indent-tabs-mode: nil
- * End:
- */
diff -Nru xen-4.2.1-new/extras/mini-os/include/xen/io/tpmif.h xen-4.2.1/extras/mini-os/include/xen/io/tpmif.h
--- xen-4.2.1-new/extras/mini-os/include/xen/io/tpmif.h	2012-12-17 23:01:56.000000000 +0800
+++ xen-4.2.1/extras/mini-os/include/xen/io/tpmif.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,77 +0,0 @@
-/******************************************************************************
- * tpmif.h
- *
- * TPM I/O interface for Xen guest OSes.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- * Copyright (c) 2005, IBM Corporation
- *
- * Author: Stefan Berger, stefanb@us.ibm.com
- * Grant table support: Mahadevan Gomathisankaran
- *
- * This code has been derived from tools/libxc/xen/io/netif.h
- *
- * Copyright (c) 2003-2004, Keir Fraser
- */
-
-#ifndef __XEN_PUBLIC_IO_TPMIF_H__
-#define __XEN_PUBLIC_IO_TPMIF_H__
-
-#include "../grant_table.h"
-
-struct tpmif_tx_request {
-    unsigned long addr;   /* Machine address of packet.   */
-    grant_ref_t ref;      /* grant table access reference */
-    uint16_t unused;
-    uint16_t size;        /* Packet size in bytes.        */
-};
-typedef struct tpmif_tx_request tpmif_tx_request_t;
-
-/*
- * The TPMIF_TX_RING_SIZE defines the number of pages the
- * front-end and backend can exchange (= size of array).
- */
-typedef uint32_t TPMIF_RING_IDX;
-
-#define TPMIF_TX_RING_SIZE 1
-
-/* This structure must fit in a memory page. */
-
-struct tpmif_ring {
-    struct tpmif_tx_request req;
-};
-typedef struct tpmif_ring tpmif_ring_t;
-
-struct tpmif_tx_interface {
-    struct tpmif_ring ring[TPMIF_TX_RING_SIZE];
-};
-typedef struct tpmif_tx_interface tpmif_tx_interface_t;
-
-#endif
-
-/*
- * Local variables:
- * mode: C
- * c-set-style: "BSD"
- * c-basic-offset: 4
- * tab-width: 4
- * indent-tabs-mode: nil
- * End:
- */
diff -Nru xen-4.2.1-new/extras/mini-os/include/xen/io/usbif.h xen-4.2.1/extras/mini-os/include/xen/io/usbif.h
--- xen-4.2.1-new/extras/mini-os/include/xen/io/usbif.h	2012-12-17 23:01:56.000000000 +0800
+++ xen-4.2.1/extras/mini-os/include/xen/io/usbif.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,151 +0,0 @@
-/*
- * usbif.h
- *
- * USB I/O interface for Xen guest OSes.
- *
- * Copyright (C) 2009, FUJITSU LABORATORIES LTD.
- * Author: Noboru Iwamatsu <n_iwamatsu@jp.fujitsu.com>
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- */
-
-#ifndef __XEN_PUBLIC_IO_USBIF_H__
-#define __XEN_PUBLIC_IO_USBIF_H__
-
-#include "ring.h"
-#include "../grant_table.h"
-
-enum usb_spec_version {
-	USB_VER_UNKNOWN = 0,
-	USB_VER_USB11,
-	USB_VER_USB20,
-	USB_VER_USB30,	/* not supported yet */
-};
-
-/*
- *  USB pipe in usbif_request
- *
- *  bits 0-5 are specific bits for virtual USB driver.
- *  bits 7-31 are standard urb pipe.
- *
- *  - port number(NEW):	bits 0-4
- *  				(USB_MAXCHILDREN is 31)
- *
- *  - operation flag(NEW):	bit 5
- *  				(0 = submit urb,
- *  				 1 = unlink urb)
- *
- *  - direction:		bit 7
- *  				(0 = Host-to-Device [Out]
- *                           1 = Device-to-Host [In])
- *
- *  - device address:	bits 8-14
- *
- *  - endpoint:		bits 15-18
- *
- *  - pipe type:		bits 30-31
- *  				(00 = isochronous, 01 = interrupt,
- *                           10 = control, 11 = bulk)
- */
-#define usbif_pipeportnum(pipe) ((pipe) & 0x1f)
-#define usbif_setportnum_pipe(pipe, portnum) \
-	((pipe)|(portnum))
-
-#define usbif_pipeunlink(pipe) ((pipe) & 0x20)
-#define usbif_pipesubmit(pipe) (!usbif_pipeunlink(pipe))
-#define usbif_setunlink_pipe(pipe) ((pipe)|(0x20))
-
-#define USBIF_BACK_MAX_PENDING_REQS (128)
-#define USBIF_MAX_SEGMENTS_PER_REQUEST (16)
-
-/*
- * RING for transferring urbs.
- */
-struct usbif_request_segment {
-	grant_ref_t gref;
-	uint16_t offset;
-	uint16_t length;
-};
-
-struct usbif_urb_request {
-	uint16_t id; /* request id */
-	uint16_t nr_buffer_segs; /* number of urb->transfer_buffer segments */
-
-	/* basic urb parameter */
-	uint32_t pipe;
-	uint16_t transfer_flags;
-	uint16_t buffer_length;
-	union {
-		uint8_t ctrl[8]; /* setup_packet (Ctrl) */
-
-		struct {
-			uint16_t interval; /* maximum (1024*8) in usb core */
-			uint16_t start_frame; /* start frame */
-			uint16_t number_of_packets; /* number of ISO packet */
-			uint16_t nr_frame_desc_segs; /* number of iso_frame_desc segments */
-		} isoc;
-
-		struct {
-			uint16_t interval; /* maximum (1024*8) in usb core */
-			uint16_t pad[3];
-		} intr;
-
-		struct {
-			uint16_t unlink_id; /* unlink request id */
-			uint16_t pad[3];
-		} unlink;
-
-	} u;
-
-	/* urb data segments */
-	struct usbif_request_segment seg[USBIF_MAX_SEGMENTS_PER_REQUEST];
-};
-typedef struct usbif_urb_request usbif_urb_request_t;
-
-struct usbif_urb_response {
-	uint16_t id; /* request id */
-	uint16_t start_frame;  /* start frame (ISO) */
-	int32_t status; /* status (non-ISO) */
-	int32_t actual_length; /* actual transfer length */
-	int32_t error_count; /* number of ISO errors */
-};
-typedef struct usbif_urb_response usbif_urb_response_t;
-
-DEFINE_RING_TYPES(usbif_urb, struct usbif_urb_request, struct usbif_urb_response);
-#define USB_URB_RING_SIZE __CONST_RING_SIZE(usbif_urb, PAGE_SIZE)
-
-/*
- * RING for notifying connect/disconnect events to frontend
- */
-struct usbif_conn_request {
-	uint16_t id;
-};
-typedef struct usbif_conn_request usbif_conn_request_t;
-
-struct usbif_conn_response {
-	uint16_t id; /* request id */
-	uint8_t portnum; /* port number */
-	uint8_t speed; /* usb_device_speed */
-};
-typedef struct usbif_conn_response usbif_conn_response_t;
-
-DEFINE_RING_TYPES(usbif_conn, struct usbif_conn_request, struct usbif_conn_response);
-#define USB_CONN_RING_SIZE __CONST_RING_SIZE(usbif_conn, PAGE_SIZE)
-
-#endif /* __XEN_PUBLIC_IO_USBIF_H__ */
diff -Nru xen-4.2.1-new/extras/mini-os/include/xen/io/vscsiif.h xen-4.2.1/extras/mini-os/include/xen/io/vscsiif.h
--- xen-4.2.1-new/extras/mini-os/include/xen/io/vscsiif.h	2012-12-17 23:01:56.000000000 +0800
+++ xen-4.2.1/extras/mini-os/include/xen/io/vscsiif.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,105 +0,0 @@
-/******************************************************************************
- * vscsiif.h
- * 
- * Based on the blkif.h code.
- * 
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- * Copyright(c) FUJITSU Limited 2008.
- */
-
-#ifndef __XEN__PUBLIC_IO_SCSI_H__
-#define __XEN__PUBLIC_IO_SCSI_H__
-
-#include "ring.h"
-#include "../grant_table.h"
-
-/* command between backend and frontend */
-#define VSCSIIF_ACT_SCSI_CDB         1    /* SCSI CDB command */
-#define VSCSIIF_ACT_SCSI_ABORT       2    /* SCSI Device(Lun) Abort*/
-#define VSCSIIF_ACT_SCSI_RESET       3    /* SCSI Device(Lun) Reset*/
-
-
-#define VSCSIIF_BACK_MAX_PENDING_REQS    128
-
-/*
- * Maximum scatter/gather segments per request.
- *
- * Considering balance between allocating al least 16 "vscsiif_request"
- * structures on one page (4096bytes) and number of scatter gather 
- * needed, we decided to use 26 as a magic number.
- */
-#define VSCSIIF_SG_TABLESIZE             26
-
-/*
- * base on linux kernel 2.6.18
- */
-#define VSCSIIF_MAX_COMMAND_SIZE         16
-#define VSCSIIF_SENSE_BUFFERSIZE         96
-
-
-struct vscsiif_request {
-    uint16_t rqid;          /* private guest value, echoed in resp  */
-    uint8_t act;            /* command between backend and frontend */
-    uint8_t cmd_len;
-
-    uint8_t cmnd[VSCSIIF_MAX_COMMAND_SIZE];
-    uint16_t timeout_per_command;     /* The command is issued by twice 
-                                         the value in Backend. */
-    uint16_t channel, id, lun;
-    uint16_t padding;
-    uint8_t sc_data_direction;        /* for DMA_TO_DEVICE(1)
-                                         DMA_FROM_DEVICE(2)
-                                         DMA_NONE(3) requests  */
-    uint8_t nr_segments;              /* Number of pieces of scatter-gather */
-
-    struct scsiif_request_segment {
-        grant_ref_t gref;
-        uint16_t offset;
-        uint16_t length;
-    } seg[VSCSIIF_SG_TABLESIZE];
-    uint32_t reserved[3];
-};
-typedef struct vscsiif_request vscsiif_request_t;
-
-struct vscsiif_response {
-    uint16_t rqid;
-    uint8_t padding;
-    uint8_t sense_len;
-    uint8_t sense_buffer[VSCSIIF_SENSE_BUFFERSIZE];
-    int32_t rslt;
-    uint32_t residual_len;     /* request bufflen - 
-                                  return the value from physical device */
-    uint32_t reserved[36];
-};
-typedef struct vscsiif_response vscsiif_response_t;
-
-DEFINE_RING_TYPES(vscsiif, struct vscsiif_request, struct vscsiif_response);
-
-
-#endif  /*__XEN__PUBLIC_IO_SCSI_H__*/
-/*
- * Local variables:
- * mode: C
- * c-set-style: "BSD"
- * c-basic-offset: 4
- * tab-width: 4
- * indent-tabs-mode: nil
- * End:
- */
diff -Nru xen-4.2.1-new/extras/mini-os/include/xen/io/xenbus.h xen-4.2.1/extras/mini-os/include/xen/io/xenbus.h
--- xen-4.2.1-new/extras/mini-os/include/xen/io/xenbus.h	2012-12-17 23:01:56.000000000 +0800
+++ xen-4.2.1/extras/mini-os/include/xen/io/xenbus.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,80 +0,0 @@
-/*****************************************************************************
- * xenbus.h
- *
- * Xenbus protocol details.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- * Copyright (C) 2005 XenSource Ltd.
- */
-
-#ifndef _XEN_PUBLIC_IO_XENBUS_H
-#define _XEN_PUBLIC_IO_XENBUS_H
-
-/*
- * The state of either end of the Xenbus, i.e. the current communication
- * status of initialisation across the bus.  States here imply nothing about
- * the state of the connection between the driver and the kernel's device
- * layers.
- */
-enum xenbus_state {
-    XenbusStateUnknown       = 0,
-
-    XenbusStateInitialising  = 1,
-
-    /*
-     * InitWait: Finished early initialisation but waiting for information
-     * from the peer or hotplug scripts.
-     */
-    XenbusStateInitWait      = 2,
-
-    /*
-     * Initialised: Waiting for a connection from the peer.
-     */
-    XenbusStateInitialised   = 3,
-
-    XenbusStateConnected     = 4,
-
-    /*
-     * Closing: The device is being closed due to an error or an unplug event.
-     */
-    XenbusStateClosing       = 5,
-
-    XenbusStateClosed        = 6,
-
-    /*
-     * Reconfiguring: The device is being reconfigured.
-     */
-    XenbusStateReconfiguring = 7,
-
-    XenbusStateReconfigured  = 8
-};
-typedef enum xenbus_state XenbusState;
-
-#endif /* _XEN_PUBLIC_IO_XENBUS_H */
-
-/*
- * Local variables:
- * mode: C
- * c-set-style: "BSD"
- * c-basic-offset: 4
- * tab-width: 4
- * indent-tabs-mode: nil
- * End:
- */
diff -Nru xen-4.2.1-new/extras/mini-os/include/xen/io/xs_wire.h xen-4.2.1/extras/mini-os/include/xen/io/xs_wire.h
--- xen-4.2.1-new/extras/mini-os/include/xen/io/xs_wire.h	2012-12-17 23:01:56.000000000 +0800
+++ xen-4.2.1/extras/mini-os/include/xen/io/xs_wire.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,134 +0,0 @@
-/*
- * Details of the "wire" protocol between Xen Store Daemon and client
- * library or guest kernel.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- * Copyright (C) 2005 Rusty Russell IBM Corporation
- */
-
-#ifndef _XS_WIRE_H
-#define _XS_WIRE_H
-
-enum xsd_sockmsg_type
-{
-    XS_DEBUG,
-    XS_DIRECTORY,
-    XS_READ,
-    XS_GET_PERMS,
-    XS_WATCH,
-    XS_UNWATCH,
-    XS_TRANSACTION_START,
-    XS_TRANSACTION_END,
-    XS_INTRODUCE,
-    XS_RELEASE,
-    XS_GET_DOMAIN_PATH,
-    XS_WRITE,
-    XS_MKDIR,
-    XS_RM,
-    XS_SET_PERMS,
-    XS_WATCH_EVENT,
-    XS_ERROR,
-    XS_IS_DOMAIN_INTRODUCED,
-    XS_RESUME,
-    XS_SET_TARGET,
-    XS_RESTRICT,
-    XS_RESET_WATCHES
-};
-
-#define XS_WRITE_NONE "NONE"
-#define XS_WRITE_CREATE "CREATE"
-#define XS_WRITE_CREATE_EXCL "CREATE|EXCL"
-
-/* We hand errors as strings, for portability. */
-struct xsd_errors
-{
-    int errnum;
-    const char *errstring;
-};
-#ifdef EINVAL
-#define XSD_ERROR(x) { x, #x }
-/* LINTED: static unused */
-static struct xsd_errors xsd_errors[]
-#if defined(__GNUC__)
-__attribute__((unused))
-#endif
-    = {
-    XSD_ERROR(EINVAL),
-    XSD_ERROR(EACCES),
-    XSD_ERROR(EEXIST),
-    XSD_ERROR(EISDIR),
-    XSD_ERROR(ENOENT),
-    XSD_ERROR(ENOMEM),
-    XSD_ERROR(ENOSPC),
-    XSD_ERROR(EIO),
-    XSD_ERROR(ENOTEMPTY),
-    XSD_ERROR(ENOSYS),
-    XSD_ERROR(EROFS),
-    XSD_ERROR(EBUSY),
-    XSD_ERROR(EAGAIN),
-    XSD_ERROR(EISCONN)
-};
-#endif
-
-struct xsd_sockmsg
-{
-    uint32_t type;  /* XS_??? */
-    uint32_t req_id;/* Request identifier, echoed in daemon's response.  */
-    uint32_t tx_id; /* Transaction id (0 if not related to a transaction). */
-    uint32_t len;   /* Length of data following this. */
-
-    /* Generally followed by nul-terminated string(s). */
-};
-
-enum xs_watch_type
-{
-    XS_WATCH_PATH = 0,
-    XS_WATCH_TOKEN
-};
-
-/* Inter-domain shared memory communications. */
-#define XENSTORE_RING_SIZE 1024
-typedef uint32_t XENSTORE_RING_IDX;
-#define MASK_XENSTORE_IDX(idx) ((idx) & (XENSTORE_RING_SIZE-1))
-struct xenstore_domain_interface {
-    char req[XENSTORE_RING_SIZE]; /* Requests to xenstore daemon. */
-    char rsp[XENSTORE_RING_SIZE]; /* Replies and async watch events. */
-    XENSTORE_RING_IDX req_cons, req_prod;
-    XENSTORE_RING_IDX rsp_cons, rsp_prod;
-};
-
-/* Violating this is very bad.  See docs/misc/xenstore.txt. */
-#define XENSTORE_PAYLOAD_MAX 4096
-
-/* Violating these just gets you an error back */
-#define XENSTORE_ABS_PATH_MAX 3072
-#define XENSTORE_REL_PATH_MAX 2048
-
-#endif /* _XS_WIRE_H */
-
-/*
- * Local variables:
- * mode: C
- * c-set-style: "BSD"
- * c-basic-offset: 4
- * tab-width: 4
- * indent-tabs-mode: nil
- * End:
- */
diff -Nru xen-4.2.1-new/extras/mini-os/include/xen/kexec.h xen-4.2.1/extras/mini-os/include/xen/kexec.h
--- xen-4.2.1-new/extras/mini-os/include/xen/kexec.h	2014-08-23 21:01:22.000000000 +0800
+++ xen-4.2.1/extras/mini-os/include/xen/kexec.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,168 +0,0 @@
-/******************************************************************************
- * kexec.h - Public portion
- * 
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- * 
- * Xen port written by:
- * - Simon 'Horms' Horman <horms@verge.net.au>
- * - Magnus Damm <magnus@valinux.co.jp>
- */
-
-#ifndef _XEN_PUBLIC_KEXEC_H
-#define _XEN_PUBLIC_KEXEC_H
-
-
-/* This file describes the Kexec / Kdump hypercall interface for Xen.
- *
- * Kexec under vanilla Linux allows a user to reboot the physical machine 
- * into a new user-specified kernel. The Xen port extends this idea
- * to allow rebooting of the machine from dom0. When kexec for dom0
- * is used to reboot,  both the hypervisor and the domains get replaced
- * with some other kernel. It is possible to kexec between vanilla
- * Linux and Xen and back again. Xen to Xen works well too.
- *
- * The hypercall interface for kexec can be divided into three main
- * types of hypercall operations:
- *
- * 1) Range information:
- *    This is used by the dom0 kernel to ask the hypervisor about various 
- *    address information. This information is needed to allow kexec-tools 
- *    to fill in the ELF headers for /proc/vmcore properly.
- *
- * 2) Load and unload of images:
- *    There are no big surprises here, the kexec binary from kexec-tools
- *    runs in userspace in dom0. The tool loads/unloads data into the
- *    dom0 kernel such as new kernel, initramfs and hypervisor. When
- *    loaded the dom0 kernel performs a load hypercall operation, and
- *    before releasing all page references the dom0 kernel calls unload.
- *
- * 3) Kexec operation:
- *    This is used to start a previously loaded kernel.
- */
-
-#include "xen.h"
-
-#if defined(__i386__) || defined(__x86_64__)
-#define KEXEC_XEN_NO_PAGES 17
-#endif
-
-/*
- * Prototype for this hypercall is:
- *  int kexec_op(int cmd, void *args)
- * @cmd  == KEXEC_CMD_... 
- *          KEXEC operation to perform
- * @args == Operation-specific extra arguments (NULL if none).
- */
-
-/*
- * Kexec supports two types of operation:
- * - kexec into a regular kernel, very similar to a standard reboot
- *   - KEXEC_TYPE_DEFAULT is used to specify this type
- * - kexec into a special "crash kernel", aka kexec-on-panic
- *   - KEXEC_TYPE_CRASH is used to specify this type
- *   - parts of our system may be broken at kexec-on-panic time
- *     - the code should be kept as simple and self-contained as possible
- */
-
-#define KEXEC_TYPE_DEFAULT 0
-#define KEXEC_TYPE_CRASH   1
-
-
-/* The kexec implementation for Xen allows the user to load two
- * types of kernels, KEXEC_TYPE_DEFAULT and KEXEC_TYPE_CRASH.
- * All data needed for a kexec reboot is kept in one xen_kexec_image_t
- * per "instance". The data mainly consists of machine address lists to pages
- * together with destination addresses. The data in xen_kexec_image_t
- * is passed to the "code page" which is one page of code that performs
- * the final relocations before jumping to the new kernel.
- */
- 
-typedef struct xen_kexec_image {
-#if defined(__i386__) || defined(__x86_64__)
-    unsigned long page_list[KEXEC_XEN_NO_PAGES];
-#endif
-#if defined(__ia64__)
-    unsigned long reboot_code_buffer;
-#endif
-    unsigned long indirection_page;
-    unsigned long start_address;
-} xen_kexec_image_t;
-
-/*
- * Perform kexec having previously loaded a kexec or kdump kernel
- * as appropriate.
- * type == KEXEC_TYPE_DEFAULT or KEXEC_TYPE_CRASH [in]
- */
-#define KEXEC_CMD_kexec                 0
-typedef struct xen_kexec_exec {
-    int type;
-} xen_kexec_exec_t;
-
-/*
- * Load/Unload kernel image for kexec or kdump.
- * type  == KEXEC_TYPE_DEFAULT or KEXEC_TYPE_CRASH [in]
- * image == relocation information for kexec (ignored for unload) [in]
- */
-#define KEXEC_CMD_kexec_load            1
-#define KEXEC_CMD_kexec_unload          2
-typedef struct xen_kexec_load {
-    int type;
-    xen_kexec_image_t image;
-} xen_kexec_load_t;
-
-#define KEXEC_RANGE_MA_CRASH      0 /* machine address and size of crash area */
-#define KEXEC_RANGE_MA_XEN        1 /* machine address and size of Xen itself */
-#define KEXEC_RANGE_MA_CPU        2 /* machine address and size of a CPU note */
-#define KEXEC_RANGE_MA_XENHEAP    3 /* machine address and size of xenheap
-                                     * Note that although this is adjacent
-                                     * to Xen it exists in a separate EFI
-                                     * region on ia64, and thus needs to be
-                                     * inserted into iomem_machine separately */
-#define KEXEC_RANGE_MA_BOOT_PARAM 4 /* machine address and size of
-                                     * the ia64_boot_param */
-#define KEXEC_RANGE_MA_EFI_MEMMAP 5 /* machine address and size of
-                                     * of the EFI Memory Map */
-#define KEXEC_RANGE_MA_VMCOREINFO 6 /* machine address and size of vmcoreinfo */
-
-/*
- * Find the address and size of certain memory areas
- * range == KEXEC_RANGE_... [in]
- * nr    == physical CPU number (starting from 0) if KEXEC_RANGE_MA_CPU [in]
- * size  == number of bytes reserved in window [out]
- * start == address of the first byte in the window [out]
- */
-#define KEXEC_CMD_kexec_get_range       3
-typedef struct xen_kexec_range {
-    int range;
-    int nr;
-    unsigned long size;
-    unsigned long start;
-} xen_kexec_range_t;
-
-#endif /* _XEN_PUBLIC_KEXEC_H */
-
-/*
- * Local variables:
- * mode: C
- * c-set-style: "BSD"
- * c-basic-offset: 4
- * tab-width: 4
- * indent-tabs-mode: nil
- * End:
- */
diff -Nru xen-4.2.1-new/extras/mini-os/include/xen/mem_event.h xen-4.2.1/extras/mini-os/include/xen/mem_event.h
--- xen-4.2.1-new/extras/mini-os/include/xen/mem_event.h	2014-08-23 21:01:22.000000000 +0800
+++ xen-4.2.1/extras/mini-os/include/xen/mem_event.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,80 +0,0 @@
-/******************************************************************************
- * mem_event.h
- *
- * Memory event common structures.
- *
- * Copyright (c) 2009 by Citrix Systems, Inc. (Patrick Colp)
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- */
-
-#ifndef _XEN_PUBLIC_MEM_EVENT_H
-#define _XEN_PUBLIC_MEM_EVENT_H
-
-#include "xen.h"
-#include "io/ring.h"
-
-/* Memory event flags */
-#define MEM_EVENT_FLAG_VCPU_PAUSED  (1 << 0)
-#define MEM_EVENT_FLAG_DROP_PAGE    (1 << 1)
-#define MEM_EVENT_FLAG_EVICT_FAIL   (1 << 2)
-#define MEM_EVENT_FLAG_FOREIGN      (1 << 3)
-#define MEM_EVENT_FLAG_DUMMY        (1 << 4)
-
-/* Reasons for the memory event request */
-#define MEM_EVENT_REASON_UNKNOWN     0    /* typical reason */
-#define MEM_EVENT_REASON_VIOLATION   1    /* access violation, GFN is address */
-#define MEM_EVENT_REASON_CR0         2    /* CR0 was hit: gfn is CR0 value */
-#define MEM_EVENT_REASON_CR3         3    /* CR3 was hit: gfn is CR3 value */
-#define MEM_EVENT_REASON_CR4         4    /* CR4 was hit: gfn is CR4 value */
-#define MEM_EVENT_REASON_INT3        5    /* int3 was hit: gla/gfn are RIP */
-#define MEM_EVENT_REASON_SINGLESTEP  6    /* single step was invoked: gla/gfn are RIP */
-
-typedef struct mem_event_st {
-    uint32_t flags;
-    uint32_t vcpu_id;
-
-    uint64_t gfn;
-    uint64_t offset;
-    uint64_t gla; /* if gla_valid */
-
-    uint32_t p2mt;
-
-    uint16_t access_r:1;
-    uint16_t access_w:1;
-    uint16_t access_x:1;
-    uint16_t gla_valid:1;
-    uint16_t available:12;
-
-    uint16_t reason;
-} mem_event_request_t, mem_event_response_t;
-
-DEFINE_RING_TYPES(mem_event, mem_event_request_t, mem_event_response_t);
-
-#endif
-
-/*
- * Local variables:
- * mode: C
- * c-set-style: "BSD"
- * c-basic-offset: 4
- * tab-width: 4
- * indent-tabs-mode: nil
- * End:
- */
diff -Nru xen-4.2.1-new/extras/mini-os/include/xen/memory.h xen-4.2.1/extras/mini-os/include/xen/memory.h
--- xen-4.2.1-new/extras/mini-os/include/xen/memory.h	2014-08-23 21:01:22.000000000 +0800
+++ xen-4.2.1/extras/mini-os/include/xen/memory.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,412 +0,0 @@
-/******************************************************************************
- * memory.h
- * 
- * Memory reservation and information.
- * 
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- * Copyright (c) 2005, Keir Fraser <keir@xensource.com>
- */
-
-#ifndef __XEN_PUBLIC_MEMORY_H__
-#define __XEN_PUBLIC_MEMORY_H__
-
-#include "xen.h"
-
-/*
- * Increase or decrease the specified domain's memory reservation. Returns the
- * number of extents successfully allocated or freed.
- * arg == addr of struct xen_memory_reservation.
- */
-#define XENMEM_increase_reservation 0
-#define XENMEM_decrease_reservation 1
-#define XENMEM_populate_physmap     6
-
-#if __XEN_INTERFACE_VERSION__ >= 0x00030209
-/*
- * Maximum # bits addressable by the user of the allocated region (e.g., I/O 
- * devices often have a 32-bit limitation even in 64-bit systems). If zero 
- * then the user has no addressing restriction. This field is not used by 
- * XENMEM_decrease_reservation.
- */
-#define XENMEMF_address_bits(x)     (x)
-#define XENMEMF_get_address_bits(x) ((x) & 0xffu)
-/* NUMA node to allocate from. */
-#define XENMEMF_node(x)     (((x) + 1) << 8)
-#define XENMEMF_get_node(x) ((((x) >> 8) - 1) & 0xffu)
-/* Flag to populate physmap with populate-on-demand entries */
-#define XENMEMF_populate_on_demand (1<<16)
-/* Flag to request allocation only from the node specified */
-#define XENMEMF_exact_node_request  (1<<17)
-#define XENMEMF_exact_node(n) (XENMEMF_node(n) | XENMEMF_exact_node_request)
-#endif
-
-struct xen_memory_reservation {
-
-    /*
-     * XENMEM_increase_reservation:
-     *   OUT: MFN (*not* GMFN) bases of extents that were allocated
-     * XENMEM_decrease_reservation:
-     *   IN:  GMFN bases of extents to free
-     * XENMEM_populate_physmap:
-     *   IN:  GPFN bases of extents to populate with memory
-     *   OUT: GMFN bases of extents that were allocated
-     *   (NB. This command also updates the mach_to_phys translation table)
-     */
-    XEN_GUEST_HANDLE(xen_pfn_t) extent_start;
-
-    /* Number of extents, and size/alignment of each (2^extent_order pages). */
-    xen_ulong_t    nr_extents;
-    unsigned int   extent_order;
-
-#if __XEN_INTERFACE_VERSION__ >= 0x00030209
-    /* XENMEMF flags. */
-    unsigned int   mem_flags;
-#else
-    unsigned int   address_bits;
-#endif
-
-    /*
-     * Domain whose reservation is being changed.
-     * Unprivileged domains can specify only DOMID_SELF.
-     */
-    domid_t        domid;
-};
-typedef struct xen_memory_reservation xen_memory_reservation_t;
-DEFINE_XEN_GUEST_HANDLE(xen_memory_reservation_t);
-
-/*
- * An atomic exchange of memory pages. If return code is zero then
- * @out.extent_list provides GMFNs of the newly-allocated memory.
- * Returns zero on complete success, otherwise a negative error code.
- * On complete success then always @nr_exchanged == @in.nr_extents.
- * On partial success @nr_exchanged indicates how much work was done.
- */
-#define XENMEM_exchange             11
-struct xen_memory_exchange {
-    /*
-     * [IN] Details of memory extents to be exchanged (GMFN bases).
-     * Note that @in.address_bits is ignored and unused.
-     */
-    struct xen_memory_reservation in;
-
-    /*
-     * [IN/OUT] Details of new memory extents.
-     * We require that:
-     *  1. @in.domid == @out.domid
-     *  2. @in.nr_extents  << @in.extent_order == 
-     *     @out.nr_extents << @out.extent_order
-     *  3. @in.extent_start and @out.extent_start lists must not overlap
-     *  4. @out.extent_start lists GPFN bases to be populated
-     *  5. @out.extent_start is overwritten with allocated GMFN bases
-     */
-    struct xen_memory_reservation out;
-
-    /*
-     * [OUT] Number of input extents that were successfully exchanged:
-     *  1. The first @nr_exchanged input extents were successfully
-     *     deallocated.
-     *  2. The corresponding first entries in the output extent list correctly
-     *     indicate the GMFNs that were successfully exchanged.
-     *  3. All other input and output extents are untouched.
-     *  4. If not all input exents are exchanged then the return code of this
-     *     command will be non-zero.
-     *  5. THIS FIELD MUST BE INITIALISED TO ZERO BY THE CALLER!
-     */
-    xen_ulong_t nr_exchanged;
-};
-typedef struct xen_memory_exchange xen_memory_exchange_t;
-DEFINE_XEN_GUEST_HANDLE(xen_memory_exchange_t);
-
-/*
- * Returns the maximum machine frame number of mapped RAM in this system.
- * This command always succeeds (it never returns an error code).
- * arg == NULL.
- */
-#define XENMEM_maximum_ram_page     2
-
-/*
- * Returns the current or maximum memory reservation, in pages, of the
- * specified domain (may be DOMID_SELF). Returns -ve errcode on failure.
- * arg == addr of domid_t.
- */
-#define XENMEM_current_reservation  3
-#define XENMEM_maximum_reservation  4
-
-/*
- * Returns the maximum GPFN in use by the guest, or -ve errcode on failure.
- */
-#define XENMEM_maximum_gpfn         14
-
-/*
- * Returns a list of MFN bases of 2MB extents comprising the machine_to_phys
- * mapping table. Architectures which do not have a m2p table do not implement
- * this command.
- * arg == addr of xen_machphys_mfn_list_t.
- */
-#define XENMEM_machphys_mfn_list    5
-struct xen_machphys_mfn_list {
-    /*
-     * Size of the 'extent_start' array. Fewer entries will be filled if the
-     * machphys table is smaller than max_extents * 2MB.
-     */
-    unsigned int max_extents;
-
-    /*
-     * Pointer to buffer to fill with list of extent starts. If there are
-     * any large discontiguities in the machine address space, 2MB gaps in
-     * the machphys table will be represented by an MFN base of zero.
-     */
-    XEN_GUEST_HANDLE(xen_pfn_t) extent_start;
-
-    /*
-     * Number of extents written to the above array. This will be smaller
-     * than 'max_extents' if the machphys table is smaller than max_e * 2MB.
-     */
-    unsigned int nr_extents;
-};
-typedef struct xen_machphys_mfn_list xen_machphys_mfn_list_t;
-DEFINE_XEN_GUEST_HANDLE(xen_machphys_mfn_list_t);
-
-/*
- * Returns the location in virtual address space of the machine_to_phys
- * mapping table. Architectures which do not have a m2p table, or which do not
- * map it by default into guest address space, do not implement this command.
- * arg == addr of xen_machphys_mapping_t.
- */
-#define XENMEM_machphys_mapping     12
-struct xen_machphys_mapping {
-    xen_ulong_t v_start, v_end; /* Start and end virtual addresses.   */
-    xen_ulong_t max_mfn;        /* Maximum MFN that can be looked up. */
-};
-typedef struct xen_machphys_mapping xen_machphys_mapping_t;
-DEFINE_XEN_GUEST_HANDLE(xen_machphys_mapping_t);
-
-/*
- * Sets the GPFN at which a particular page appears in the specified guest's
- * pseudophysical address space.
- * arg == addr of xen_add_to_physmap_t.
- */
-#define XENMEM_add_to_physmap      7
-struct xen_add_to_physmap {
-    /* Which domain to change the mapping for. */
-    domid_t domid;
-
-    /* Number of pages to go through for gmfn_range */
-    uint16_t    size;
-
-    /* Source mapping space. */
-#define XENMAPSPACE_shared_info 0 /* shared info page */
-#define XENMAPSPACE_grant_table 1 /* grant table page */
-#define XENMAPSPACE_gmfn        2 /* GMFN */
-#define XENMAPSPACE_gmfn_range  3 /* GMFN range */
-    unsigned int space;
-
-#define XENMAPIDX_grant_table_status 0x80000000
-
-    /* Index into source mapping space. */
-    xen_ulong_t idx;
-
-    /* GPFN where the source mapping page should appear. */
-    xen_pfn_t     gpfn;
-};
-typedef struct xen_add_to_physmap xen_add_to_physmap_t;
-DEFINE_XEN_GUEST_HANDLE(xen_add_to_physmap_t);
-
-/*
- * Unmaps the page appearing at a particular GPFN from the specified guest's
- * pseudophysical address space.
- * arg == addr of xen_remove_from_physmap_t.
- */
-#define XENMEM_remove_from_physmap      15
-struct xen_remove_from_physmap {
-    /* Which domain to change the mapping for. */
-    domid_t domid;
-
-    /* GPFN of the current mapping of the page. */
-    xen_pfn_t     gpfn;
-};
-typedef struct xen_remove_from_physmap xen_remove_from_physmap_t;
-DEFINE_XEN_GUEST_HANDLE(xen_remove_from_physmap_t);
-
-/*** REMOVED ***/
-/*#define XENMEM_translate_gpfn_list  8*/
-
-/*
- * Returns the pseudo-physical memory map as it was when the domain
- * was started (specified by XENMEM_set_memory_map).
- * arg == addr of xen_memory_map_t.
- */
-#define XENMEM_memory_map           9
-struct xen_memory_map {
-    /*
-     * On call the number of entries which can be stored in buffer. On
-     * return the number of entries which have been stored in
-     * buffer.
-     */
-    unsigned int nr_entries;
-
-    /*
-     * Entries in the buffer are in the same format as returned by the
-     * BIOS INT 0x15 EAX=0xE820 call.
-     */
-    XEN_GUEST_HANDLE(void) buffer;
-};
-typedef struct xen_memory_map xen_memory_map_t;
-DEFINE_XEN_GUEST_HANDLE(xen_memory_map_t);
-
-/*
- * Returns the real physical memory map. Passes the same structure as
- * XENMEM_memory_map.
- * arg == addr of xen_memory_map_t.
- */
-#define XENMEM_machine_memory_map   10
-
-/*
- * Set the pseudo-physical memory map of a domain, as returned by
- * XENMEM_memory_map.
- * arg == addr of xen_foreign_memory_map_t.
- */
-#define XENMEM_set_memory_map       13
-struct xen_foreign_memory_map {
-    domid_t domid;
-    struct xen_memory_map map;
-};
-typedef struct xen_foreign_memory_map xen_foreign_memory_map_t;
-DEFINE_XEN_GUEST_HANDLE(xen_foreign_memory_map_t);
-
-#define XENMEM_set_pod_target       16
-#define XENMEM_get_pod_target       17
-struct xen_pod_target {
-    /* IN */
-    uint64_t target_pages;
-    /* OUT */
-    uint64_t tot_pages;
-    uint64_t pod_cache_pages;
-    uint64_t pod_entries;
-    /* IN */
-    domid_t domid;
-};
-typedef struct xen_pod_target xen_pod_target_t;
-
-#if defined(__XEN__) || defined(__XEN_TOOLS__)
-
-#ifndef uint64_aligned_t
-#define uint64_aligned_t uint64_t
-#endif
-
-/*
- * Get the number of MFNs saved through memory sharing.
- * The call never fails. 
- */
-#define XENMEM_get_sharing_freed_pages    18
-#define XENMEM_get_sharing_shared_pages   19
-
-#define XENMEM_paging_op                    20
-#define XENMEM_paging_op_nominate           0
-#define XENMEM_paging_op_evict              1
-#define XENMEM_paging_op_prep               2
-
-#define XENMEM_access_op                    21
-#define XENMEM_access_op_resume             0
-
-struct xen_mem_event_op {
-    uint8_t     op;         /* XENMEM_*_op_* */
-    domid_t     domain;
-    
-
-    /* PAGING_PREP IN: buffer to immediately fill page in */
-    uint64_aligned_t    buffer;
-    /* Other OPs */
-    uint64_aligned_t    gfn;           /* IN:  gfn of page being operated on */
-};
-typedef struct xen_mem_event_op xen_mem_event_op_t;
-DEFINE_XEN_GUEST_HANDLE(xen_mem_event_op_t);
-
-#define XENMEM_sharing_op                   22
-#define XENMEM_sharing_op_nominate_gfn      0
-#define XENMEM_sharing_op_nominate_gref     1
-#define XENMEM_sharing_op_share             2
-#define XENMEM_sharing_op_resume            3
-#define XENMEM_sharing_op_debug_gfn         4
-#define XENMEM_sharing_op_debug_mfn         5
-#define XENMEM_sharing_op_debug_gref        6
-#define XENMEM_sharing_op_add_physmap       7
-#define XENMEM_sharing_op_audit             8
-
-#define XENMEM_SHARING_OP_S_HANDLE_INVALID  (-10)
-#define XENMEM_SHARING_OP_C_HANDLE_INVALID  (-9)
-
-/* The following allows sharing of grant refs. This is useful
- * for sharing utilities sitting as "filters" in IO backends
- * (e.g. memshr + blktap(2)). The IO backend is only exposed 
- * to grant references, and this allows sharing of the grefs */
-#define XENMEM_SHARING_OP_FIELD_IS_GREF_FLAG   (1ULL << 62)
-
-#define XENMEM_SHARING_OP_FIELD_MAKE_GREF(field, val)  \
-    (field) = (XENMEM_SHARING_OP_FIELD_IS_GREF_FLAG | val)
-#define XENMEM_SHARING_OP_FIELD_IS_GREF(field)         \
-    ((field) & XENMEM_SHARING_OP_FIELD_IS_GREF_FLAG)
-#define XENMEM_SHARING_OP_FIELD_GET_GREF(field)        \
-    ((field) & (~XENMEM_SHARING_OP_FIELD_IS_GREF_FLAG))
-
-struct xen_mem_sharing_op {
-    uint8_t     op;     /* XENMEM_sharing_op_* */
-    domid_t     domain;
-
-    union {
-        struct mem_sharing_op_nominate {  /* OP_NOMINATE_xxx           */
-            union {
-                uint64_aligned_t gfn;     /* IN: gfn to nominate       */
-                uint32_t      grant_ref;  /* IN: grant ref to nominate */
-            } u;
-            uint64_aligned_t  handle;     /* OUT: the handle           */
-        } nominate;
-        struct mem_sharing_op_share {     /* OP_SHARE/ADD_PHYSMAP */
-            uint64_aligned_t source_gfn;    /* IN: the gfn of the source page */
-            uint64_aligned_t source_handle; /* IN: handle to the source page */
-            uint64_aligned_t client_gfn;    /* IN: the client gfn */
-            uint64_aligned_t client_handle; /* IN: handle to the client page */
-            domid_t  client_domain; /* IN: the client domain id */
-        } share; 
-        struct mem_sharing_op_debug {     /* OP_DEBUG_xxx */
-            union {
-                uint64_aligned_t gfn;      /* IN: gfn to debug          */
-                uint64_aligned_t mfn;      /* IN: mfn to debug          */
-                uint32_t gref;     /* IN: gref to debug         */
-            } u;
-        } debug;
-    } u;
-};
-typedef struct xen_mem_sharing_op xen_mem_sharing_op_t;
-DEFINE_XEN_GUEST_HANDLE(xen_mem_sharing_op_t);
-
-#endif /* defined(__XEN__) || defined(__XEN_TOOLS__) */
-
-#endif /* __XEN_PUBLIC_MEMORY_H__ */
-
-/*
- * Local variables:
- * mode: C
- * c-set-style: "BSD"
- * c-basic-offset: 4
- * tab-width: 4
- * indent-tabs-mode: nil
- * End:
- */
diff -Nru xen-4.2.1-new/extras/mini-os/include/xen/nmi.h xen-4.2.1/extras/mini-os/include/xen/nmi.h
--- xen-4.2.1-new/extras/mini-os/include/xen/nmi.h	2014-08-23 21:01:22.000000000 +0800
+++ xen-4.2.1/extras/mini-os/include/xen/nmi.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,80 +0,0 @@
-/******************************************************************************
- * nmi.h
- * 
- * NMI callback registration and reason codes.
- * 
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- * Copyright (c) 2005, Keir Fraser <keir@xensource.com>
- */
-
-#ifndef __XEN_PUBLIC_NMI_H__
-#define __XEN_PUBLIC_NMI_H__
-
-#include "xen.h"
-
-/*
- * NMI reason codes:
- * Currently these are x86-specific, stored in arch_shared_info.nmi_reason.
- */
- /* I/O-check error reported via ISA port 0x61, bit 6. */
-#define _XEN_NMIREASON_io_error     0
-#define XEN_NMIREASON_io_error      (1UL << _XEN_NMIREASON_io_error)
- /* Parity error reported via ISA port 0x61, bit 7. */
-#define _XEN_NMIREASON_parity_error 1
-#define XEN_NMIREASON_parity_error  (1UL << _XEN_NMIREASON_parity_error)
- /* Unknown hardware-generated NMI. */
-#define _XEN_NMIREASON_unknown      2
-#define XEN_NMIREASON_unknown       (1UL << _XEN_NMIREASON_unknown)
-
-/*
- * long nmi_op(unsigned int cmd, void *arg)
- * NB. All ops return zero on success, else a negative error code.
- */
-
-/*
- * Register NMI callback for this (calling) VCPU. Currently this only makes
- * sense for domain 0, vcpu 0. All other callers will be returned EINVAL.
- * arg == pointer to xennmi_callback structure.
- */
-#define XENNMI_register_callback   0
-struct xennmi_callback {
-    unsigned long handler_address;
-    unsigned long pad;
-};
-typedef struct xennmi_callback xennmi_callback_t;
-DEFINE_XEN_GUEST_HANDLE(xennmi_callback_t);
-
-/*
- * Deregister NMI callback for this (calling) VCPU.
- * arg == NULL.
- */
-#define XENNMI_unregister_callback 1
-
-#endif /* __XEN_PUBLIC_NMI_H__ */
-
-/*
- * Local variables:
- * mode: C
- * c-set-style: "BSD"
- * c-basic-offset: 4
- * tab-width: 4
- * indent-tabs-mode: nil
- * End:
- */
diff -Nru xen-4.2.1-new/extras/mini-os/include/xen/physdev.h xen-4.2.1/extras/mini-os/include/xen/physdev.h
--- xen-4.2.1-new/extras/mini-os/include/xen/physdev.h	2014-08-23 21:01:22.000000000 +0800
+++ xen-4.2.1/extras/mini-os/include/xen/physdev.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,352 +0,0 @@
-/*
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- */
-
-#ifndef __XEN_PUBLIC_PHYSDEV_H__
-#define __XEN_PUBLIC_PHYSDEV_H__
-
-#include "xen.h"
-
-/*
- * Prototype for this hypercall is:
- *  int physdev_op(int cmd, void *args)
- * @cmd  == PHYSDEVOP_??? (physdev operation).
- * @args == Operation-specific extra arguments (NULL if none).
- */
-
-/*
- * Notify end-of-interrupt (EOI) for the specified IRQ.
- * @arg == pointer to physdev_eoi structure.
- */
-#define PHYSDEVOP_eoi                   12
-struct physdev_eoi {
-    /* IN */
-    uint32_t irq;
-};
-typedef struct physdev_eoi physdev_eoi_t;
-DEFINE_XEN_GUEST_HANDLE(physdev_eoi_t);
-
-/*
- * Register a shared page for the hypervisor to indicate whether the guest
- * must issue PHYSDEVOP_eoi. The semantics of PHYSDEVOP_eoi change slightly
- * once the guest used this function in that the associated event channel
- * will automatically get unmasked. The page registered is used as a bit
- * array indexed by Xen's PIRQ value.
- */
-#define PHYSDEVOP_pirq_eoi_gmfn_v1       17
-/*
- * Register a shared page for the hypervisor to indicate whether the
- * guest must issue PHYSDEVOP_eoi. This hypercall is very similar to
- * PHYSDEVOP_pirq_eoi_gmfn_v1 but it doesn't change the semantics of
- * PHYSDEVOP_eoi. The page registered is used as a bit array indexed by
- * Xen's PIRQ value.
- */
-#define PHYSDEVOP_pirq_eoi_gmfn_v2       28
-struct physdev_pirq_eoi_gmfn {
-    /* IN */
-    xen_pfn_t gmfn;
-};
-typedef struct physdev_pirq_eoi_gmfn physdev_pirq_eoi_gmfn_t;
-DEFINE_XEN_GUEST_HANDLE(physdev_pirq_eoi_gmfn_t);
-
-/*
- * Query the status of an IRQ line.
- * @arg == pointer to physdev_irq_status_query structure.
- */
-#define PHYSDEVOP_irq_status_query       5
-struct physdev_irq_status_query {
-    /* IN */
-    uint32_t irq;
-    /* OUT */
-    uint32_t flags; /* XENIRQSTAT_* */
-};
-typedef struct physdev_irq_status_query physdev_irq_status_query_t;
-DEFINE_XEN_GUEST_HANDLE(physdev_irq_status_query_t);
-
-/* Need to call PHYSDEVOP_eoi when the IRQ has been serviced? */
-#define _XENIRQSTAT_needs_eoi   (0)
-#define  XENIRQSTAT_needs_eoi   (1U<<_XENIRQSTAT_needs_eoi)
-
-/* IRQ shared by multiple guests? */
-#define _XENIRQSTAT_shared      (1)
-#define  XENIRQSTAT_shared      (1U<<_XENIRQSTAT_shared)
-
-/*
- * Set the current VCPU's I/O privilege level.
- * @arg == pointer to physdev_set_iopl structure.
- */
-#define PHYSDEVOP_set_iopl               6
-struct physdev_set_iopl {
-    /* IN */
-    uint32_t iopl;
-};
-typedef struct physdev_set_iopl physdev_set_iopl_t;
-DEFINE_XEN_GUEST_HANDLE(physdev_set_iopl_t);
-
-/*
- * Set the current VCPU's I/O-port permissions bitmap.
- * @arg == pointer to physdev_set_iobitmap structure.
- */
-#define PHYSDEVOP_set_iobitmap           7
-struct physdev_set_iobitmap {
-    /* IN */
-#if __XEN_INTERFACE_VERSION__ >= 0x00030205
-    XEN_GUEST_HANDLE(uint8) bitmap;
-#else
-    uint8_t *bitmap;
-#endif
-    uint32_t nr_ports;
-};
-typedef struct physdev_set_iobitmap physdev_set_iobitmap_t;
-DEFINE_XEN_GUEST_HANDLE(physdev_set_iobitmap_t);
-
-/*
- * Read or write an IO-APIC register.
- * @arg == pointer to physdev_apic structure.
- */
-#define PHYSDEVOP_apic_read              8
-#define PHYSDEVOP_apic_write             9
-struct physdev_apic {
-    /* IN */
-    unsigned long apic_physbase;
-    uint32_t reg;
-    /* IN or OUT */
-    uint32_t value;
-};
-typedef struct physdev_apic physdev_apic_t;
-DEFINE_XEN_GUEST_HANDLE(physdev_apic_t);
-
-/*
- * Allocate or free a physical upcall vector for the specified IRQ line.
- * @arg == pointer to physdev_irq structure.
- */
-#define PHYSDEVOP_alloc_irq_vector      10
-#define PHYSDEVOP_free_irq_vector       11
-struct physdev_irq {
-    /* IN */
-    uint32_t irq;
-    /* IN or OUT */
-    uint32_t vector;
-};
-typedef struct physdev_irq physdev_irq_t;
-DEFINE_XEN_GUEST_HANDLE(physdev_irq_t);
- 
-#define MAP_PIRQ_TYPE_MSI               0x0
-#define MAP_PIRQ_TYPE_GSI               0x1
-#define MAP_PIRQ_TYPE_UNKNOWN           0x2
-#define MAP_PIRQ_TYPE_MSI_SEG           0x3
-
-#define PHYSDEVOP_map_pirq               13
-struct physdev_map_pirq {
-    domid_t domid;
-    /* IN */
-    int type;
-    /* IN */
-    int index;
-    /* IN or OUT */
-    int pirq;
-    /* IN - high 16 bits hold segment for MAP_PIRQ_TYPE_MSI_SEG */
-    int bus;
-    /* IN */
-    int devfn;
-    /* IN */
-    int entry_nr;
-    /* IN */
-    uint64_t table_base;
-};
-typedef struct physdev_map_pirq physdev_map_pirq_t;
-DEFINE_XEN_GUEST_HANDLE(physdev_map_pirq_t);
-
-#define PHYSDEVOP_unmap_pirq             14
-struct physdev_unmap_pirq {
-    domid_t domid;
-    /* IN */
-    int pirq;
-};
-
-typedef struct physdev_unmap_pirq physdev_unmap_pirq_t;
-DEFINE_XEN_GUEST_HANDLE(physdev_unmap_pirq_t);
-
-#define PHYSDEVOP_manage_pci_add         15
-#define PHYSDEVOP_manage_pci_remove      16
-struct physdev_manage_pci {
-    /* IN */
-    uint8_t bus;
-    uint8_t devfn;
-}; 
-
-typedef struct physdev_manage_pci physdev_manage_pci_t;
-DEFINE_XEN_GUEST_HANDLE(physdev_manage_pci_t);
-
-#define PHYSDEVOP_restore_msi            19
-struct physdev_restore_msi {
-    /* IN */
-    uint8_t bus;
-    uint8_t devfn;
-};
-typedef struct physdev_restore_msi physdev_restore_msi_t;
-DEFINE_XEN_GUEST_HANDLE(physdev_restore_msi_t);
-
-#define PHYSDEVOP_manage_pci_add_ext     20
-struct physdev_manage_pci_ext {
-    /* IN */
-    uint8_t bus;
-    uint8_t devfn;
-    unsigned is_extfn;
-    unsigned is_virtfn;
-    struct {
-        uint8_t bus;
-        uint8_t devfn;
-    } physfn;
-};
-
-typedef struct physdev_manage_pci_ext physdev_manage_pci_ext_t;
-DEFINE_XEN_GUEST_HANDLE(physdev_manage_pci_ext_t);
-
-/*
- * Argument to physdev_op_compat() hypercall. Superceded by new physdev_op()
- * hypercall since 0x00030202.
- */
-struct physdev_op {
-    uint32_t cmd;
-    union {
-        struct physdev_irq_status_query      irq_status_query;
-        struct physdev_set_iopl              set_iopl;
-        struct physdev_set_iobitmap          set_iobitmap;
-        struct physdev_apic                  apic_op;
-        struct physdev_irq                   irq_op;
-    } u;
-};
-typedef struct physdev_op physdev_op_t;
-DEFINE_XEN_GUEST_HANDLE(physdev_op_t);
-
-#define PHYSDEVOP_setup_gsi    21
-struct physdev_setup_gsi {
-    int gsi;
-    /* IN */
-    uint8_t triggering;
-    /* IN */
-    uint8_t polarity;
-    /* IN */
-};
-
-typedef struct physdev_setup_gsi physdev_setup_gsi_t;
-DEFINE_XEN_GUEST_HANDLE(physdev_setup_gsi_t);
-
-/* leave PHYSDEVOP 22 free */
-
-/* type is MAP_PIRQ_TYPE_GSI or MAP_PIRQ_TYPE_MSI
- * the hypercall returns a free pirq */
-#define PHYSDEVOP_get_free_pirq    23
-struct physdev_get_free_pirq {
-    /* IN */ 
-    int type;
-    /* OUT */
-    uint32_t pirq;
-};
-
-typedef struct physdev_get_free_pirq physdev_get_free_pirq_t;
-DEFINE_XEN_GUEST_HANDLE(physdev_get_free_pirq_t);
-
-#define XEN_PCI_MMCFG_RESERVED         0x1
-
-#define PHYSDEVOP_pci_mmcfg_reserved    24
-struct physdev_pci_mmcfg_reserved {
-    uint64_t address;
-    uint16_t segment;
-    uint8_t start_bus;
-    uint8_t end_bus;
-    uint32_t flags;
-};
-typedef struct physdev_pci_mmcfg_reserved physdev_pci_mmcfg_reserved_t;
-DEFINE_XEN_GUEST_HANDLE(physdev_pci_mmcfg_reserved_t);
-
-#define XEN_PCI_DEV_EXTFN              0x1
-#define XEN_PCI_DEV_VIRTFN             0x2
-#define XEN_PCI_DEV_PXM                0x4
-
-#define PHYSDEVOP_pci_device_add        25
-struct physdev_pci_device_add {
-    /* IN */
-    uint16_t seg;
-    uint8_t bus;
-    uint8_t devfn;
-    uint32_t flags;
-    struct {
-        uint8_t bus;
-        uint8_t devfn;
-    } physfn;
-#if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
-    uint32_t optarr[];
-#elif defined(__GNUC__)
-    uint32_t optarr[0];
-#endif
-};
-typedef struct physdev_pci_device_add physdev_pci_device_add_t;
-DEFINE_XEN_GUEST_HANDLE(physdev_pci_device_add_t);
-
-#define PHYSDEVOP_pci_device_remove     26
-#define PHYSDEVOP_restore_msi_ext       27
-struct physdev_pci_device {
-    /* IN */
-    uint16_t seg;
-    uint8_t bus;
-    uint8_t devfn;
-};
-typedef struct physdev_pci_device physdev_pci_device_t;
-DEFINE_XEN_GUEST_HANDLE(physdev_pci_device_t);
-
-/*
- * Notify that some PIRQ-bound event channels have been unmasked.
- * ** This command is obsolete since interface version 0x00030202 and is **
- * ** unsupported by newer versions of Xen.                              **
- */
-#define PHYSDEVOP_IRQ_UNMASK_NOTIFY      4
-
-/*
- * These all-capitals physdev operation names are superceded by the new names
- * (defined above) since interface version 0x00030202.
- */
-#define PHYSDEVOP_IRQ_STATUS_QUERY       PHYSDEVOP_irq_status_query
-#define PHYSDEVOP_SET_IOPL               PHYSDEVOP_set_iopl
-#define PHYSDEVOP_SET_IOBITMAP           PHYSDEVOP_set_iobitmap
-#define PHYSDEVOP_APIC_READ              PHYSDEVOP_apic_read
-#define PHYSDEVOP_APIC_WRITE             PHYSDEVOP_apic_write
-#define PHYSDEVOP_ASSIGN_VECTOR          PHYSDEVOP_alloc_irq_vector
-#define PHYSDEVOP_FREE_VECTOR            PHYSDEVOP_free_irq_vector
-#define PHYSDEVOP_IRQ_NEEDS_UNMASK_NOTIFY XENIRQSTAT_needs_eoi
-#define PHYSDEVOP_IRQ_SHARED             XENIRQSTAT_shared
-
-#if __XEN_INTERFACE_VERSION__ < 0x00040200
-#define PHYSDEVOP_pirq_eoi_gmfn PHYSDEVOP_pirq_eoi_gmfn_v1
-#else
-#define PHYSDEVOP_pirq_eoi_gmfn PHYSDEVOP_pirq_eoi_gmfn_v2
-#endif
-
-#endif /* __XEN_PUBLIC_PHYSDEV_H__ */
-
-/*
- * Local variables:
- * mode: C
- * c-set-style: "BSD"
- * c-basic-offset: 4
- * tab-width: 4
- * indent-tabs-mode: nil
- * End:
- */
diff -Nru xen-4.2.1-new/extras/mini-os/include/xen/platform.h xen-4.2.1/extras/mini-os/include/xen/platform.h
--- xen-4.2.1-new/extras/mini-os/include/xen/platform.h	2014-08-23 21:01:22.000000000 +0800
+++ xen-4.2.1/extras/mini-os/include/xen/platform.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,549 +0,0 @@
-/******************************************************************************
- * platform.h
- * 
- * Hardware platform operations. Intended for use by domain-0 kernel.
- * 
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- * Copyright (c) 2002-2006, K Fraser
- */
-
-#ifndef __XEN_PUBLIC_PLATFORM_H__
-#define __XEN_PUBLIC_PLATFORM_H__
-
-#include "xen.h"
-
-#define XENPF_INTERFACE_VERSION 0x03000001
-
-/*
- * Set clock such that it would read <secs,nsecs> after 00:00:00 UTC,
- * 1 January, 1970 if the current system time was <system_time>.
- */
-#define XENPF_settime             17
-struct xenpf_settime {
-    /* IN variables. */
-    uint32_t secs;
-    uint32_t nsecs;
-    uint64_t system_time;
-};
-typedef struct xenpf_settime xenpf_settime_t;
-DEFINE_XEN_GUEST_HANDLE(xenpf_settime_t);
-
-/*
- * Request memory range (@mfn, @mfn+@nr_mfns-1) to have type @type.
- * On x86, @type is an architecture-defined MTRR memory type.
- * On success, returns the MTRR that was used (@reg) and a handle that can
- * be passed to XENPF_DEL_MEMTYPE to accurately tear down the new setting.
- * (x86-specific).
- */
-#define XENPF_add_memtype         31
-struct xenpf_add_memtype {
-    /* IN variables. */
-    xen_pfn_t mfn;
-    uint64_t nr_mfns;
-    uint32_t type;
-    /* OUT variables. */
-    uint32_t handle;
-    uint32_t reg;
-};
-typedef struct xenpf_add_memtype xenpf_add_memtype_t;
-DEFINE_XEN_GUEST_HANDLE(xenpf_add_memtype_t);
-
-/*
- * Tear down an existing memory-range type. If @handle is remembered then it
- * should be passed in to accurately tear down the correct setting (in case
- * of overlapping memory regions with differing types). If it is not known
- * then @handle should be set to zero. In all cases @reg must be set.
- * (x86-specific).
- */
-#define XENPF_del_memtype         32
-struct xenpf_del_memtype {
-    /* IN variables. */
-    uint32_t handle;
-    uint32_t reg;
-};
-typedef struct xenpf_del_memtype xenpf_del_memtype_t;
-DEFINE_XEN_GUEST_HANDLE(xenpf_del_memtype_t);
-
-/* Read current type of an MTRR (x86-specific). */
-#define XENPF_read_memtype        33
-struct xenpf_read_memtype {
-    /* IN variables. */
-    uint32_t reg;
-    /* OUT variables. */
-    xen_pfn_t mfn;
-    uint64_t nr_mfns;
-    uint32_t type;
-};
-typedef struct xenpf_read_memtype xenpf_read_memtype_t;
-DEFINE_XEN_GUEST_HANDLE(xenpf_read_memtype_t);
-
-#define XENPF_microcode_update    35
-struct xenpf_microcode_update {
-    /* IN variables. */
-    XEN_GUEST_HANDLE(const_void) data;/* Pointer to microcode data */
-    uint32_t length;                  /* Length of microcode data. */
-};
-typedef struct xenpf_microcode_update xenpf_microcode_update_t;
-DEFINE_XEN_GUEST_HANDLE(xenpf_microcode_update_t);
-
-#define XENPF_platform_quirk      39
-#define QUIRK_NOIRQBALANCING      1 /* Do not restrict IO-APIC RTE targets */
-#define QUIRK_IOAPIC_BAD_REGSEL   2 /* IO-APIC REGSEL forgets its value    */
-#define QUIRK_IOAPIC_GOOD_REGSEL  3 /* IO-APIC REGSEL behaves properly     */
-struct xenpf_platform_quirk {
-    /* IN variables. */
-    uint32_t quirk_id;
-};
-typedef struct xenpf_platform_quirk xenpf_platform_quirk_t;
-DEFINE_XEN_GUEST_HANDLE(xenpf_platform_quirk_t);
-
-#define XENPF_efi_runtime_call    49
-#define XEN_EFI_get_time                      1
-#define XEN_EFI_set_time                      2
-#define XEN_EFI_get_wakeup_time               3
-#define XEN_EFI_set_wakeup_time               4
-#define XEN_EFI_get_next_high_monotonic_count 5
-#define XEN_EFI_get_variable                  6
-#define XEN_EFI_set_variable                  7
-#define XEN_EFI_get_next_variable_name        8
-#define XEN_EFI_query_variable_info           9
-#define XEN_EFI_query_capsule_capabilities   10
-#define XEN_EFI_update_capsule               11
-struct xenpf_efi_runtime_call {
-    uint32_t function;
-    /*
-     * This field is generally used for per sub-function flags (defined
-     * below), except for the XEN_EFI_get_next_high_monotonic_count case,
-     * where it holds the single returned value.
-     */
-    uint32_t misc;
-    unsigned long status;
-    union {
-#define XEN_EFI_GET_TIME_SET_CLEARS_NS 0x00000001
-        struct {
-            struct xenpf_efi_time {
-                uint16_t year;
-                uint8_t month;
-                uint8_t day;
-                uint8_t hour;
-                uint8_t min;
-                uint8_t sec;
-                uint32_t ns;
-                int16_t tz;
-                uint8_t daylight;
-            } time;
-            uint32_t resolution;
-            uint32_t accuracy;
-        } get_time;
-
-        struct xenpf_efi_time set_time;
-
-#define XEN_EFI_GET_WAKEUP_TIME_ENABLED 0x00000001
-#define XEN_EFI_GET_WAKEUP_TIME_PENDING 0x00000002
-        struct xenpf_efi_time get_wakeup_time;
-
-#define XEN_EFI_SET_WAKEUP_TIME_ENABLE      0x00000001
-#define XEN_EFI_SET_WAKEUP_TIME_ENABLE_ONLY 0x00000002
-        struct xenpf_efi_time set_wakeup_time;
-
-#define XEN_EFI_VARIABLE_NON_VOLATILE       0x00000001
-#define XEN_EFI_VARIABLE_BOOTSERVICE_ACCESS 0x00000002
-#define XEN_EFI_VARIABLE_RUNTIME_ACCESS     0x00000004
-        struct {
-            XEN_GUEST_HANDLE(void) name;  /* UCS-2/UTF-16 string */
-            unsigned long size;
-            XEN_GUEST_HANDLE(void) data;
-            struct xenpf_efi_guid {
-                uint32_t data1;
-                uint16_t data2;
-                uint16_t data3;
-                uint8_t data4[8];
-            } vendor_guid;
-        } get_variable, set_variable;
-
-        struct {
-            unsigned long size;
-            XEN_GUEST_HANDLE(void) name;  /* UCS-2/UTF-16 string */
-            struct xenpf_efi_guid vendor_guid;
-        } get_next_variable_name;
-
-        struct {
-            uint32_t attr;
-            uint64_t max_store_size;
-            uint64_t remain_store_size;
-            uint64_t max_size;
-        } query_variable_info;
-
-        struct {
-            XEN_GUEST_HANDLE(void) capsule_header_array;
-            unsigned long capsule_count;
-            uint64_t max_capsule_size;
-            unsigned int reset_type;
-        } query_capsule_capabilities;
-
-        struct {
-            XEN_GUEST_HANDLE(void) capsule_header_array;
-            unsigned long capsule_count;
-            uint64_t sg_list; /* machine address */
-        } update_capsule;
-    } u;
-};
-typedef struct xenpf_efi_runtime_call xenpf_efi_runtime_call_t;
-DEFINE_XEN_GUEST_HANDLE(xenpf_efi_runtime_call_t);
-
-#define XENPF_firmware_info       50
-#define XEN_FW_DISK_INFO          1 /* from int 13 AH=08/41/48 */
-#define XEN_FW_DISK_MBR_SIGNATURE 2 /* from MBR offset 0x1b8 */
-#define XEN_FW_VBEDDC_INFO        3 /* from int 10 AX=4f15 */
-#define XEN_FW_EFI_INFO           4 /* from EFI */
-#define  XEN_FW_EFI_VERSION        0
-#define  XEN_FW_EFI_CONFIG_TABLE   1
-#define  XEN_FW_EFI_VENDOR         2
-#define  XEN_FW_EFI_MEM_INFO       3
-#define  XEN_FW_EFI_RT_VERSION     4
-struct xenpf_firmware_info {
-    /* IN variables. */
-    uint32_t type;
-    uint32_t index;
-    /* OUT variables. */
-    union {
-        struct {
-            /* Int13, Fn48: Check Extensions Present. */
-            uint8_t device;                   /* %dl: bios device number */
-            uint8_t version;                  /* %ah: major version      */
-            uint16_t interface_support;       /* %cx: support bitmap     */
-            /* Int13, Fn08: Legacy Get Device Parameters. */
-            uint16_t legacy_max_cylinder;     /* %cl[7:6]:%ch: max cyl # */
-            uint8_t legacy_max_head;          /* %dh: max head #         */
-            uint8_t legacy_sectors_per_track; /* %cl[5:0]: max sector #  */
-            /* Int13, Fn41: Get Device Parameters (as filled into %ds:%esi). */
-            /* NB. First uint16_t of buffer must be set to buffer size.      */
-            XEN_GUEST_HANDLE(void) edd_params;
-        } disk_info; /* XEN_FW_DISK_INFO */
-        struct {
-            uint8_t device;                   /* bios device number  */
-            uint32_t mbr_signature;           /* offset 0x1b8 in mbr */
-        } disk_mbr_signature; /* XEN_FW_DISK_MBR_SIGNATURE */
-        struct {
-            /* Int10, AX=4F15: Get EDID info. */
-            uint8_t capabilities;
-            uint8_t edid_transfer_time;
-            /* must refer to 128-byte buffer */
-            XEN_GUEST_HANDLE(uint8) edid;
-        } vbeddc_info; /* XEN_FW_VBEDDC_INFO */
-        union xenpf_efi_info {
-            uint32_t version;
-            struct {
-                uint64_t addr;                /* EFI_CONFIGURATION_TABLE */
-                uint32_t nent;
-            } cfg;
-            struct {
-                uint32_t revision;
-                uint32_t bufsz;               /* input, in bytes */
-                XEN_GUEST_HANDLE(void) name;  /* UCS-2/UTF-16 string */
-            } vendor;
-            struct {
-                uint64_t addr;
-                uint64_t size;
-                uint64_t attr;
-                uint32_t type;
-            } mem;
-        } efi_info; /* XEN_FW_EFI_INFO */
-    } u;
-};
-typedef struct xenpf_firmware_info xenpf_firmware_info_t;
-DEFINE_XEN_GUEST_HANDLE(xenpf_firmware_info_t);
-
-#define XENPF_enter_acpi_sleep    51
-struct xenpf_enter_acpi_sleep {
-    /* IN variables */
-    uint16_t pm1a_cnt_val;      /* PM1a control value. */
-    uint16_t pm1b_cnt_val;      /* PM1b control value. */
-    uint32_t sleep_state;       /* Which state to enter (Sn). */
-    uint32_t flags;             /* Must be zero. */
-};
-typedef struct xenpf_enter_acpi_sleep xenpf_enter_acpi_sleep_t;
-DEFINE_XEN_GUEST_HANDLE(xenpf_enter_acpi_sleep_t);
-
-#define XENPF_change_freq         52
-struct xenpf_change_freq {
-    /* IN variables */
-    uint32_t flags; /* Must be zero. */
-    uint32_t cpu;   /* Physical cpu. */
-    uint64_t freq;  /* New frequency (Hz). */
-};
-typedef struct xenpf_change_freq xenpf_change_freq_t;
-DEFINE_XEN_GUEST_HANDLE(xenpf_change_freq_t);
-
-/*
- * Get idle times (nanoseconds since boot) for physical CPUs specified in the
- * @cpumap_bitmap with range [0..@cpumap_nr_cpus-1]. The @idletime array is
- * indexed by CPU number; only entries with the corresponding @cpumap_bitmap
- * bit set are written to. On return, @cpumap_bitmap is modified so that any
- * non-existent CPUs are cleared. Such CPUs have their @idletime array entry
- * cleared.
- */
-#define XENPF_getidletime         53
-struct xenpf_getidletime {
-    /* IN/OUT variables */
-    /* IN: CPUs to interrogate; OUT: subset of IN which are present */
-    XEN_GUEST_HANDLE(uint8) cpumap_bitmap;
-    /* IN variables */
-    /* Size of cpumap bitmap. */
-    uint32_t cpumap_nr_cpus;
-    /* Must be indexable for every cpu in cpumap_bitmap. */
-    XEN_GUEST_HANDLE(uint64) idletime;
-    /* OUT variables */
-    /* System time when the idletime snapshots were taken. */
-    uint64_t now;
-};
-typedef struct xenpf_getidletime xenpf_getidletime_t;
-DEFINE_XEN_GUEST_HANDLE(xenpf_getidletime_t);
-
-#define XENPF_set_processor_pminfo      54
-
-/* ability bits */
-#define XEN_PROCESSOR_PM_CX	1
-#define XEN_PROCESSOR_PM_PX	2
-#define XEN_PROCESSOR_PM_TX	4
-
-/* cmd type */
-#define XEN_PM_CX   0
-#define XEN_PM_PX   1
-#define XEN_PM_TX   2
-#define XEN_PM_PDC  3
-
-/* Px sub info type */
-#define XEN_PX_PCT   1
-#define XEN_PX_PSS   2
-#define XEN_PX_PPC   4
-#define XEN_PX_PSD   8
-
-struct xen_power_register {
-    uint32_t     space_id;
-    uint32_t     bit_width;
-    uint32_t     bit_offset;
-    uint32_t     access_size;
-    uint64_t     address;
-};
-
-struct xen_processor_csd {
-    uint32_t    domain;      /* domain number of one dependent group */
-    uint32_t    coord_type;  /* coordination type */
-    uint32_t    num;         /* number of processors in same domain */
-};
-typedef struct xen_processor_csd xen_processor_csd_t;
-DEFINE_XEN_GUEST_HANDLE(xen_processor_csd_t);
-
-struct xen_processor_cx {
-    struct xen_power_register  reg; /* GAS for Cx trigger register */
-    uint8_t     type;     /* cstate value, c0: 0, c1: 1, ... */
-    uint32_t    latency;  /* worst latency (ms) to enter/exit this cstate */
-    uint32_t    power;    /* average power consumption(mW) */
-    uint32_t    dpcnt;    /* number of dependency entries */
-    XEN_GUEST_HANDLE(xen_processor_csd_t) dp; /* NULL if no dependency */
-};
-typedef struct xen_processor_cx xen_processor_cx_t;
-DEFINE_XEN_GUEST_HANDLE(xen_processor_cx_t);
-
-struct xen_processor_flags {
-    uint32_t bm_control:1;
-    uint32_t bm_check:1;
-    uint32_t has_cst:1;
-    uint32_t power_setup_done:1;
-    uint32_t bm_rld_set:1;
-};
-
-struct xen_processor_power {
-    uint32_t count;  /* number of C state entries in array below */
-    struct xen_processor_flags flags;  /* global flags of this processor */
-    XEN_GUEST_HANDLE(xen_processor_cx_t) states; /* supported c states */
-};
-
-struct xen_pct_register {
-    uint8_t  descriptor;
-    uint16_t length;
-    uint8_t  space_id;
-    uint8_t  bit_width;
-    uint8_t  bit_offset;
-    uint8_t  reserved;
-    uint64_t address;
-};
-
-struct xen_processor_px {
-    uint64_t core_frequency; /* megahertz */
-    uint64_t power;      /* milliWatts */
-    uint64_t transition_latency; /* microseconds */
-    uint64_t bus_master_latency; /* microseconds */
-    uint64_t control;        /* control value */
-    uint64_t status;     /* success indicator */
-};
-typedef struct xen_processor_px xen_processor_px_t;
-DEFINE_XEN_GUEST_HANDLE(xen_processor_px_t);
-
-struct xen_psd_package {
-    uint64_t num_entries;
-    uint64_t revision;
-    uint64_t domain;
-    uint64_t coord_type;
-    uint64_t num_processors;
-};
-
-struct xen_processor_performance {
-    uint32_t flags;     /* flag for Px sub info type */
-    uint32_t platform_limit;  /* Platform limitation on freq usage */
-    struct xen_pct_register control_register;
-    struct xen_pct_register status_register;
-    uint32_t state_count;     /* total available performance states */
-    XEN_GUEST_HANDLE(xen_processor_px_t) states;
-    struct xen_psd_package domain_info;
-    uint32_t shared_type;     /* coordination type of this processor */
-};
-typedef struct xen_processor_performance xen_processor_performance_t;
-DEFINE_XEN_GUEST_HANDLE(xen_processor_performance_t);
-
-struct xenpf_set_processor_pminfo {
-    /* IN variables */
-    uint32_t id;    /* ACPI CPU ID */
-    uint32_t type;  /* {XEN_PM_CX, XEN_PM_PX} */
-    union {
-        struct xen_processor_power          power;/* Cx: _CST/_CSD */
-        struct xen_processor_performance    perf; /* Px: _PPC/_PCT/_PSS/_PSD */
-        XEN_GUEST_HANDLE(uint32)            pdc;  /* _PDC */
-    } u;
-};
-typedef struct xenpf_set_processor_pminfo xenpf_set_processor_pminfo_t;
-DEFINE_XEN_GUEST_HANDLE(xenpf_set_processor_pminfo_t);
-
-#define XENPF_get_cpuinfo 55
-struct xenpf_pcpuinfo {
-    /* IN */
-    uint32_t xen_cpuid;
-    /* OUT */
-    /* The maxium cpu_id that is present */
-    uint32_t max_present;
-#define XEN_PCPU_FLAGS_ONLINE   1
-    /* Correponding xen_cpuid is not present*/
-#define XEN_PCPU_FLAGS_INVALID  2
-    uint32_t flags;
-    uint32_t apic_id;
-    uint32_t acpi_id;
-};
-typedef struct xenpf_pcpuinfo xenpf_pcpuinfo_t;
-DEFINE_XEN_GUEST_HANDLE(xenpf_pcpuinfo_t);
-
-#define XENPF_get_cpu_version 48
-struct xenpf_pcpu_version {
-    /* IN */
-    uint32_t xen_cpuid;
-    /* OUT */
-    /* The maxium cpu_id that is present */
-    uint32_t max_present;
-    char vendor_id[12];
-    uint32_t family;
-    uint32_t model;
-    uint32_t stepping;
-};
-typedef struct xenpf_pcpu_version xenpf_pcpu_version_t;
-DEFINE_XEN_GUEST_HANDLE(xenpf_pcpu_version_t);
-
-#define XENPF_cpu_online    56
-#define XENPF_cpu_offline   57
-struct xenpf_cpu_ol
-{
-    uint32_t cpuid;
-};
-typedef struct xenpf_cpu_ol xenpf_cpu_ol_t;
-DEFINE_XEN_GUEST_HANDLE(xenpf_cpu_ol_t);
-
-#define XENPF_cpu_hotadd    58
-struct xenpf_cpu_hotadd
-{
-	uint32_t apic_id;
-	uint32_t acpi_id;
-	uint32_t pxm;
-};
-
-#define XENPF_mem_hotadd    59
-struct xenpf_mem_hotadd
-{
-    uint64_t spfn;
-    uint64_t epfn;
-    uint32_t pxm;
-    uint32_t flags;
-};
-
-#define XENPF_core_parking  60
-
-#define XEN_CORE_PARKING_SET 1
-#define XEN_CORE_PARKING_GET 2
-struct xenpf_core_parking {
-    /* IN variables */
-    uint32_t type;
-    /* IN variables:  set cpu nums expected to be idled */
-    /* OUT variables: get cpu nums actually be idled */
-    uint32_t idle_nums;
-};
-typedef struct xenpf_core_parking xenpf_core_parking_t;
-DEFINE_XEN_GUEST_HANDLE(xenpf_core_parking_t);
-
-/*
- * ` enum neg_errnoval
- * ` HYPERVISOR_platform_op(const struct xen_platform_op*);
- */
-struct xen_platform_op {
-    uint32_t cmd;
-    uint32_t interface_version; /* XENPF_INTERFACE_VERSION */
-    union {
-        struct xenpf_settime           settime;
-        struct xenpf_add_memtype       add_memtype;
-        struct xenpf_del_memtype       del_memtype;
-        struct xenpf_read_memtype      read_memtype;
-        struct xenpf_microcode_update  microcode;
-        struct xenpf_platform_quirk    platform_quirk;
-        struct xenpf_efi_runtime_call  efi_runtime_call;
-        struct xenpf_firmware_info     firmware_info;
-        struct xenpf_enter_acpi_sleep  enter_acpi_sleep;
-        struct xenpf_change_freq       change_freq;
-        struct xenpf_getidletime       getidletime;
-        struct xenpf_set_processor_pminfo set_pminfo;
-        struct xenpf_pcpuinfo          pcpu_info;
-        struct xenpf_pcpu_version      pcpu_version;
-        struct xenpf_cpu_ol            cpu_ol;
-        struct xenpf_cpu_hotadd        cpu_add;
-        struct xenpf_mem_hotadd        mem_add;
-        struct xenpf_core_parking      core_parking;
-        uint8_t                        pad[128];
-    } u;
-};
-typedef struct xen_platform_op xen_platform_op_t;
-DEFINE_XEN_GUEST_HANDLE(xen_platform_op_t);
-
-#endif /* __XEN_PUBLIC_PLATFORM_H__ */
-
-/*
- * Local variables:
- * mode: C
- * c-set-style: "BSD"
- * c-basic-offset: 4
- * tab-width: 4
- * indent-tabs-mode: nil
- * End:
- */
diff -Nru xen-4.2.1-new/extras/mini-os/include/xen/sched.h xen-4.2.1/extras/mini-os/include/xen/sched.h
--- xen-4.2.1-new/extras/mini-os/include/xen/sched.h	2014-08-23 21:01:22.000000000 +0800
+++ xen-4.2.1/extras/mini-os/include/xen/sched.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,145 +0,0 @@
-/******************************************************************************
- * sched.h
- * 
- * Scheduler state interactions
- * 
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- * Copyright (c) 2005, Keir Fraser <keir@xensource.com>
- */
-
-#ifndef __XEN_PUBLIC_SCHED_H__
-#define __XEN_PUBLIC_SCHED_H__
-
-#include "event_channel.h"
-
-/*
- * The prototype for this hypercall is:
- *  long sched_op(int cmd, void *arg)
- * @cmd == SCHEDOP_??? (scheduler operation).
- * @arg == Operation-specific extra argument(s), as described below.
- * 
- * Versions of Xen prior to 3.0.2 provided only the following legacy version
- * of this hypercall, supporting only the commands yield, block and shutdown:
- *  long sched_op(int cmd, unsigned long arg)
- * @cmd == SCHEDOP_??? (scheduler operation).
- * @arg == 0               (SCHEDOP_yield and SCHEDOP_block)
- *      == SHUTDOWN_* code (SCHEDOP_shutdown)
- * This legacy version is available to new guests as sched_op_compat().
- */
-
-/*
- * Voluntarily yield the CPU.
- * @arg == NULL.
- */
-#define SCHEDOP_yield       0
-
-/*
- * Block execution of this VCPU until an event is received for processing.
- * If called with event upcalls masked, this operation will atomically
- * reenable event delivery and check for pending events before blocking the
- * VCPU. This avoids a "wakeup waiting" race.
- * @arg == NULL.
- */
-#define SCHEDOP_block       1
-
-/*
- * Halt execution of this domain (all VCPUs) and notify the system controller.
- * @arg == pointer to sched_shutdown structure.
- */
-#define SCHEDOP_shutdown    2
-struct sched_shutdown {
-    unsigned int reason; /* SHUTDOWN_* */
-};
-typedef struct sched_shutdown sched_shutdown_t;
-DEFINE_XEN_GUEST_HANDLE(sched_shutdown_t);
-
-/*
- * Poll a set of event-channel ports. Return when one or more are pending. An
- * optional timeout may be specified.
- * @arg == pointer to sched_poll structure.
- */
-#define SCHEDOP_poll        3
-struct sched_poll {
-    XEN_GUEST_HANDLE(evtchn_port_t) ports;
-    unsigned int nr_ports;
-    uint64_t timeout;
-};
-typedef struct sched_poll sched_poll_t;
-DEFINE_XEN_GUEST_HANDLE(sched_poll_t);
-
-/*
- * Declare a shutdown for another domain. The main use of this function is
- * in interpreting shutdown requests and reasons for fully-virtualized
- * domains.  A para-virtualized domain may use SCHEDOP_shutdown directly.
- * @arg == pointer to sched_remote_shutdown structure.
- */
-#define SCHEDOP_remote_shutdown        4
-struct sched_remote_shutdown {
-    domid_t domain_id;         /* Remote domain ID */
-    unsigned int reason;       /* SHUTDOWN_xxx reason */
-};
-typedef struct sched_remote_shutdown sched_remote_shutdown_t;
-DEFINE_XEN_GUEST_HANDLE(sched_remote_shutdown_t);
-
-/*
- * Latch a shutdown code, so that when the domain later shuts down it
- * reports this code to the control tools.
- * @arg == as for SCHEDOP_shutdown.
- */
-#define SCHEDOP_shutdown_code 5
-
-/*
- * Setup, poke and destroy a domain watchdog timer.
- * @arg == pointer to sched_watchdog structure.
- * With id == 0, setup a domain watchdog timer to cause domain shutdown
- *               after timeout, returns watchdog id.
- * With id != 0 and timeout == 0, destroy domain watchdog timer.
- * With id != 0 and timeout != 0, poke watchdog timer and set new timeout.
- */
-#define SCHEDOP_watchdog    6
-struct sched_watchdog {
-    uint32_t id;                /* watchdog ID */
-    uint32_t timeout;           /* timeout */
-};
-typedef struct sched_watchdog sched_watchdog_t;
-DEFINE_XEN_GUEST_HANDLE(sched_watchdog_t);
-
-/*
- * Reason codes for SCHEDOP_shutdown. These may be interpreted by control
- * software to determine the appropriate action. For the most part, Xen does
- * not care about the shutdown code.
- */
-#define SHUTDOWN_poweroff   0  /* Domain exited normally. Clean up and kill. */
-#define SHUTDOWN_reboot     1  /* Clean up, kill, and then restart.          */
-#define SHUTDOWN_suspend    2  /* Clean up, save suspend info, kill.         */
-#define SHUTDOWN_crash      3  /* Tell controller we've crashed.             */
-#define SHUTDOWN_watchdog   4  /* Restart because watchdog time expired.     */
-
-#endif /* __XEN_PUBLIC_SCHED_H__ */
-
-/*
- * Local variables:
- * mode: C
- * c-set-style: "BSD"
- * c-basic-offset: 4
- * tab-width: 4
- * indent-tabs-mode: nil
- * End:
- */
diff -Nru xen-4.2.1-new/extras/mini-os/include/xen/sysctl.h xen-4.2.1/extras/mini-os/include/xen/sysctl.h
--- xen-4.2.1-new/extras/mini-os/include/xen/sysctl.h	2014-08-23 21:01:22.000000000 +0800
+++ xen-4.2.1/extras/mini-os/include/xen/sysctl.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,655 +0,0 @@
-/******************************************************************************
- * sysctl.h
- * 
- * System management operations. For use by node control stack.
- * 
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- * Copyright (c) 2002-2006, K Fraser
- */
-
-#ifndef __XEN_PUBLIC_SYSCTL_H__
-#define __XEN_PUBLIC_SYSCTL_H__
-
-#if !defined(__XEN__) && !defined(__XEN_TOOLS__)
-#error "sysctl operations are intended for use by node control tools only"
-#endif
-
-#include "xen.h"
-#include "domctl.h"
-
-#define XEN_SYSCTL_INTERFACE_VERSION 0x00000009
-
-/*
- * Read console content from Xen buffer ring.
- */
-/* XEN_SYSCTL_readconsole */
-struct xen_sysctl_readconsole {
-    /* IN: Non-zero -> clear after reading. */
-    uint8_t clear;
-    /* IN: Non-zero -> start index specified by @index field. */
-    uint8_t incremental;
-    uint8_t pad0, pad1;
-    /*
-     * IN:  Start index for consuming from ring buffer (if @incremental);
-     * OUT: End index after consuming from ring buffer.
-     */
-    uint32_t index; 
-    /* IN: Virtual address to write console data. */
-    XEN_GUEST_HANDLE_64(char) buffer;
-    /* IN: Size of buffer; OUT: Bytes written to buffer. */
-    uint32_t count;
-};
-typedef struct xen_sysctl_readconsole xen_sysctl_readconsole_t;
-DEFINE_XEN_GUEST_HANDLE(xen_sysctl_readconsole_t);
-
-/* Get trace buffers machine base address */
-/* XEN_SYSCTL_tbuf_op */
-struct xen_sysctl_tbuf_op {
-    /* IN variables */
-#define XEN_SYSCTL_TBUFOP_get_info     0
-#define XEN_SYSCTL_TBUFOP_set_cpu_mask 1
-#define XEN_SYSCTL_TBUFOP_set_evt_mask 2
-#define XEN_SYSCTL_TBUFOP_set_size     3
-#define XEN_SYSCTL_TBUFOP_enable       4
-#define XEN_SYSCTL_TBUFOP_disable      5
-    uint32_t cmd;
-    /* IN/OUT variables */
-    struct xenctl_cpumap cpu_mask;
-    uint32_t             evt_mask;
-    /* OUT variables */
-    uint64_aligned_t buffer_mfn;
-    uint32_t size;  /* Also an IN variable! */
-};
-typedef struct xen_sysctl_tbuf_op xen_sysctl_tbuf_op_t;
-DEFINE_XEN_GUEST_HANDLE(xen_sysctl_tbuf_op_t);
-
-/*
- * Get physical information about the host machine
- */
-/* XEN_SYSCTL_physinfo */
- /* (x86) The platform supports HVM guests. */
-#define _XEN_SYSCTL_PHYSCAP_hvm          0
-#define XEN_SYSCTL_PHYSCAP_hvm           (1u<<_XEN_SYSCTL_PHYSCAP_hvm)
- /* (x86) The platform supports HVM-guest direct access to I/O devices. */
-#define _XEN_SYSCTL_PHYSCAP_hvm_directio 1
-#define XEN_SYSCTL_PHYSCAP_hvm_directio  (1u<<_XEN_SYSCTL_PHYSCAP_hvm_directio)
-struct xen_sysctl_physinfo {
-    uint32_t threads_per_core;
-    uint32_t cores_per_socket;
-    uint32_t nr_cpus;     /* # CPUs currently online */
-    uint32_t max_cpu_id;  /* Largest possible CPU ID on this host */
-    uint32_t nr_nodes;    /* # nodes currently online */
-    uint32_t max_node_id; /* Largest possible node ID on this host */
-    uint32_t cpu_khz;
-    uint64_aligned_t total_pages;
-    uint64_aligned_t free_pages;
-    uint64_aligned_t scrub_pages;
-    uint32_t hw_cap[8];
-
-    /* XEN_SYSCTL_PHYSCAP_??? */
-    uint32_t capabilities;
-};
-typedef struct xen_sysctl_physinfo xen_sysctl_physinfo_t;
-DEFINE_XEN_GUEST_HANDLE(xen_sysctl_physinfo_t);
-
-/*
- * Get the ID of the current scheduler.
- */
-/* XEN_SYSCTL_sched_id */
-struct xen_sysctl_sched_id {
-    /* OUT variable */
-    uint32_t sched_id;
-};
-typedef struct xen_sysctl_sched_id xen_sysctl_sched_id_t;
-DEFINE_XEN_GUEST_HANDLE(xen_sysctl_sched_id_t);
-
-/* Interface for controlling Xen software performance counters. */
-/* XEN_SYSCTL_perfc_op */
-/* Sub-operations: */
-#define XEN_SYSCTL_PERFCOP_reset 1   /* Reset all counters to zero. */
-#define XEN_SYSCTL_PERFCOP_query 2   /* Get perfctr information. */
-struct xen_sysctl_perfc_desc {
-    char         name[80];             /* name of perf counter */
-    uint32_t     nr_vals;              /* number of values for this counter */
-};
-typedef struct xen_sysctl_perfc_desc xen_sysctl_perfc_desc_t;
-DEFINE_XEN_GUEST_HANDLE(xen_sysctl_perfc_desc_t);
-typedef uint32_t xen_sysctl_perfc_val_t;
-DEFINE_XEN_GUEST_HANDLE(xen_sysctl_perfc_val_t);
-
-struct xen_sysctl_perfc_op {
-    /* IN variables. */
-    uint32_t       cmd;                /*  XEN_SYSCTL_PERFCOP_??? */
-    /* OUT variables. */
-    uint32_t       nr_counters;       /*  number of counters description  */
-    uint32_t       nr_vals;           /*  number of values  */
-    /* counter information (or NULL) */
-    XEN_GUEST_HANDLE_64(xen_sysctl_perfc_desc_t) desc;
-    /* counter values (or NULL) */
-    XEN_GUEST_HANDLE_64(xen_sysctl_perfc_val_t) val;
-};
-typedef struct xen_sysctl_perfc_op xen_sysctl_perfc_op_t;
-DEFINE_XEN_GUEST_HANDLE(xen_sysctl_perfc_op_t);
-
-/* XEN_SYSCTL_getdomaininfolist */
-struct xen_sysctl_getdomaininfolist {
-    /* IN variables. */
-    domid_t               first_domain;
-    uint32_t              max_domains;
-    XEN_GUEST_HANDLE_64(xen_domctl_getdomaininfo_t) buffer;
-    /* OUT variables. */
-    uint32_t              num_domains;
-};
-typedef struct xen_sysctl_getdomaininfolist xen_sysctl_getdomaininfolist_t;
-DEFINE_XEN_GUEST_HANDLE(xen_sysctl_getdomaininfolist_t);
-
-/* Inject debug keys into Xen. */
-/* XEN_SYSCTL_debug_keys */
-struct xen_sysctl_debug_keys {
-    /* IN variables. */
-    XEN_GUEST_HANDLE_64(char) keys;
-    uint32_t nr_keys;
-};
-typedef struct xen_sysctl_debug_keys xen_sysctl_debug_keys_t;
-DEFINE_XEN_GUEST_HANDLE(xen_sysctl_debug_keys_t);
-
-/* Get physical CPU information. */
-/* XEN_SYSCTL_getcpuinfo */
-struct xen_sysctl_cpuinfo {
-    uint64_aligned_t idletime;
-};
-typedef struct xen_sysctl_cpuinfo xen_sysctl_cpuinfo_t;
-DEFINE_XEN_GUEST_HANDLE(xen_sysctl_cpuinfo_t); 
-struct xen_sysctl_getcpuinfo {
-    /* IN variables. */
-    uint32_t max_cpus;
-    XEN_GUEST_HANDLE_64(xen_sysctl_cpuinfo_t) info;
-    /* OUT variables. */
-    uint32_t nr_cpus;
-}; 
-typedef struct xen_sysctl_getcpuinfo xen_sysctl_getcpuinfo_t;
-DEFINE_XEN_GUEST_HANDLE(xen_sysctl_getcpuinfo_t); 
-
-/* XEN_SYSCTL_availheap */
-struct xen_sysctl_availheap {
-    /* IN variables. */
-    uint32_t min_bitwidth;  /* Smallest address width (zero if don't care). */
-    uint32_t max_bitwidth;  /* Largest address width (zero if don't care). */
-    int32_t  node;          /* NUMA node of interest (-1 for all nodes). */
-    /* OUT variables. */
-    uint64_aligned_t avail_bytes;/* Bytes available in the specified region. */
-};
-typedef struct xen_sysctl_availheap xen_sysctl_availheap_t;
-DEFINE_XEN_GUEST_HANDLE(xen_sysctl_availheap_t);
-
-/* XEN_SYSCTL_get_pmstat */
-struct pm_px_val {
-    uint64_aligned_t freq;        /* Px core frequency */
-    uint64_aligned_t residency;   /* Px residency time */
-    uint64_aligned_t count;       /* Px transition count */
-};
-typedef struct pm_px_val pm_px_val_t;
-DEFINE_XEN_GUEST_HANDLE(pm_px_val_t);
-
-struct pm_px_stat {
-    uint8_t total;        /* total Px states */
-    uint8_t usable;       /* usable Px states */
-    uint8_t last;         /* last Px state */
-    uint8_t cur;          /* current Px state */
-    XEN_GUEST_HANDLE_64(uint64) trans_pt;   /* Px transition table */
-    XEN_GUEST_HANDLE_64(pm_px_val_t) pt;
-};
-typedef struct pm_px_stat pm_px_stat_t;
-DEFINE_XEN_GUEST_HANDLE(pm_px_stat_t);
-
-struct pm_cx_stat {
-    uint32_t nr;    /* entry nr in triggers & residencies, including C0 */
-    uint32_t last;  /* last Cx state */
-    uint64_aligned_t idle_time;                 /* idle time from boot */
-    XEN_GUEST_HANDLE_64(uint64) triggers;    /* Cx trigger counts */
-    XEN_GUEST_HANDLE_64(uint64) residencies; /* Cx residencies */
-    uint64_aligned_t pc2;
-    uint64_aligned_t pc3;
-    uint64_aligned_t pc6;
-    uint64_aligned_t pc7;
-    uint64_aligned_t cc3;
-    uint64_aligned_t cc6;
-    uint64_aligned_t cc7;
-};
-
-struct xen_sysctl_get_pmstat {
-#define PMSTAT_CATEGORY_MASK 0xf0
-#define PMSTAT_PX            0x10
-#define PMSTAT_CX            0x20
-#define PMSTAT_get_max_px    (PMSTAT_PX | 0x1)
-#define PMSTAT_get_pxstat    (PMSTAT_PX | 0x2)
-#define PMSTAT_reset_pxstat  (PMSTAT_PX | 0x3)
-#define PMSTAT_get_max_cx    (PMSTAT_CX | 0x1)
-#define PMSTAT_get_cxstat    (PMSTAT_CX | 0x2)
-#define PMSTAT_reset_cxstat  (PMSTAT_CX | 0x3)
-    uint32_t type;
-    uint32_t cpuid;
-    union {
-        struct pm_px_stat getpx;
-        struct pm_cx_stat getcx;
-        /* other struct for tx, etc */
-    } u;
-};
-typedef struct xen_sysctl_get_pmstat xen_sysctl_get_pmstat_t;
-DEFINE_XEN_GUEST_HANDLE(xen_sysctl_get_pmstat_t);
-
-/* XEN_SYSCTL_cpu_hotplug */
-struct xen_sysctl_cpu_hotplug {
-    /* IN variables */
-    uint32_t cpu;   /* Physical cpu. */
-#define XEN_SYSCTL_CPU_HOTPLUG_ONLINE  0
-#define XEN_SYSCTL_CPU_HOTPLUG_OFFLINE 1
-    uint32_t op;    /* hotplug opcode */
-};
-typedef struct xen_sysctl_cpu_hotplug xen_sysctl_cpu_hotplug_t;
-DEFINE_XEN_GUEST_HANDLE(xen_sysctl_cpu_hotplug_t);
-
-/*
- * Get/set xen power management, include 
- * 1. cpufreq governors and related parameters
- */
-/* XEN_SYSCTL_pm_op */
-struct xen_userspace {
-    uint32_t scaling_setspeed;
-};
-typedef struct xen_userspace xen_userspace_t;
-
-struct xen_ondemand {
-    uint32_t sampling_rate_max;
-    uint32_t sampling_rate_min;
-
-    uint32_t sampling_rate;
-    uint32_t up_threshold;
-};
-typedef struct xen_ondemand xen_ondemand_t;
-
-/* 
- * cpufreq para name of this structure named 
- * same as sysfs file name of native linux
- */
-#define CPUFREQ_NAME_LEN 16
-struct xen_get_cpufreq_para {
-    /* IN/OUT variable */
-    uint32_t cpu_num;
-    uint32_t freq_num;
-    uint32_t gov_num;
-
-    /* for all governors */
-    /* OUT variable */
-    XEN_GUEST_HANDLE_64(uint32) affected_cpus;
-    XEN_GUEST_HANDLE_64(uint32) scaling_available_frequencies;
-    XEN_GUEST_HANDLE_64(char)   scaling_available_governors;
-    char scaling_driver[CPUFREQ_NAME_LEN];
-
-    uint32_t cpuinfo_cur_freq;
-    uint32_t cpuinfo_max_freq;
-    uint32_t cpuinfo_min_freq;
-    uint32_t scaling_cur_freq;
-
-    char scaling_governor[CPUFREQ_NAME_LEN];
-    uint32_t scaling_max_freq;
-    uint32_t scaling_min_freq;
-
-    /* for specific governor */
-    union {
-        struct  xen_userspace userspace;
-        struct  xen_ondemand ondemand;
-    } u;
-
-    int32_t turbo_enabled;
-};
-
-struct xen_set_cpufreq_gov {
-    char scaling_governor[CPUFREQ_NAME_LEN];
-};
-
-struct xen_set_cpufreq_para {
-    #define SCALING_MAX_FREQ           1
-    #define SCALING_MIN_FREQ           2
-    #define SCALING_SETSPEED           3
-    #define SAMPLING_RATE              4
-    #define UP_THRESHOLD               5
-
-    uint32_t ctrl_type;
-    uint32_t ctrl_value;
-};
-
-struct xen_sysctl_pm_op {
-    #define PM_PARA_CATEGORY_MASK      0xf0
-    #define CPUFREQ_PARA               0x10
-
-    /* cpufreq command type */
-    #define GET_CPUFREQ_PARA           (CPUFREQ_PARA | 0x01)
-    #define SET_CPUFREQ_GOV            (CPUFREQ_PARA | 0x02)
-    #define SET_CPUFREQ_PARA           (CPUFREQ_PARA | 0x03)
-    #define GET_CPUFREQ_AVGFREQ        (CPUFREQ_PARA | 0x04)
-
-    /* set/reset scheduler power saving option */
-    #define XEN_SYSCTL_pm_op_set_sched_opt_smt    0x21
-
-    /* cpuidle max_cstate access command */
-    #define XEN_SYSCTL_pm_op_get_max_cstate       0x22
-    #define XEN_SYSCTL_pm_op_set_max_cstate       0x23
-
-    /* set scheduler migration cost value */
-    #define XEN_SYSCTL_pm_op_set_vcpu_migration_delay   0x24
-    #define XEN_SYSCTL_pm_op_get_vcpu_migration_delay   0x25
-
-    /* enable/disable turbo mode when in dbs governor */
-    #define XEN_SYSCTL_pm_op_enable_turbo               0x26
-    #define XEN_SYSCTL_pm_op_disable_turbo              0x27
-
-    uint32_t cmd;
-    uint32_t cpuid;
-    union {
-        struct xen_get_cpufreq_para get_para;
-        struct xen_set_cpufreq_gov  set_gov;
-        struct xen_set_cpufreq_para set_para;
-        uint64_aligned_t get_avgfreq;
-        uint32_t                    set_sched_opt_smt;
-        uint32_t                    get_max_cstate;
-        uint32_t                    set_max_cstate;
-        uint32_t                    get_vcpu_migration_delay;
-        uint32_t                    set_vcpu_migration_delay;
-    } u;
-};
-
-/* XEN_SYSCTL_page_offline_op */
-struct xen_sysctl_page_offline_op {
-    /* IN: range of page to be offlined */
-#define sysctl_page_offline     1
-#define sysctl_page_online      2
-#define sysctl_query_page_offline  3
-    uint32_t cmd;
-    uint32_t start;
-    uint32_t end;
-    /* OUT: result of page offline request */
-    /*
-     * bit 0~15: result flags
-     * bit 16~31: owner
-     */
-    XEN_GUEST_HANDLE(uint32) status;
-};
-
-#define PG_OFFLINE_STATUS_MASK    (0xFFUL)
-
-/* The result is invalid, i.e. HV does not handle it */
-#define PG_OFFLINE_INVALID   (0x1UL << 0)
-
-#define PG_OFFLINE_OFFLINED  (0x1UL << 1)
-#define PG_OFFLINE_PENDING   (0x1UL << 2)
-#define PG_OFFLINE_FAILED    (0x1UL << 3)
-#define PG_OFFLINE_AGAIN     (0x1UL << 4)
-
-#define PG_ONLINE_FAILED     PG_OFFLINE_FAILED
-#define PG_ONLINE_ONLINED    PG_OFFLINE_OFFLINED
-
-#define PG_OFFLINE_STATUS_OFFLINED              (0x1UL << 1)
-#define PG_OFFLINE_STATUS_ONLINE                (0x1UL << 2)
-#define PG_OFFLINE_STATUS_OFFLINE_PENDING       (0x1UL << 3)
-#define PG_OFFLINE_STATUS_BROKEN                (0x1UL << 4)
-
-#define PG_OFFLINE_MISC_MASK    (0xFFUL << 4)
-
-/* valid when PG_OFFLINE_FAILED or PG_OFFLINE_PENDING */
-#define PG_OFFLINE_XENPAGE   (0x1UL << 8)
-#define PG_OFFLINE_DOM0PAGE  (0x1UL << 9)
-#define PG_OFFLINE_ANONYMOUS (0x1UL << 10)
-#define PG_OFFLINE_NOT_CONV_RAM   (0x1UL << 11)
-#define PG_OFFLINE_OWNED     (0x1UL << 12)
-
-#define PG_OFFLINE_BROKEN    (0x1UL << 13)
-#define PG_ONLINE_BROKEN     PG_OFFLINE_BROKEN
-
-#define PG_OFFLINE_OWNER_SHIFT 16
-
-/* XEN_SYSCTL_lockprof_op */
-/* Sub-operations: */
-#define XEN_SYSCTL_LOCKPROF_reset 1   /* Reset all profile data to zero. */
-#define XEN_SYSCTL_LOCKPROF_query 2   /* Get lock profile information. */
-/* Record-type: */
-#define LOCKPROF_TYPE_GLOBAL      0   /* global lock, idx meaningless */
-#define LOCKPROF_TYPE_PERDOM      1   /* per-domain lock, idx is domid */
-#define LOCKPROF_TYPE_N           2   /* number of types */
-struct xen_sysctl_lockprof_data {
-    char     name[40];     /* lock name (may include up to 2 %d specifiers) */
-    int32_t  type;         /* LOCKPROF_TYPE_??? */
-    int32_t  idx;          /* index (e.g. domain id) */
-    uint64_aligned_t lock_cnt;     /* # of locking succeeded */
-    uint64_aligned_t block_cnt;    /* # of wait for lock */
-    uint64_aligned_t lock_time;    /* nsecs lock held */
-    uint64_aligned_t block_time;   /* nsecs waited for lock */
-};
-typedef struct xen_sysctl_lockprof_data xen_sysctl_lockprof_data_t;
-DEFINE_XEN_GUEST_HANDLE(xen_sysctl_lockprof_data_t);
-struct xen_sysctl_lockprof_op {
-    /* IN variables. */
-    uint32_t       cmd;               /* XEN_SYSCTL_LOCKPROF_??? */
-    uint32_t       max_elem;          /* size of output buffer */
-    /* OUT variables (query only). */
-    uint32_t       nr_elem;           /* number of elements available */
-    uint64_aligned_t time;            /* nsecs of profile measurement */
-    /* profile information (or NULL) */
-    XEN_GUEST_HANDLE_64(xen_sysctl_lockprof_data_t) data;
-};
-typedef struct xen_sysctl_lockprof_op xen_sysctl_lockprof_op_t;
-DEFINE_XEN_GUEST_HANDLE(xen_sysctl_lockprof_op_t);
-
-/* XEN_SYSCTL_topologyinfo */
-#define INVALID_TOPOLOGY_ID  (~0U)
-struct xen_sysctl_topologyinfo {
-    /*
-     * IN: maximum addressable entry in the caller-provided arrays.
-     * OUT: largest cpu identifier in the system.
-     * If OUT is greater than IN then the arrays are truncated!
-     * If OUT is leass than IN then the array tails are not written by sysctl.
-     */
-    uint32_t max_cpu_index;
-
-    /*
-     * If not NULL, these arrays are filled with core/socket/node identifier
-     * for each cpu.
-     * If a cpu has no core/socket/node information (e.g., cpu not present) 
-     * then the sentinel value ~0u is written to each array.
-     * The number of array elements written by the sysctl is:
-     *   min(@max_cpu_index_IN,@max_cpu_index_OUT)+1
-     */
-    XEN_GUEST_HANDLE_64(uint32) cpu_to_core;
-    XEN_GUEST_HANDLE_64(uint32) cpu_to_socket;
-    XEN_GUEST_HANDLE_64(uint32) cpu_to_node;
-};
-typedef struct xen_sysctl_topologyinfo xen_sysctl_topologyinfo_t;
-DEFINE_XEN_GUEST_HANDLE(xen_sysctl_topologyinfo_t);
-
-/* XEN_SYSCTL_numainfo */
-#define INVALID_NUMAINFO_ID (~0U)
-struct xen_sysctl_numainfo {
-    /*
-     * IN: maximum addressable entry in the caller-provided arrays.
-     * OUT: largest node identifier in the system.
-     * If OUT is greater than IN then the arrays are truncated!
-     */
-    uint32_t max_node_index;
-
-    /* NB. Entries are 0 if node is not present. */
-    XEN_GUEST_HANDLE_64(uint64) node_to_memsize;
-    XEN_GUEST_HANDLE_64(uint64) node_to_memfree;
-
-    /*
-     * Array, of size (max_node_index+1)^2, listing memory access distances
-     * between nodes. If an entry has no node distance information (e.g., node 
-     * not present) then the value ~0u is written.
-     * 
-     * Note that the array rows must be indexed by multiplying by the minimum 
-     * of the caller-provided max_node_index and the returned value of
-     * max_node_index. That is, if the largest node index in the system is
-     * smaller than the caller can handle, a smaller 2-d array is constructed
-     * within the space provided by the caller. When this occurs, trailing
-     * space provided by the caller is not modified. If the largest node index
-     * in the system is larger than the caller can handle, then a 2-d array of
-     * the maximum size handleable by the caller is constructed.
-     */
-    XEN_GUEST_HANDLE_64(uint32) node_to_node_distance;
-};
-typedef struct xen_sysctl_numainfo xen_sysctl_numainfo_t;
-DEFINE_XEN_GUEST_HANDLE(xen_sysctl_numainfo_t);
-
-/* XEN_SYSCTL_cpupool_op */
-#define XEN_SYSCTL_CPUPOOL_OP_CREATE                1  /* C */
-#define XEN_SYSCTL_CPUPOOL_OP_DESTROY               2  /* D */
-#define XEN_SYSCTL_CPUPOOL_OP_INFO                  3  /* I */
-#define XEN_SYSCTL_CPUPOOL_OP_ADDCPU                4  /* A */
-#define XEN_SYSCTL_CPUPOOL_OP_RMCPU                 5  /* R */
-#define XEN_SYSCTL_CPUPOOL_OP_MOVEDOMAIN            6  /* M */
-#define XEN_SYSCTL_CPUPOOL_OP_FREEINFO              7  /* F */
-#define XEN_SYSCTL_CPUPOOL_PAR_ANY     0xFFFFFFFF
-struct xen_sysctl_cpupool_op {
-    uint32_t op;          /* IN */
-    uint32_t cpupool_id;  /* IN: CDIARM OUT: CI */
-    uint32_t sched_id;    /* IN: C      OUT: I  */
-    uint32_t domid;       /* IN: M              */
-    uint32_t cpu;         /* IN: AR             */
-    uint32_t n_dom;       /*            OUT: I  */
-    struct xenctl_cpumap cpumap; /*     OUT: IF */
-};
-typedef struct xen_sysctl_cpupool_op xen_sysctl_cpupool_op_t;
-DEFINE_XEN_GUEST_HANDLE(xen_sysctl_cpupool_op_t);
-
-#define ARINC653_MAX_DOMAINS_PER_SCHEDULE   64
-/*
- * This structure is used to pass a new ARINC653 schedule from a
- * privileged domain (ie dom0) to Xen.
- */
-struct xen_sysctl_arinc653_schedule {
-    /* major_frame holds the time for the new schedule's major frame
-     * in nanoseconds. */
-    uint64_aligned_t     major_frame;
-    /* num_sched_entries holds how many of the entries in the
-     * sched_entries[] array are valid. */
-    uint8_t     num_sched_entries;
-    /* The sched_entries array holds the actual schedule entries. */
-    struct {
-        /* dom_handle must match a domain's UUID */
-        xen_domain_handle_t dom_handle;
-        /* If a domain has multiple VCPUs, vcpu_id specifies which one
-         * this schedule entry applies to. It should be set to 0 if
-         * there is only one VCPU for the domain. */
-        unsigned int vcpu_id;
-        /* runtime specifies the amount of time that should be allocated
-         * to this VCPU per major frame. It is specified in nanoseconds */
-        uint64_aligned_t runtime;
-    } sched_entries[ARINC653_MAX_DOMAINS_PER_SCHEDULE];
-};
-typedef struct xen_sysctl_arinc653_schedule xen_sysctl_arinc653_schedule_t;
-DEFINE_XEN_GUEST_HANDLE(xen_sysctl_arinc653_schedule_t);
-
-struct xen_sysctl_credit_schedule {
-    /* Length of timeslice in milliseconds */
-#define XEN_SYSCTL_CSCHED_TSLICE_MAX 1000
-#define XEN_SYSCTL_CSCHED_TSLICE_MIN 1
-    unsigned tslice_ms;
-    /* Rate limit (minimum timeslice) in microseconds */
-#define XEN_SYSCTL_SCHED_RATELIMIT_MAX 500000
-#define XEN_SYSCTL_SCHED_RATELIMIT_MIN 100
-    unsigned ratelimit_us;
-};
-typedef struct xen_sysctl_credit_schedule xen_sysctl_credit_schedule_t;
-DEFINE_XEN_GUEST_HANDLE(xen_sysctl_credit_schedule_t);
-
-/* XEN_SYSCTL_scheduler_op */
-/* Set or get info? */
-#define XEN_SYSCTL_SCHEDOP_putinfo 0
-#define XEN_SYSCTL_SCHEDOP_getinfo 1
-struct xen_sysctl_scheduler_op {
-    uint32_t cpupool_id; /* Cpupool whose scheduler is to be targetted. */
-    uint32_t sched_id;   /* XEN_SCHEDULER_* (domctl.h) */
-    uint32_t cmd;        /* XEN_SYSCTL_SCHEDOP_* */
-    union {
-        struct xen_sysctl_sched_arinc653 {
-            XEN_GUEST_HANDLE_64(xen_sysctl_arinc653_schedule_t) schedule;
-        } sched_arinc653;
-        struct xen_sysctl_credit_schedule sched_credit;
-    } u;
-};
-typedef struct xen_sysctl_scheduler_op xen_sysctl_scheduler_op_t;
-DEFINE_XEN_GUEST_HANDLE(xen_sysctl_scheduler_op_t);
-
-struct xen_sysctl {
-    uint32_t cmd;
-#define XEN_SYSCTL_readconsole                    1
-#define XEN_SYSCTL_tbuf_op                        2
-#define XEN_SYSCTL_physinfo                       3
-#define XEN_SYSCTL_sched_id                       4
-#define XEN_SYSCTL_perfc_op                       5
-#define XEN_SYSCTL_getdomaininfolist              6
-#define XEN_SYSCTL_debug_keys                     7
-#define XEN_SYSCTL_getcpuinfo                     8
-#define XEN_SYSCTL_availheap                      9
-#define XEN_SYSCTL_get_pmstat                    10
-#define XEN_SYSCTL_cpu_hotplug                   11
-#define XEN_SYSCTL_pm_op                         12
-#define XEN_SYSCTL_page_offline_op               14
-#define XEN_SYSCTL_lockprof_op                   15
-#define XEN_SYSCTL_topologyinfo                  16 
-#define XEN_SYSCTL_numainfo                      17
-#define XEN_SYSCTL_cpupool_op                    18
-#define XEN_SYSCTL_scheduler_op                  19
-    uint32_t interface_version; /* XEN_SYSCTL_INTERFACE_VERSION */
-    union {
-        struct xen_sysctl_readconsole       readconsole;
-        struct xen_sysctl_tbuf_op           tbuf_op;
-        struct xen_sysctl_physinfo          physinfo;
-        struct xen_sysctl_topologyinfo      topologyinfo;
-        struct xen_sysctl_numainfo          numainfo;
-        struct xen_sysctl_sched_id          sched_id;
-        struct xen_sysctl_perfc_op          perfc_op;
-        struct xen_sysctl_getdomaininfolist getdomaininfolist;
-        struct xen_sysctl_debug_keys        debug_keys;
-        struct xen_sysctl_getcpuinfo        getcpuinfo;
-        struct xen_sysctl_availheap         availheap;
-        struct xen_sysctl_get_pmstat        get_pmstat;
-        struct xen_sysctl_cpu_hotplug       cpu_hotplug;
-        struct xen_sysctl_pm_op             pm_op;
-        struct xen_sysctl_page_offline_op   page_offline;
-        struct xen_sysctl_lockprof_op       lockprof_op;
-        struct xen_sysctl_cpupool_op        cpupool_op;
-        struct xen_sysctl_scheduler_op      scheduler_op;
-        uint8_t                             pad[128];
-    } u;
-};
-typedef struct xen_sysctl xen_sysctl_t;
-DEFINE_XEN_GUEST_HANDLE(xen_sysctl_t);
-
-#endif /* __XEN_PUBLIC_SYSCTL_H__ */
-
-/*
- * Local variables:
- * mode: C
- * c-set-style: "BSD"
- * c-basic-offset: 4
- * tab-width: 4
- * indent-tabs-mode: nil
- * End:
- */
diff -Nru xen-4.2.1-new/extras/mini-os/include/xen/tmem.h xen-4.2.1/extras/mini-os/include/xen/tmem.h
--- xen-4.2.1-new/extras/mini-os/include/xen/tmem.h	2014-08-23 21:01:22.000000000 +0800
+++ xen-4.2.1/extras/mini-os/include/xen/tmem.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,148 +0,0 @@
-/******************************************************************************
- * tmem.h
- * 
- * Guest OS interface to Xen Transcendent Memory.
- * 
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- * Copyright (c) 2004, K A Fraser
- */
-
-#ifndef __XEN_PUBLIC_TMEM_H__
-#define __XEN_PUBLIC_TMEM_H__
-
-#include "xen.h"
-
-/* version of ABI */
-#define TMEM_SPEC_VERSION          1
-
-/* Commands to HYPERVISOR_tmem_op() */
-#define TMEM_CONTROL               0
-#define TMEM_NEW_POOL              1
-#define TMEM_DESTROY_POOL          2
-#define TMEM_NEW_PAGE              3
-#define TMEM_PUT_PAGE              4
-#define TMEM_GET_PAGE              5
-#define TMEM_FLUSH_PAGE            6
-#define TMEM_FLUSH_OBJECT          7
-#define TMEM_READ                  8
-#define TMEM_WRITE                 9
-#define TMEM_XCHG                 10
-
-/* Privileged commands to HYPERVISOR_tmem_op() */
-#define TMEM_AUTH                 101 
-#define TMEM_RESTORE_NEW          102
-
-/* Subops for HYPERVISOR_tmem_op(TMEM_CONTROL) */
-#define TMEMC_THAW                   0
-#define TMEMC_FREEZE                 1
-#define TMEMC_FLUSH                  2
-#define TMEMC_DESTROY                3
-#define TMEMC_LIST                   4
-#define TMEMC_SET_WEIGHT             5
-#define TMEMC_SET_CAP                6
-#define TMEMC_SET_COMPRESS           7
-#define TMEMC_QUERY_FREEABLE_MB      8
-#define TMEMC_SAVE_BEGIN             10
-#define TMEMC_SAVE_GET_VERSION       11
-#define TMEMC_SAVE_GET_MAXPOOLS      12
-#define TMEMC_SAVE_GET_CLIENT_WEIGHT 13
-#define TMEMC_SAVE_GET_CLIENT_CAP    14
-#define TMEMC_SAVE_GET_CLIENT_FLAGS  15
-#define TMEMC_SAVE_GET_POOL_FLAGS    16
-#define TMEMC_SAVE_GET_POOL_NPAGES   17
-#define TMEMC_SAVE_GET_POOL_UUID     18
-#define TMEMC_SAVE_GET_NEXT_PAGE     19
-#define TMEMC_SAVE_GET_NEXT_INV      20
-#define TMEMC_SAVE_END               21
-#define TMEMC_RESTORE_BEGIN          30
-#define TMEMC_RESTORE_PUT_PAGE       32
-#define TMEMC_RESTORE_FLUSH_PAGE     33
-
-/* Bits for HYPERVISOR_tmem_op(TMEM_NEW_POOL) */
-#define TMEM_POOL_PERSIST          1
-#define TMEM_POOL_SHARED           2
-#define TMEM_POOL_PRECOMPRESSED    4
-#define TMEM_POOL_PAGESIZE_SHIFT   4
-#define TMEM_POOL_PAGESIZE_MASK  0xf
-#define TMEM_POOL_VERSION_SHIFT   24
-#define TMEM_POOL_VERSION_MASK  0xff
-#define TMEM_POOL_RESERVED_BITS  0x00ffff00
-
-/* Bits for client flags (save/restore) */
-#define TMEM_CLIENT_COMPRESS       1
-#define TMEM_CLIENT_FROZEN         2
-
-/* Special errno values */
-#define EFROZEN                 1000
-#define EEMPTY                  1001
-
-
-#ifndef __ASSEMBLY__
-typedef xen_pfn_t tmem_cli_mfn_t;
-typedef XEN_GUEST_HANDLE(char) tmem_cli_va_t;
-struct tmem_op {
-    uint32_t cmd;
-    int32_t pool_id;
-    union {
-        struct {
-            uint64_t uuid[2];
-            uint32_t flags;
-            uint32_t arg1;
-        } creat; /* for cmd == TMEM_NEW_POOL, TMEM_AUTH, TMEM_RESTORE_NEW */
-        struct { 
-            uint32_t subop;
-            uint32_t cli_id;
-            uint32_t arg1;
-            uint32_t arg2;
-            uint64_t oid[3];
-            tmem_cli_va_t buf;
-        } ctrl; /* for cmd == TMEM_CONTROL */
-        struct {
-            
-            uint64_t oid[3];
-            uint32_t index;
-            uint32_t tmem_offset;
-            uint32_t pfn_offset;
-            uint32_t len;
-            tmem_cli_mfn_t cmfn; /* client machine page frame */
-        } gen; /* for all other cmd ("generic") */
-    } u;
-};
-typedef struct tmem_op tmem_op_t;
-DEFINE_XEN_GUEST_HANDLE(tmem_op_t);
-
-struct tmem_handle {
-    uint32_t pool_id;
-    uint32_t index;
-    uint64_t oid[3];
-};
-#endif
-
-#endif /* __XEN_PUBLIC_TMEM_H__ */
-
-/*
- * Local variables:
- * mode: C
- * c-set-style: "BSD"
- * c-basic-offset: 4
- * tab-width: 4
- * indent-tabs-mode: nil
- * End:
- */
diff -Nru xen-4.2.1-new/extras/mini-os/include/xen/trace.h xen-4.2.1/extras/mini-os/include/xen/trace.h
--- xen-4.2.1-new/extras/mini-os/include/xen/trace.h	2014-08-23 21:01:22.000000000 +0800
+++ xen-4.2.1/extras/mini-os/include/xen/trace.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,245 +0,0 @@
-/******************************************************************************
- * include/public/trace.h
- * 
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- * Mark Williamson, (C) 2004 Intel Research Cambridge
- * Copyright (C) 2005 Bin Ren
- */
-
-#ifndef __XEN_PUBLIC_TRACE_H__
-#define __XEN_PUBLIC_TRACE_H__
-
-#define TRACE_EXTRA_MAX    7
-#define TRACE_EXTRA_SHIFT 28
-
-/* Trace classes */
-#define TRC_CLS_SHIFT 16
-#define TRC_GEN      0x0001f000    /* General trace            */
-#define TRC_SCHED    0x0002f000    /* Xen Scheduler trace      */
-#define TRC_DOM0OP   0x0004f000    /* Xen DOM0 operation trace */
-#define TRC_HVM      0x0008f000    /* Xen HVM trace            */
-#define TRC_MEM      0x0010f000    /* Xen memory trace         */
-#define TRC_PV       0x0020f000    /* Xen PV traces            */
-#define TRC_SHADOW   0x0040f000    /* Xen shadow tracing       */
-#define TRC_HW       0x0080f000    /* Xen hardware-related traces */
-#define TRC_GUEST    0x0800f000    /* Guest-generated traces   */
-#define TRC_ALL      0x0ffff000
-#define TRC_HD_TO_EVENT(x) ((x)&0x0fffffff)
-#define TRC_HD_CYCLE_FLAG (1UL<<31)
-#define TRC_HD_INCLUDES_CYCLE_COUNT(x) ( !!( (x) & TRC_HD_CYCLE_FLAG ) )
-#define TRC_HD_EXTRA(x)    (((x)>>TRACE_EXTRA_SHIFT)&TRACE_EXTRA_MAX)
-
-/* Trace subclasses */
-#define TRC_SUBCLS_SHIFT 12
-
-/* trace subclasses for SVM */
-#define TRC_HVM_ENTRYEXIT 0x00081000   /* VMENTRY and #VMEXIT       */
-#define TRC_HVM_HANDLER   0x00082000   /* various HVM handlers      */
-
-#define TRC_SCHED_MIN       0x00021000   /* Just runstate changes */
-#define TRC_SCHED_CLASS     0x00022000   /* Scheduler-specific    */
-#define TRC_SCHED_VERBOSE   0x00028000   /* More inclusive scheduling */
-
-/* Trace classes for Hardware */
-#define TRC_HW_PM           0x00801000   /* Power management traces */
-#define TRC_HW_IRQ          0x00802000   /* Traces relating to the handling of IRQs */
-
-/* Trace events per class */
-#define TRC_LOST_RECORDS        (TRC_GEN + 1)
-#define TRC_TRACE_WRAP_BUFFER  (TRC_GEN + 2)
-#define TRC_TRACE_CPU_CHANGE    (TRC_GEN + 3)
-
-#define TRC_SCHED_RUNSTATE_CHANGE   (TRC_SCHED_MIN + 1)
-#define TRC_SCHED_CONTINUE_RUNNING  (TRC_SCHED_MIN + 2)
-#define TRC_SCHED_DOM_ADD        (TRC_SCHED_VERBOSE +  1)
-#define TRC_SCHED_DOM_REM        (TRC_SCHED_VERBOSE +  2)
-#define TRC_SCHED_SLEEP          (TRC_SCHED_VERBOSE +  3)
-#define TRC_SCHED_WAKE           (TRC_SCHED_VERBOSE +  4)
-#define TRC_SCHED_YIELD          (TRC_SCHED_VERBOSE +  5)
-#define TRC_SCHED_BLOCK          (TRC_SCHED_VERBOSE +  6)
-#define TRC_SCHED_SHUTDOWN       (TRC_SCHED_VERBOSE +  7)
-#define TRC_SCHED_CTL            (TRC_SCHED_VERBOSE +  8)
-#define TRC_SCHED_ADJDOM         (TRC_SCHED_VERBOSE +  9)
-#define TRC_SCHED_SWITCH         (TRC_SCHED_VERBOSE + 10)
-#define TRC_SCHED_S_TIMER_FN     (TRC_SCHED_VERBOSE + 11)
-#define TRC_SCHED_T_TIMER_FN     (TRC_SCHED_VERBOSE + 12)
-#define TRC_SCHED_DOM_TIMER_FN   (TRC_SCHED_VERBOSE + 13)
-#define TRC_SCHED_SWITCH_INFPREV (TRC_SCHED_VERBOSE + 14)
-#define TRC_SCHED_SWITCH_INFNEXT (TRC_SCHED_VERBOSE + 15)
-#define TRC_SCHED_SHUTDOWN_CODE  (TRC_SCHED_VERBOSE + 16)
-
-#define TRC_MEM_PAGE_GRANT_MAP      (TRC_MEM + 1)
-#define TRC_MEM_PAGE_GRANT_UNMAP    (TRC_MEM + 2)
-#define TRC_MEM_PAGE_GRANT_TRANSFER (TRC_MEM + 3)
-#define TRC_MEM_SET_P2M_ENTRY       (TRC_MEM + 4)
-#define TRC_MEM_DECREASE_RESERVATION (TRC_MEM + 5)
-#define TRC_MEM_POD_POPULATE        (TRC_MEM + 16)
-#define TRC_MEM_POD_ZERO_RECLAIM    (TRC_MEM + 17)
-#define TRC_MEM_POD_SUPERPAGE_SPLINTER (TRC_MEM + 18)
-
-
-#define TRC_PV_HYPERCALL             (TRC_PV +  1)
-#define TRC_PV_TRAP                  (TRC_PV +  3)
-#define TRC_PV_PAGE_FAULT            (TRC_PV +  4)
-#define TRC_PV_FORCED_INVALID_OP     (TRC_PV +  5)
-#define TRC_PV_EMULATE_PRIVOP        (TRC_PV +  6)
-#define TRC_PV_EMULATE_4GB           (TRC_PV +  7)
-#define TRC_PV_MATH_STATE_RESTORE    (TRC_PV +  8)
-#define TRC_PV_PAGING_FIXUP          (TRC_PV +  9)
-#define TRC_PV_GDT_LDT_MAPPING_FAULT (TRC_PV + 10)
-#define TRC_PV_PTWR_EMULATION        (TRC_PV + 11)
-#define TRC_PV_PTWR_EMULATION_PAE    (TRC_PV + 12)
-  /* Indicates that addresses in trace record are 64 bits */
-#define TRC_64_FLAG               (0x100) 
-
-#define TRC_SHADOW_NOT_SHADOW                 (TRC_SHADOW +  1)
-#define TRC_SHADOW_FAST_PROPAGATE             (TRC_SHADOW +  2)
-#define TRC_SHADOW_FAST_MMIO                  (TRC_SHADOW +  3)
-#define TRC_SHADOW_FALSE_FAST_PATH            (TRC_SHADOW +  4)
-#define TRC_SHADOW_MMIO                       (TRC_SHADOW +  5)
-#define TRC_SHADOW_FIXUP                      (TRC_SHADOW +  6)
-#define TRC_SHADOW_DOMF_DYING                 (TRC_SHADOW +  7)
-#define TRC_SHADOW_EMULATE                    (TRC_SHADOW +  8)
-#define TRC_SHADOW_EMULATE_UNSHADOW_USER      (TRC_SHADOW +  9)
-#define TRC_SHADOW_EMULATE_UNSHADOW_EVTINJ    (TRC_SHADOW + 10)
-#define TRC_SHADOW_EMULATE_UNSHADOW_UNHANDLED (TRC_SHADOW + 11)
-#define TRC_SHADOW_WRMAP_BF                   (TRC_SHADOW + 12)
-#define TRC_SHADOW_PREALLOC_UNPIN             (TRC_SHADOW + 13)
-#define TRC_SHADOW_RESYNC_FULL                (TRC_SHADOW + 14)
-#define TRC_SHADOW_RESYNC_ONLY                (TRC_SHADOW + 15)
-
-/* trace events per subclass */
-#define TRC_HVM_NESTEDFLAG      (0x400)
-#define TRC_HVM_VMENTRY         (TRC_HVM_ENTRYEXIT + 0x01)
-#define TRC_HVM_VMEXIT          (TRC_HVM_ENTRYEXIT + 0x02)
-#define TRC_HVM_VMEXIT64        (TRC_HVM_ENTRYEXIT + TRC_64_FLAG + 0x02)
-#define TRC_HVM_PF_XEN          (TRC_HVM_HANDLER + 0x01)
-#define TRC_HVM_PF_XEN64        (TRC_HVM_HANDLER + TRC_64_FLAG + 0x01)
-#define TRC_HVM_PF_INJECT       (TRC_HVM_HANDLER + 0x02)
-#define TRC_HVM_PF_INJECT64     (TRC_HVM_HANDLER + TRC_64_FLAG + 0x02)
-#define TRC_HVM_INJ_EXC         (TRC_HVM_HANDLER + 0x03)
-#define TRC_HVM_INJ_VIRQ        (TRC_HVM_HANDLER + 0x04)
-#define TRC_HVM_REINJ_VIRQ      (TRC_HVM_HANDLER + 0x05)
-#define TRC_HVM_IO_READ         (TRC_HVM_HANDLER + 0x06)
-#define TRC_HVM_IO_WRITE        (TRC_HVM_HANDLER + 0x07)
-#define TRC_HVM_CR_READ         (TRC_HVM_HANDLER + 0x08)
-#define TRC_HVM_CR_READ64       (TRC_HVM_HANDLER + TRC_64_FLAG + 0x08)
-#define TRC_HVM_CR_WRITE        (TRC_HVM_HANDLER + 0x09)
-#define TRC_HVM_CR_WRITE64      (TRC_HVM_HANDLER + TRC_64_FLAG + 0x09)
-#define TRC_HVM_DR_READ         (TRC_HVM_HANDLER + 0x0A)
-#define TRC_HVM_DR_WRITE        (TRC_HVM_HANDLER + 0x0B)
-#define TRC_HVM_MSR_READ        (TRC_HVM_HANDLER + 0x0C)
-#define TRC_HVM_MSR_WRITE       (TRC_HVM_HANDLER + 0x0D)
-#define TRC_HVM_CPUID           (TRC_HVM_HANDLER + 0x0E)
-#define TRC_HVM_INTR            (TRC_HVM_HANDLER + 0x0F)
-#define TRC_HVM_NMI             (TRC_HVM_HANDLER + 0x10)
-#define TRC_HVM_SMI             (TRC_HVM_HANDLER + 0x11)
-#define TRC_HVM_VMMCALL         (TRC_HVM_HANDLER + 0x12)
-#define TRC_HVM_HLT             (TRC_HVM_HANDLER + 0x13)
-#define TRC_HVM_INVLPG          (TRC_HVM_HANDLER + 0x14)
-#define TRC_HVM_INVLPG64        (TRC_HVM_HANDLER + TRC_64_FLAG + 0x14)
-#define TRC_HVM_MCE             (TRC_HVM_HANDLER + 0x15)
-#define TRC_HVM_IOPORT_READ     (TRC_HVM_HANDLER + 0x16)
-#define TRC_HVM_IOMEM_READ      (TRC_HVM_HANDLER + 0x17)
-#define TRC_HVM_CLTS            (TRC_HVM_HANDLER + 0x18)
-#define TRC_HVM_LMSW            (TRC_HVM_HANDLER + 0x19)
-#define TRC_HVM_LMSW64          (TRC_HVM_HANDLER + TRC_64_FLAG + 0x19)
-#define TRC_HVM_RDTSC           (TRC_HVM_HANDLER + 0x1a)
-#define TRC_HVM_INTR_WINDOW     (TRC_HVM_HANDLER + 0x20)
-#define TRC_HVM_NPF             (TRC_HVM_HANDLER + 0x21)
-#define TRC_HVM_REALMODE_EMULATE (TRC_HVM_HANDLER + 0x22)
-#define TRC_HVM_TRAP             (TRC_HVM_HANDLER + 0x23)
-#define TRC_HVM_TRAP_DEBUG       (TRC_HVM_HANDLER + 0x24)
-#define TRC_HVM_VLAPIC           (TRC_HVM_HANDLER + 0x25)
-
-#define TRC_HVM_IOPORT_WRITE    (TRC_HVM_HANDLER + 0x216)
-#define TRC_HVM_IOMEM_WRITE     (TRC_HVM_HANDLER + 0x217)
-
-/* trace events for per class */
-#define TRC_PM_FREQ_CHANGE      (TRC_HW_PM + 0x01)
-#define TRC_PM_IDLE_ENTRY       (TRC_HW_PM + 0x02)
-#define TRC_PM_IDLE_EXIT        (TRC_HW_PM + 0x03)
-
-/* Trace events for IRQs */
-#define TRC_HW_IRQ_MOVE_CLEANUP_DELAY (TRC_HW_IRQ + 0x1)
-#define TRC_HW_IRQ_MOVE_CLEANUP       (TRC_HW_IRQ + 0x2)
-#define TRC_HW_IRQ_BIND_VECTOR        (TRC_HW_IRQ + 0x3)
-#define TRC_HW_IRQ_CLEAR_VECTOR       (TRC_HW_IRQ + 0x4)
-#define TRC_HW_IRQ_MOVE_FINISH        (TRC_HW_IRQ + 0x5)
-#define TRC_HW_IRQ_ASSIGN_VECTOR      (TRC_HW_IRQ + 0x6)
-#define TRC_HW_IRQ_UNMAPPED_VECTOR    (TRC_HW_IRQ + 0x7)
-#define TRC_HW_IRQ_HANDLED            (TRC_HW_IRQ + 0x8)
-
-
-/* This structure represents a single trace buffer record. */
-struct t_rec {
-    uint32_t event:28;
-    uint32_t extra_u32:3;         /* # entries in trailing extra_u32[] array */
-    uint32_t cycles_included:1;   /* u.cycles or u.no_cycles? */
-    union {
-        struct {
-            uint32_t cycles_lo, cycles_hi; /* cycle counter timestamp */
-            uint32_t extra_u32[7];         /* event data items */
-        } cycles;
-        struct {
-            uint32_t extra_u32[7];         /* event data items */
-        } nocycles;
-    } u;
-};
-
-/*
- * This structure contains the metadata for a single trace buffer.  The head
- * field, indexes into an array of struct t_rec's.
- */
-struct t_buf {
-    /* Assume the data buffer size is X.  X is generally not a power of 2.
-     * CONS and PROD are incremented modulo (2*X):
-     *     0 <= cons < 2*X
-     *     0 <= prod < 2*X
-     * This is done because addition modulo X breaks at 2^32 when X is not a
-     * power of 2:
-     *     (((2^32 - 1) % X) + 1) % X != (2^32) % X
-     */
-    uint32_t cons;   /* Offset of next item to be consumed by control tools. */
-    uint32_t prod;   /* Offset of next item to be produced by Xen.           */
-    /*  Records follow immediately after the meta-data header.    */
-};
-
-/* Structure used to pass MFNs to the trace buffers back to trace consumers.
- * Offset is an offset into the mapped structure where the mfn list will be held.
- * MFNs will be at ((unsigned long *)(t_info))+(t_info->cpu_offset[cpu]).
- */
-struct t_info {
-    uint16_t tbuf_size; /* Size in pages of each trace buffer */
-    uint16_t mfn_offset[];  /* Offset within t_info structure of the page list per cpu */
-    /* MFN lists immediately after the header */
-};
-
-#endif /* __XEN_PUBLIC_TRACE_H__ */
-
-/*
- * Local variables:
- * mode: C
- * c-set-style: "BSD"
- * c-basic-offset: 4
- * tab-width: 4
- * indent-tabs-mode: nil
- * End:
- */
diff -Nru xen-4.2.1-new/extras/mini-os/include/xen/vcpu.h xen-4.2.1/extras/mini-os/include/xen/vcpu.h
--- xen-4.2.1-new/extras/mini-os/include/xen/vcpu.h	2014-08-23 21:01:22.000000000 +0800
+++ xen-4.2.1/extras/mini-os/include/xen/vcpu.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,240 +0,0 @@
-/******************************************************************************
- * vcpu.h
- * 
- * VCPU initialisation, query, and hotplug.
- * 
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- * Copyright (c) 2005, Keir Fraser <keir@xensource.com>
- */
-
-#ifndef __XEN_PUBLIC_VCPU_H__
-#define __XEN_PUBLIC_VCPU_H__
-
-#include "xen.h"
-
-/*
- * Prototype for this hypercall is:
- *  int vcpu_op(int cmd, int vcpuid, void *extra_args)
- * @cmd        == VCPUOP_??? (VCPU operation).
- * @vcpuid     == VCPU to operate on.
- * @extra_args == Operation-specific extra arguments (NULL if none).
- */
-
-/*
- * Initialise a VCPU. Each VCPU can be initialised only once. A 
- * newly-initialised VCPU will not run until it is brought up by VCPUOP_up.
- * 
- * @extra_arg == pointer to vcpu_guest_context structure containing initial
- *               state for the VCPU.
- */
-#define VCPUOP_initialise            0
-
-/*
- * Bring up a VCPU. This makes the VCPU runnable. This operation will fail
- * if the VCPU has not been initialised (VCPUOP_initialise).
- */
-#define VCPUOP_up                    1
-
-/*
- * Bring down a VCPU (i.e., make it non-runnable).
- * There are a few caveats that callers should observe:
- *  1. This operation may return, and VCPU_is_up may return false, before the
- *     VCPU stops running (i.e., the command is asynchronous). It is a good
- *     idea to ensure that the VCPU has entered a non-critical loop before
- *     bringing it down. Alternatively, this operation is guaranteed
- *     synchronous if invoked by the VCPU itself.
- *  2. After a VCPU is initialised, there is currently no way to drop all its
- *     references to domain memory. Even a VCPU that is down still holds
- *     memory references via its pagetable base pointer and GDT. It is good
- *     practise to move a VCPU onto an 'idle' or default page table, LDT and
- *     GDT before bringing it down.
- */
-#define VCPUOP_down                  2
-
-/* Returns 1 if the given VCPU is up. */
-#define VCPUOP_is_up                 3
-
-/*
- * Return information about the state and running time of a VCPU.
- * @extra_arg == pointer to vcpu_runstate_info structure.
- */
-#define VCPUOP_get_runstate_info     4
-struct vcpu_runstate_info {
-    /* VCPU's current state (RUNSTATE_*). */
-    int      state;
-    /* When was current state entered (system time, ns)? */
-    uint64_t state_entry_time;
-    /*
-     * Time spent in each RUNSTATE_* (ns). The sum of these times is
-     * guaranteed not to drift from system time.
-     */
-    uint64_t time[4];
-};
-typedef struct vcpu_runstate_info vcpu_runstate_info_t;
-DEFINE_XEN_GUEST_HANDLE(vcpu_runstate_info_t);
-
-/* VCPU is currently running on a physical CPU. */
-#define RUNSTATE_running  0
-
-/* VCPU is runnable, but not currently scheduled on any physical CPU. */
-#define RUNSTATE_runnable 1
-
-/* VCPU is blocked (a.k.a. idle). It is therefore not runnable. */
-#define RUNSTATE_blocked  2
-
-/*
- * VCPU is not runnable, but it is not blocked.
- * This is a 'catch all' state for things like hotplug and pauses by the
- * system administrator (or for critical sections in the hypervisor).
- * RUNSTATE_blocked dominates this state (it is the preferred state).
- */
-#define RUNSTATE_offline  3
-
-/*
- * Register a shared memory area from which the guest may obtain its own
- * runstate information without needing to execute a hypercall.
- * Notes:
- *  1. The registered address may be virtual or physical or guest handle,
- *     depending on the platform. Virtual address or guest handle should be
- *     registered on x86 systems.
- *  2. Only one shared area may be registered per VCPU. The shared area is
- *     updated by the hypervisor each time the VCPU is scheduled. Thus
- *     runstate.state will always be RUNSTATE_running and
- *     runstate.state_entry_time will indicate the system time at which the
- *     VCPU was last scheduled to run.
- * @extra_arg == pointer to vcpu_register_runstate_memory_area structure.
- */
-#define VCPUOP_register_runstate_memory_area 5
-struct vcpu_register_runstate_memory_area {
-    union {
-        XEN_GUEST_HANDLE(vcpu_runstate_info_t) h;
-        struct vcpu_runstate_info *v;
-        uint64_t p;
-    } addr;
-};
-typedef struct vcpu_register_runstate_memory_area vcpu_register_runstate_memory_area_t;
-DEFINE_XEN_GUEST_HANDLE(vcpu_register_runstate_memory_area_t);
-
-/*
- * Set or stop a VCPU's periodic timer. Every VCPU has one periodic timer
- * which can be set via these commands. Periods smaller than one millisecond
- * may not be supported.
- */
-#define VCPUOP_set_periodic_timer    6 /* arg == vcpu_set_periodic_timer_t */
-#define VCPUOP_stop_periodic_timer   7 /* arg == NULL */
-struct vcpu_set_periodic_timer {
-    uint64_t period_ns;
-};
-typedef struct vcpu_set_periodic_timer vcpu_set_periodic_timer_t;
-DEFINE_XEN_GUEST_HANDLE(vcpu_set_periodic_timer_t);
-
-/*
- * Set or stop a VCPU's single-shot timer. Every VCPU has one single-shot
- * timer which can be set via these commands.
- */
-#define VCPUOP_set_singleshot_timer  8 /* arg == vcpu_set_singleshot_timer_t */
-#define VCPUOP_stop_singleshot_timer 9 /* arg == NULL */
-struct vcpu_set_singleshot_timer {
-    uint64_t timeout_abs_ns;   /* Absolute system time value in nanoseconds. */
-    uint32_t flags;            /* VCPU_SSHOTTMR_??? */
-};
-typedef struct vcpu_set_singleshot_timer vcpu_set_singleshot_timer_t;
-DEFINE_XEN_GUEST_HANDLE(vcpu_set_singleshot_timer_t);
-
-/* Flags to VCPUOP_set_singleshot_timer. */
- /* Require the timeout to be in the future (return -ETIME if it's passed). */
-#define _VCPU_SSHOTTMR_future (0)
-#define VCPU_SSHOTTMR_future  (1U << _VCPU_SSHOTTMR_future)
-
-/* 
- * Register a memory location in the guest address space for the
- * vcpu_info structure.  This allows the guest to place the vcpu_info
- * structure in a convenient place, such as in a per-cpu data area.
- * The pointer need not be page aligned, but the structure must not
- * cross a page boundary.
- *
- * This may be called only once per vcpu.
- */
-#define VCPUOP_register_vcpu_info   10  /* arg == vcpu_register_vcpu_info_t */
-struct vcpu_register_vcpu_info {
-    uint64_t mfn;    /* mfn of page to place vcpu_info */
-    uint32_t offset; /* offset within page */
-    uint32_t rsvd;   /* unused */
-};
-typedef struct vcpu_register_vcpu_info vcpu_register_vcpu_info_t;
-DEFINE_XEN_GUEST_HANDLE(vcpu_register_vcpu_info_t);
-
-/* Send an NMI to the specified VCPU. @extra_arg == NULL. */
-#define VCPUOP_send_nmi             11
-
-/* 
- * Get the physical ID information for a pinned vcpu's underlying physical
- * processor.  The physical ID informmation is architecture-specific.
- * On x86: id[31:0]=apic_id, id[63:32]=acpi_id.
- * This command returns -EINVAL if it is not a valid operation for this VCPU.
- */
-#define VCPUOP_get_physid           12 /* arg == vcpu_get_physid_t */
-struct vcpu_get_physid {
-    uint64_t phys_id;
-};
-typedef struct vcpu_get_physid vcpu_get_physid_t;
-DEFINE_XEN_GUEST_HANDLE(vcpu_get_physid_t);
-#define xen_vcpu_physid_to_x86_apicid(physid) ((uint32_t)(physid))
-#define xen_vcpu_physid_to_x86_acpiid(physid) ((uint32_t)((physid) >> 32))
-
-/* 
- * Register a memory location to get a secondary copy of the vcpu time
- * parameters.  The master copy still exists as part of the vcpu shared
- * memory area, and this secondary copy is updated whenever the master copy
- * is updated (and using the same versioning scheme for synchronisation).
- *
- * The intent is that this copy may be mapped (RO) into userspace so
- * that usermode can compute system time using the time info and the
- * tsc.  Usermode will see an array of vcpu_time_info structures, one
- * for each vcpu, and choose the right one by an existing mechanism
- * which allows it to get the current vcpu number (such as via a
- * segment limit).  It can then apply the normal algorithm to compute
- * system time from the tsc.
- *
- * @extra_arg == pointer to vcpu_register_time_info_memory_area structure.
- */
-#define VCPUOP_register_vcpu_time_memory_area   13
-DEFINE_XEN_GUEST_HANDLE(vcpu_time_info_t);
-struct vcpu_register_time_memory_area {
-    union {
-        XEN_GUEST_HANDLE(vcpu_time_info_t) h;
-        struct vcpu_time_info *v;
-        uint64_t p;
-    } addr;
-};
-typedef struct vcpu_register_time_memory_area vcpu_register_time_memory_area_t;
-DEFINE_XEN_GUEST_HANDLE(vcpu_register_time_memory_area_t);
-
-#endif /* __XEN_PUBLIC_VCPU_H__ */
-
-/*
- * Local variables:
- * mode: C
- * c-set-style: "BSD"
- * c-basic-offset: 4
- * tab-width: 4
- * indent-tabs-mode: nil
- * End:
- */
diff -Nru xen-4.2.1-new/extras/mini-os/include/xen/version.h xen-4.2.1/extras/mini-os/include/xen/version.h
--- xen-4.2.1-new/extras/mini-os/include/xen/version.h	2014-08-23 21:01:22.000000000 +0800
+++ xen-4.2.1/extras/mini-os/include/xen/version.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,94 +0,0 @@
-/******************************************************************************
- * version.h
- * 
- * Xen version, type, and compile information.
- * 
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- * Copyright (c) 2005, Nguyen Anh Quynh <aquynh@gmail.com>
- * Copyright (c) 2005, Keir Fraser <keir@xensource.com>
- */
-
-#ifndef __XEN_PUBLIC_VERSION_H__
-#define __XEN_PUBLIC_VERSION_H__
-
-/* NB. All ops return zero on success, except XENVER_{version,pagesize} */
-
-/* arg == NULL; returns major:minor (16:16). */
-#define XENVER_version      0
-
-/* arg == xen_extraversion_t. */
-#define XENVER_extraversion 1
-typedef char xen_extraversion_t[16];
-#define XEN_EXTRAVERSION_LEN (sizeof(xen_extraversion_t))
-
-/* arg == xen_compile_info_t. */
-#define XENVER_compile_info 2
-struct xen_compile_info {
-    char compiler[64];
-    char compile_by[16];
-    char compile_domain[32];
-    char compile_date[32];
-};
-typedef struct xen_compile_info xen_compile_info_t;
-
-#define XENVER_capabilities 3
-typedef char xen_capabilities_info_t[1024];
-#define XEN_CAPABILITIES_INFO_LEN (sizeof(xen_capabilities_info_t))
-
-#define XENVER_changeset 4
-typedef char xen_changeset_info_t[64];
-#define XEN_CHANGESET_INFO_LEN (sizeof(xen_changeset_info_t))
-
-#define XENVER_platform_parameters 5
-struct xen_platform_parameters {
-    unsigned long virt_start;
-};
-typedef struct xen_platform_parameters xen_platform_parameters_t;
-
-#define XENVER_get_features 6
-struct xen_feature_info {
-    unsigned int submap_idx;    /* IN: which 32-bit submap to return */
-    uint32_t     submap;        /* OUT: 32-bit submap */
-};
-typedef struct xen_feature_info xen_feature_info_t;
-
-/* Declares the features reported by XENVER_get_features. */
-#include "features.h"
-
-/* arg == NULL; returns host memory page size. */
-#define XENVER_pagesize 7
-
-/* arg == xen_domain_handle_t. */
-#define XENVER_guest_handle 8
-
-#define XENVER_commandline 9
-typedef char xen_commandline_t[1024];
-
-#endif /* __XEN_PUBLIC_VERSION_H__ */
-
-/*
- * Local variables:
- * mode: C
- * c-set-style: "BSD"
- * c-basic-offset: 4
- * tab-width: 4
- * indent-tabs-mode: nil
- * End:
- */
diff -Nru xen-4.2.1-new/extras/mini-os/include/xen/xencomm.h xen-4.2.1/extras/mini-os/include/xen/xencomm.h
--- xen-4.2.1-new/extras/mini-os/include/xen/xencomm.h	2014-08-23 21:01:22.000000000 +0800
+++ xen-4.2.1/extras/mini-os/include/xen/xencomm.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,41 +0,0 @@
-/*
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- * Copyright (C) IBM Corp. 2006
- */
-
-#ifndef _XEN_XENCOMM_H_
-#define _XEN_XENCOMM_H_
-
-/* A xencomm descriptor is a scatter/gather list containing physical
- * addresses corresponding to a virtually contiguous memory area. The
- * hypervisor translates these physical addresses to machine addresses to copy
- * to and from the virtually contiguous area.
- */
-
-#define XENCOMM_MAGIC 0x58434F4D /* 'XCOM' */
-#define XENCOMM_INVALID (~0UL)
-
-struct xencomm_desc {
-    uint32_t magic;
-    uint32_t nr_addrs; /* the number of entries in address[] */
-    uint64_t address[0];
-};
-
-#endif /* _XEN_XENCOMM_H_ */
diff -Nru xen-4.2.1-new/extras/mini-os/include/xen/xen-compat.h xen-4.2.1/extras/mini-os/include/xen/xen-compat.h
--- xen-4.2.1-new/extras/mini-os/include/xen/xen-compat.h	2014-08-23 21:01:22.000000000 +0800
+++ xen-4.2.1/extras/mini-os/include/xen/xen-compat.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,44 +0,0 @@
-/******************************************************************************
- * xen-compat.h
- * 
- * Guest OS interface to Xen.  Compatibility layer.
- * 
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- * Copyright (c) 2006, Christian Limpach
- */
-
-#ifndef __XEN_PUBLIC_XEN_COMPAT_H__
-#define __XEN_PUBLIC_XEN_COMPAT_H__
-
-#define __XEN_LATEST_INTERFACE_VERSION__ 0x00040200
-
-#if defined(__XEN__) || defined(__XEN_TOOLS__)
-/* Xen is built with matching headers and implements the latest interface. */
-#define __XEN_INTERFACE_VERSION__ __XEN_LATEST_INTERFACE_VERSION__
-#elif !defined(__XEN_INTERFACE_VERSION__)
-/* Guests which do not specify a version get the legacy interface. */
-#define __XEN_INTERFACE_VERSION__ 0x00000000
-#endif
-
-#if __XEN_INTERFACE_VERSION__ > __XEN_LATEST_INTERFACE_VERSION__
-#error "These header files do not support the requested interface version."
-#endif
-
-#endif /* __XEN_PUBLIC_XEN_COMPAT_H__ */
diff -Nru xen-4.2.1-new/extras/mini-os/include/xen/xen.h xen-4.2.1/extras/mini-os/include/xen/xen.h
--- xen-4.2.1-new/extras/mini-os/include/xen/xen.h	2015-10-02 11:31:42.841019336 +0800
+++ xen-4.2.1/extras/mini-os/include/xen/xen.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,843 +0,0 @@
-/******************************************************************************
- * xen.h
- * 
- * Guest OS interface to Xen.
- * 
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- * Copyright (c) 2004, K A Fraser
- */
-
-#ifndef __XEN_PUBLIC_XEN_H__
-#define __XEN_PUBLIC_XEN_H__
-
-#include "xen-compat.h"
-
-#if defined(__i386__) || defined(__x86_64__)
-#include "arch-x86/xen.h"
-#elif defined(__ia64__)
-#include "arch-ia64.h"
-#elif defined(__arm__)
-#include "arch-arm.h"
-#else
-#error "Unsupported architecture"
-#endif
-
-#ifndef __ASSEMBLY__
-/* Guest handles for primitive C types. */
-DEFINE_XEN_GUEST_HANDLE(char);
-__DEFINE_XEN_GUEST_HANDLE(uchar, unsigned char);
-DEFINE_XEN_GUEST_HANDLE(int);
-__DEFINE_XEN_GUEST_HANDLE(uint,  unsigned int);
-DEFINE_XEN_GUEST_HANDLE(long);
-__DEFINE_XEN_GUEST_HANDLE(ulong, unsigned long);
-DEFINE_XEN_GUEST_HANDLE(void);
-
-DEFINE_XEN_GUEST_HANDLE(uint64_t);
-DEFINE_XEN_GUEST_HANDLE(xen_pfn_t);
-#endif
-
-/*
- * HYPERCALLS
- */
-
-/* `incontents 100 hcalls List of hypercalls
- * ` enum hypercall_num { // __HYPERVISOR_* => HYPERVISOR_*()
- */
-
-#define __HYPERVISOR_set_trap_table        0
-#define __HYPERVISOR_mmu_update            1
-#define __HYPERVISOR_set_gdt               2
-#define __HYPERVISOR_stack_switch          3
-#define __HYPERVISOR_set_callbacks         4
-#define __HYPERVISOR_fpu_taskswitch        5
-#define __HYPERVISOR_sched_op_compat       6 /* compat since 0x00030101 */
-#define __HYPERVISOR_platform_op           7
-#define __HYPERVISOR_set_debugreg          8
-#define __HYPERVISOR_get_debugreg          9
-#define __HYPERVISOR_update_descriptor    10
-#define __HYPERVISOR_memory_op            12
-#define __HYPERVISOR_multicall            13
-#define __HYPERVISOR_update_va_mapping    14
-#define __HYPERVISOR_set_timer_op         15
-#define __HYPERVISOR_event_channel_op_compat 16 /* compat since 0x00030202 */
-#define __HYPERVISOR_xen_version          17
-#define __HYPERVISOR_console_io           18
-#define __HYPERVISOR_physdev_op_compat    19 /* compat since 0x00030202 */
-#define __HYPERVISOR_grant_table_op       20
-#define __HYPERVISOR_vm_assist            21
-#define __HYPERVISOR_update_va_mapping_otherdomain 22
-#define __HYPERVISOR_iret                 23 /* x86 only */
-#define __HYPERVISOR_vcpu_op              24
-#define __HYPERVISOR_set_segment_base     25 /* x86/64 only */
-#define __HYPERVISOR_mmuext_op            26
-#define __HYPERVISOR_xsm_op               27
-#define __HYPERVISOR_nmi_op               28
-#define __HYPERVISOR_sched_op             29
-#define __HYPERVISOR_callback_op          30
-#define __HYPERVISOR_xenoprof_op          31
-#define __HYPERVISOR_event_channel_op     32
-#define __HYPERVISOR_physdev_op           33
-#define __HYPERVISOR_hvm_op               34
-#define __HYPERVISOR_sysctl               35
-#define __HYPERVISOR_domctl               36
-#define __HYPERVISOR_kexec_op             37
-#define __HYPERVISOR_tmem_op              38
-#define __HYPERVISOR_xc_reserved_op       39 /* reserved for XenClient */
-
-/* Architecture-specific hypercall definitions. */
-#define __HYPERVISOR_arch_0               48
-#define __HYPERVISOR_arch_1               49
-#define __HYPERVISOR_arch_2               50
-#define __HYPERVISOR_arch_3               51
-#define __HYPERVISOR_arch_4               52
-#define __HYPERVISOR_arch_5               53
-#define __HYPERVISOR_arch_6               54
-#define __HYPERVISOR_arch_7               55
-
-/* ` } */
-
-/*
- * HYPERCALL COMPATIBILITY.
- */
-
-/* New sched_op hypercall introduced in 0x00030101. */
-#if __XEN_INTERFACE_VERSION__ < 0x00030101
-#undef __HYPERVISOR_sched_op
-#define __HYPERVISOR_sched_op __HYPERVISOR_sched_op_compat
-#endif
-
-/* New event-channel and physdev hypercalls introduced in 0x00030202. */
-#if __XEN_INTERFACE_VERSION__ < 0x00030202
-#undef __HYPERVISOR_event_channel_op
-#define __HYPERVISOR_event_channel_op __HYPERVISOR_event_channel_op_compat
-#undef __HYPERVISOR_physdev_op
-#define __HYPERVISOR_physdev_op __HYPERVISOR_physdev_op_compat
-#endif
-
-/* New platform_op hypercall introduced in 0x00030204. */
-#if __XEN_INTERFACE_VERSION__ < 0x00030204
-#define __HYPERVISOR_dom0_op __HYPERVISOR_platform_op
-#endif
-
-/* 
- * VIRTUAL INTERRUPTS
- * 
- * Virtual interrupts that a guest OS may receive from Xen.
- * 
- * In the side comments, 'V.' denotes a per-VCPU VIRQ while 'G.' denotes a
- * global VIRQ. The former can be bound once per VCPU and cannot be re-bound.
- * The latter can be allocated only once per guest: they must initially be
- * allocated to VCPU0 but can subsequently be re-bound.
- */
-/* ` enum virq { */
-#define VIRQ_TIMER      0  /* V. Timebase update, and/or requested timeout.  */
-#define VIRQ_DEBUG      1  /* V. Request guest to dump debug info.           */
-#define VIRQ_CONSOLE    2  /* G. (DOM0) Bytes received on emergency console. */
-#define VIRQ_DOM_EXC    3  /* G. (DOM0) Exceptional event for some domain.   */
-#define VIRQ_TBUF       4  /* G. (DOM0) Trace buffer has records available.  */
-#define VIRQ_DEBUGGER   6  /* G. (DOM0) A domain has paused for debugging.   */
-#define VIRQ_XENOPROF   7  /* V. XenOprofile interrupt: new sample available */
-#define VIRQ_CON_RING   8  /* G. (DOM0) Bytes received on console            */
-#define VIRQ_PCPU_STATE 9  /* G. (DOM0) PCPU state changed                   */
-#define VIRQ_MEM_EVENT  10 /* G. (DOM0) A memory event has occured           */
-#define VIRQ_XC_RESERVED 11 /* G. Reserved for XenClient                     */
-#define VIRQ_ENOMEM     12 /* G. (DOM0) Low on heap memory       */
-
-/* Architecture-specific VIRQ definitions. */
-#define VIRQ_ARCH_0    16
-#define VIRQ_ARCH_1    17
-#define VIRQ_ARCH_2    18
-#define VIRQ_ARCH_3    19
-#define VIRQ_ARCH_4    20
-#define VIRQ_ARCH_5    21
-#define VIRQ_ARCH_6    22
-#define VIRQ_ARCH_7    23
-/* ` } */
-
-#define NR_VIRQS       24
-
-/*
- * ` enum neg_errnoval
- * ` HYPERVISOR_mmu_update(const struct mmu_update reqs[],
- * `                       unsigned count, unsigned *done_out,
- * `                       unsigned foreigndom)
- * `
- * @reqs is an array of mmu_update_t structures ((ptr, val) pairs).
- * @count is the length of the above array.
- * @pdone is an output parameter indicating number of completed operations
- * @foreigndom[15:0]: FD, the expected owner of data pages referenced in this
- *                    hypercall invocation. Can be DOMID_SELF.
- * @foreigndom[31:16]: PFD, the expected owner of pagetable pages referenced
- *                     in this hypercall invocation. The value of this field
- *                     (x) encodes the PFD as follows:
- *                     x == 0 => PFD == DOMID_SELF
- *                     x != 0 => PFD == x - 1
- * 
- * Sub-commands: ptr[1:0] specifies the appropriate MMU_* command.
- * -------------
- * ptr[1:0] == MMU_NORMAL_PT_UPDATE:
- * Updates an entry in a page table belonging to PFD. If updating an L1 table,
- * and the new table entry is valid/present, the mapped frame must belong to
- * FD. If attempting to map an I/O page then the caller assumes the privilege
- * of the FD.
- * FD == DOMID_IO: Permit /only/ I/O mappings, at the priv level of the caller.
- * FD == DOMID_XEN: Map restricted areas of Xen's heap space.
- * ptr[:2]  -- Machine address of the page-table entry to modify.
- * val      -- Value to write.
- *
- * There also certain implicit requirements when using this hypercall. The
- * pages that make up a pagetable must be mapped read-only in the guest.
- * This prevents uncontrolled guest updates to the pagetable. Xen strictly
- * enforces this, and will disallow any pagetable update which will end up
- * mapping pagetable page RW, and will disallow using any writable page as a
- * pagetable. In practice it means that when constructing a page table for a
- * process, thread, etc, we MUST be very dilligient in following these rules:
- *  1). Start with top-level page (PGD or in Xen language: L4). Fill out
- *      the entries.
- *  2). Keep on going, filling out the upper (PUD or L3), and middle (PMD
- *      or L2).
- *  3). Start filling out the PTE table (L1) with the PTE entries. Once
- *  	done, make sure to set each of those entries to RO (so writeable bit
- *  	is unset). Once that has been completed, set the PMD (L2) for this
- *  	PTE table as RO.
- *  4). When completed with all of the PMD (L2) entries, and all of them have
- *  	been set to RO, make sure to set RO the PUD (L3). Do the same
- *  	operation on PGD (L4) pagetable entries that have a PUD (L3) entry.
- *  5). Now before you can use those pages (so setting the cr3), you MUST also
- *      pin them so that the hypervisor can verify the entries. This is done
- *      via the HYPERVISOR_mmuext_op(MMUEXT_PIN_L4_TABLE, guest physical frame
- *      number of the PGD (L4)). And this point the HYPERVISOR_mmuext_op(
- *      MMUEXT_NEW_BASEPTR, guest physical frame number of the PGD (L4)) can be
- *      issued.
- * For 32-bit guests, the L4 is not used (as there is less pagetables), so
- * instead use L3.
- * At this point the pagetables can be modified using the MMU_NORMAL_PT_UPDATE
- * hypercall. Also if so desired the OS can also try to write to the PTE
- * and be trapped by the hypervisor (as the PTE entry is RO).
- *
- * To deallocate the pages, the operations are the reverse of the steps
- * mentioned above. The argument is MMUEXT_UNPIN_TABLE for all levels and the
- * pagetable MUST not be in use (meaning that the cr3 is not set to it).
- * 
- * ptr[1:0] == MMU_MACHPHYS_UPDATE:
- * Updates an entry in the machine->pseudo-physical mapping table.
- * ptr[:2]  -- Machine address within the frame whose mapping to modify.
- *             The frame must belong to the FD, if one is specified.
- * val      -- Value to write into the mapping entry.
- * 
- * ptr[1:0] == MMU_PT_UPDATE_PRESERVE_AD:
- * As MMU_NORMAL_PT_UPDATE above, but A/D bits currently in the PTE are ORed
- * with those in @val.
- *
- * @val is usually the machine frame number along with some attributes.
- * The attributes by default follow the architecture defined bits. Meaning that
- * if this is a X86_64 machine and four page table layout is used, the layout
- * of val is:
- *  - 63 if set means No execute (NX)
- *  - 46-13 the machine frame number
- *  - 12 available for guest
- *  - 11 available for guest
- *  - 10 available for guest
- *  - 9 available for guest
- *  - 8 global
- *  - 7 PAT (PSE is disabled, must use hypercall to make 4MB or 2MB pages)
- *  - 6 dirty
- *  - 5 accessed
- *  - 4 page cached disabled
- *  - 3 page write through
- *  - 2 userspace accessible
- *  - 1 writeable
- *  - 0 present
- *
- *  The one bits that does not fit with the default layout is the PAGE_PSE
- *  also called PAGE_PAT). The MMUEXT_[UN]MARK_SUPER arguments to the
- *  HYPERVISOR_mmuext_op serve as mechanism to set a pagetable to be 4MB
- *  (or 2MB) instead of using the PAGE_PSE bit.
- *
- *  The reason that the PAGE_PSE (bit 7) is not being utilized is due to Xen
- *  using it as the Page Attribute Table (PAT) bit - for details on it please
- *  refer to Intel SDM 10.12. The PAT allows to set the caching attributes of
- *  pages instead of using MTRRs.
- *
- *  The PAT MSR is as follow (it is a 64-bit value, each entry is 8 bits):
- *             PAT4                 PAT0
- *   +---+----+----+----+-----+----+----+
- *    WC | WC | WB | UC | UC- | WC | WB |  <= Linux
- *   +---+----+----+----+-----+----+----+
- *    WC | WT | WB | UC | UC- | WT | WB |  <= BIOS (default when machine boots)
- *   +---+----+----+----+-----+----+----+
- *    WC | WP | WC | UC | UC- | WT | WB |  <= Xen
- *   +---+----+----+----+-----+----+----+
- *
- *  The lookup of this index table translates to looking up
- *  Bit 7, Bit 4, and Bit 3 of val entry:
- *
- *  PAT/PSE (bit 7) ... PCD (bit 4) .. PWT (bit 3).
- *
- *  If all bits are off, then we are using PAT0. If bit 3 turned on,
- *  then we are using PAT1, if bit 3 and bit 4, then PAT2..
- *
- *  As you can see, the Linux PAT1 translates to PAT4 under Xen. Which means
- *  that if a guest that follows Linux's PAT setup and would like to set Write
- *  Combined on pages it MUST use PAT4 entry. Meaning that Bit 7 (PAGE_PAT) is
- *  set. For example, under Linux it only uses PAT0, PAT1, and PAT2 for the
- *  caching as:
- *
- *   WB = none (so PAT0)
- *   WC = PWT (bit 3 on)
- *   UC = PWT | PCD (bit 3 and 4 are on).
- *
- * To make it work with Xen, it needs to translate the WC bit as so:
- *
- *  PWT (so bit 3 on) --> PAT (so bit 7 is on) and clear bit 3
- *
- * And to translate back it would:
- *
- * PAT (bit 7 on) --> PWT (bit 3 on) and clear bit 7.
- */
-#define MMU_NORMAL_PT_UPDATE      0 /* checked '*ptr = val'. ptr is MA.      */
-#define MMU_MACHPHYS_UPDATE       1 /* ptr = MA of frame to modify entry for */
-#define MMU_PT_UPDATE_PRESERVE_AD 2 /* atomically: *ptr = val | (*ptr&(A|D)) */
-
-/*
- * MMU EXTENDED OPERATIONS
- * 
- * HYPERVISOR_mmuext_op() accepts a list of mmuext_op structures.
- * A foreigndom (FD) can be specified (or DOMID_SELF for none).
- * Where the FD has some effect, it is described below.
- * 
- * cmd: MMUEXT_(UN)PIN_*_TABLE
- * mfn: Machine frame number to be (un)pinned as a p.t. page.
- *      The frame must belong to the FD, if one is specified.
- * 
- * cmd: MMUEXT_NEW_BASEPTR
- * mfn: Machine frame number of new page-table base to install in MMU.
- * 
- * cmd: MMUEXT_NEW_USER_BASEPTR [x86/64 only]
- * mfn: Machine frame number of new page-table base to install in MMU
- *      when in user space.
- * 
- * cmd: MMUEXT_TLB_FLUSH_LOCAL
- * No additional arguments. Flushes local TLB.
- * 
- * cmd: MMUEXT_INVLPG_LOCAL
- * linear_addr: Linear address to be flushed from the local TLB.
- * 
- * cmd: MMUEXT_TLB_FLUSH_MULTI
- * vcpumask: Pointer to bitmap of VCPUs to be flushed.
- * 
- * cmd: MMUEXT_INVLPG_MULTI
- * linear_addr: Linear address to be flushed.
- * vcpumask: Pointer to bitmap of VCPUs to be flushed.
- * 
- * cmd: MMUEXT_TLB_FLUSH_ALL
- * No additional arguments. Flushes all VCPUs' TLBs.
- * 
- * cmd: MMUEXT_INVLPG_ALL
- * linear_addr: Linear address to be flushed from all VCPUs' TLBs.
- * 
- * cmd: MMUEXT_FLUSH_CACHE
- * No additional arguments. Writes back and flushes cache contents.
- *
- * cmd: MMUEXT_FLUSH_CACHE_GLOBAL
- * No additional arguments. Writes back and flushes cache contents
- * on all CPUs in the system.
- * 
- * cmd: MMUEXT_SET_LDT
- * linear_addr: Linear address of LDT base (NB. must be page-aligned).
- * nr_ents: Number of entries in LDT.
- *
- * cmd: MMUEXT_CLEAR_PAGE
- * mfn: Machine frame number to be cleared.
- *
- * cmd: MMUEXT_COPY_PAGE
- * mfn: Machine frame number of the destination page.
- * src_mfn: Machine frame number of the source page.
- *
- * cmd: MMUEXT_[UN]MARK_SUPER
- * mfn: Machine frame number of head of superpage to be [un]marked.
- */
-#define MMUEXT_PIN_L1_TABLE      0
-#define MMUEXT_PIN_L2_TABLE      1
-#define MMUEXT_PIN_L3_TABLE      2
-#define MMUEXT_PIN_L4_TABLE      3
-#define MMUEXT_UNPIN_TABLE       4
-#define MMUEXT_NEW_BASEPTR       5
-#define MMUEXT_TLB_FLUSH_LOCAL   6
-#define MMUEXT_INVLPG_LOCAL      7
-#define MMUEXT_TLB_FLUSH_MULTI   8
-#define MMUEXT_INVLPG_MULTI      9
-#define MMUEXT_TLB_FLUSH_ALL    10
-#define MMUEXT_INVLPG_ALL       11
-#define MMUEXT_FLUSH_CACHE      12
-#define MMUEXT_SET_LDT          13
-#define MMUEXT_NEW_USER_BASEPTR 15
-#define MMUEXT_CLEAR_PAGE       16
-#define MMUEXT_COPY_PAGE        17
-#define MMUEXT_FLUSH_CACHE_GLOBAL 18
-#define MMUEXT_MARK_SUPER       19
-#define MMUEXT_UNMARK_SUPER     20
-
-#ifndef __ASSEMBLY__
-struct mmuext_op {
-    unsigned int cmd;
-    union {
-        /* [UN]PIN_TABLE, NEW_BASEPTR, NEW_USER_BASEPTR
-         * CLEAR_PAGE, COPY_PAGE, [UN]MARK_SUPER */
-        xen_pfn_t     mfn;
-        /* INVLPG_LOCAL, INVLPG_ALL, SET_LDT */
-        unsigned long linear_addr;
-    } arg1;
-    union {
-        /* SET_LDT */
-        unsigned int nr_ents;
-        /* TLB_FLUSH_MULTI, INVLPG_MULTI */
-#if __XEN_INTERFACE_VERSION__ >= 0x00030205
-        XEN_GUEST_HANDLE(const_void) vcpumask;
-#else
-        const void *vcpumask;
-#endif
-        /* COPY_PAGE */
-        xen_pfn_t src_mfn;
-    } arg2;
-};
-typedef struct mmuext_op mmuext_op_t;
-DEFINE_XEN_GUEST_HANDLE(mmuext_op_t);
-#endif
-
-/* These are passed as 'flags' to update_va_mapping. They can be ORed. */
-/* When specifying UVMF_MULTI, also OR in a pointer to a CPU bitmap.   */
-/* UVMF_LOCAL is merely UVMF_MULTI with a NULL bitmap pointer.         */
-#define UVMF_NONE               (0UL<<0) /* No flushing at all.   */
-#define UVMF_TLB_FLUSH          (1UL<<0) /* Flush entire TLB(s).  */
-#define UVMF_INVLPG             (2UL<<0) /* Flush only one entry. */
-#define UVMF_FLUSHTYPE_MASK     (3UL<<0)
-#define UVMF_MULTI              (0UL<<2) /* Flush subset of TLBs. */
-#define UVMF_LOCAL              (0UL<<2) /* Flush local TLB.      */
-#define UVMF_ALL                (1UL<<2) /* Flush all TLBs.       */
-
-/*
- * Commands to HYPERVISOR_console_io().
- */
-#define CONSOLEIO_write         0
-#define CONSOLEIO_read          1
-
-/*
- * Commands to HYPERVISOR_vm_assist().
- */
-#define VMASST_CMD_enable                0
-#define VMASST_CMD_disable               1
-
-/* x86/32 guests: simulate full 4GB segment limits. */
-#define VMASST_TYPE_4gb_segments         0
-
-/* x86/32 guests: trap (vector 15) whenever above vmassist is used. */
-#define VMASST_TYPE_4gb_segments_notify  1
-
-/*
- * x86 guests: support writes to bottom-level PTEs.
- * NB1. Page-directory entries cannot be written.
- * NB2. Guest must continue to remove all writable mappings of PTEs.
- */
-#define VMASST_TYPE_writable_pagetables  2
-
-/* x86/PAE guests: support PDPTs above 4GB. */
-#define VMASST_TYPE_pae_extended_cr3     3
-
-#define MAX_VMASST_TYPE                  3
-
-#ifndef __ASSEMBLY__
-
-typedef uint16_t domid_t;
-
-/* Domain ids >= DOMID_FIRST_RESERVED cannot be used for ordinary domains. */
-#define DOMID_FIRST_RESERVED (0x7FF0U)
-
-/* DOMID_SELF is used in certain contexts to refer to oneself. */
-#define DOMID_SELF (0x7FF0U)
-
-/*
- * DOMID_IO is used to restrict page-table updates to mapping I/O memory.
- * Although no Foreign Domain need be specified to map I/O pages, DOMID_IO
- * is useful to ensure that no mappings to the OS's own heap are accidentally
- * installed. (e.g., in Linux this could cause havoc as reference counts
- * aren't adjusted on the I/O-mapping code path).
- * This only makes sense in MMUEXT_SET_FOREIGNDOM, but in that context can
- * be specified by any calling domain.
- */
-#define DOMID_IO   (0x7FF1U)
-
-/*
- * DOMID_XEN is used to allow privileged domains to map restricted parts of
- * Xen's heap space (e.g., the machine_to_phys table).
- * This only makes sense in MMUEXT_SET_FOREIGNDOM, and is only permitted if
- * the caller is privileged.
- */
-#define DOMID_XEN  (0x7FF2U)
-
-/*
- * DOMID_COW is used as the owner of sharable pages */
-#define DOMID_COW  (0x7FF3U)
-
-/* DOMID_INVALID is used to identify pages with unknown owner. */
-#define DOMID_INVALID (0x7FF4U)
-
-/* Idle domain. */
-#define DOMID_IDLE (0x7FFFU)
-
-/*
- * Send an array of these to HYPERVISOR_mmu_update().
- * NB. The fields are natural pointer/address size for this architecture.
- */
-struct mmu_update {
-    uint64_t ptr;       /* Machine address of PTE. */
-    uint64_t val;       /* New contents of PTE.    */
-};
-typedef struct mmu_update mmu_update_t;
-DEFINE_XEN_GUEST_HANDLE(mmu_update_t);
-
-/*
- * Send an array of these to HYPERVISOR_multicall().
- * NB. The fields are natural register size for this architecture.
- */
-struct multicall_entry {
-    unsigned long op, result;
-    unsigned long args[6];
-};
-typedef struct multicall_entry multicall_entry_t;
-DEFINE_XEN_GUEST_HANDLE(multicall_entry_t);
-
-/*
- * Event channel endpoints per domain:
- *  1024 if a long is 32 bits; 4096 if a long is 64 bits.
- */
-#define NR_EVENT_CHANNELS (sizeof(unsigned long) * sizeof(unsigned long) * 64)
-
-struct vcpu_time_info {
-    /*
-     * Updates to the following values are preceded and followed by an
-     * increment of 'version'. The guest can therefore detect updates by
-     * looking for changes to 'version'. If the least-significant bit of
-     * the version number is set then an update is in progress and the guest
-     * must wait to read a consistent set of values.
-     * The correct way to interact with the version number is similar to
-     * Linux's seqlock: see the implementations of read_seqbegin/read_seqretry.
-     */
-    uint32_t version;
-    uint32_t pad0;
-    uint64_t tsc_timestamp;   /* TSC at last update of time vals.  */
-    uint64_t system_time;     /* Time, in nanosecs, since boot.    */
-    /*
-     * Current system time:
-     *   system_time +
-     *   ((((tsc - tsc_timestamp) << tsc_shift) * tsc_to_system_mul) >> 32)
-     * CPU frequency (Hz):
-     *   ((10^9 << 32) / tsc_to_system_mul) >> tsc_shift
-     */
-    uint32_t tsc_to_system_mul;
-    int8_t   tsc_shift;
-    int8_t   pad1[3];
-}; /* 32 bytes */
-typedef struct vcpu_time_info vcpu_time_info_t;
-
-struct vcpu_info {
-    /*
-     * 'evtchn_upcall_pending' is written non-zero by Xen to indicate
-     * a pending notification for a particular VCPU. It is then cleared 
-     * by the guest OS /before/ checking for pending work, thus avoiding
-     * a set-and-check race. Note that the mask is only accessed by Xen
-     * on the CPU that is currently hosting the VCPU. This means that the
-     * pending and mask flags can be updated by the guest without special
-     * synchronisation (i.e., no need for the x86 LOCK prefix).
-     * This may seem suboptimal because if the pending flag is set by
-     * a different CPU then an IPI may be scheduled even when the mask
-     * is set. However, note:
-     *  1. The task of 'interrupt holdoff' is covered by the per-event-
-     *     channel mask bits. A 'noisy' event that is continually being
-     *     triggered can be masked at source at this very precise
-     *     granularity.
-     *  2. The main purpose of the per-VCPU mask is therefore to restrict
-     *     reentrant execution: whether for concurrency control, or to
-     *     prevent unbounded stack usage. Whatever the purpose, we expect
-     *     that the mask will be asserted only for short periods at a time,
-     *     and so the likelihood of a 'spurious' IPI is suitably small.
-     * The mask is read before making an event upcall to the guest: a
-     * non-zero mask therefore guarantees that the VCPU will not receive
-     * an upcall activation. The mask is cleared when the VCPU requests
-     * to block: this avoids wakeup-waiting races.
-     */
-    uint8_t evtchn_upcall_pending;
-    uint8_t evtchn_upcall_mask;
-    unsigned long evtchn_pending_sel;
-    struct arch_vcpu_info arch;
-    struct vcpu_time_info time;
-}; /* 64 bytes (x86) */
-#ifndef __XEN__
-typedef struct vcpu_info vcpu_info_t;
-#endif
-
-/*
- * Xen/kernel shared data -- pointer provided in start_info.
- *
- * This structure is defined to be both smaller than a page, and the
- * only data on the shared page, but may vary in actual size even within
- * compatible Xen versions; guests should not rely on the size
- * of this structure remaining constant.
- */
-struct shared_info {
-    struct vcpu_info vcpu_info[XEN_LEGACY_MAX_VCPUS];
-
-    /*
-     * A domain can create "event channels" on which it can send and receive
-     * asynchronous event notifications. There are three classes of event that
-     * are delivered by this mechanism:
-     *  1. Bi-directional inter- and intra-domain connections. Domains must
-     *     arrange out-of-band to set up a connection (usually by allocating
-     *     an unbound 'listener' port and avertising that via a storage service
-     *     such as xenstore).
-     *  2. Physical interrupts. A domain with suitable hardware-access
-     *     privileges can bind an event-channel port to a physical interrupt
-     *     source.
-     *  3. Virtual interrupts ('events'). A domain can bind an event-channel
-     *     port to a virtual interrupt source, such as the virtual-timer
-     *     device or the emergency console.
-     * 
-     * Event channels are addressed by a "port index". Each channel is
-     * associated with two bits of information:
-     *  1. PENDING -- notifies the domain that there is a pending notification
-     *     to be processed. This bit is cleared by the guest.
-     *  2. MASK -- if this bit is clear then a 0->1 transition of PENDING
-     *     will cause an asynchronous upcall to be scheduled. This bit is only
-     *     updated by the guest. It is read-only within Xen. If a channel
-     *     becomes pending while the channel is masked then the 'edge' is lost
-     *     (i.e., when the channel is unmasked, the guest must manually handle
-     *     pending notifications as no upcall will be scheduled by Xen).
-     * 
-     * To expedite scanning of pending notifications, any 0->1 pending
-     * transition on an unmasked channel causes a corresponding bit in a
-     * per-vcpu selector word to be set. Each bit in the selector covers a
-     * 'C long' in the PENDING bitfield array.
-     */
-    unsigned long evtchn_pending[sizeof(unsigned long) * 8];
-    unsigned long evtchn_mask[sizeof(unsigned long) * 8];
-
-    /*
-     * Wallclock time: updated only by control software. Guests should base
-     * their gettimeofday() syscall on this wallclock-base value.
-     */
-    uint32_t wc_version;      /* Version counter: see vcpu_time_info_t. */
-    uint32_t wc_sec;          /* Secs  00:00:00 UTC, Jan 1, 1970.  */
-    uint32_t wc_nsec;         /* Nsecs 00:00:00 UTC, Jan 1, 1970.  */
-
-    struct arch_shared_info arch;
-
-};
-#ifndef __XEN__
-typedef struct shared_info shared_info_t;
-#endif
-
-/*
- * Start-of-day memory layout:
- *  1. The domain is started within contiguous virtual-memory region.
- *  2. The contiguous region ends on an aligned 4MB boundary.
- *  3. This the order of bootstrap elements in the initial virtual region:
- *      a. relocated kernel image
- *      b. initial ram disk              [mod_start, mod_len]
- *      c. list of allocated page frames [mfn_list, nr_pages]
- *         (unless relocated due to XEN_ELFNOTE_INIT_P2M)
- *      d. start_info_t structure        [register ESI (x86)]
- *      e. bootstrap page tables         [pt_base, CR3 (x86)]
- *      f. bootstrap stack               [register ESP (x86)]
- *  4. Bootstrap elements are packed together, but each is 4kB-aligned.
- *  5. The initial ram disk may be omitted.
- *  6. The list of page frames forms a contiguous 'pseudo-physical' memory
- *     layout for the domain. In particular, the bootstrap virtual-memory
- *     region is a 1:1 mapping to the first section of the pseudo-physical map.
- *  7. All bootstrap elements are mapped read-writable for the guest OS. The
- *     only exception is the bootstrap page table, which is mapped read-only.
- *  8. There is guaranteed to be at least 512kB padding after the final
- *     bootstrap element. If necessary, the bootstrap virtual region is
- *     extended by an extra 4MB to ensure this.
- */
-
-#define MAX_GUEST_CMDLINE 1024
-struct start_info {
-    /* THE FOLLOWING ARE FILLED IN BOTH ON INITIAL BOOT AND ON RESUME.    */
-    char magic[32];             /* "xen-<version>-<platform>".            */
-    unsigned long nr_pages;     /* Total pages allocated to this domain.  */
-    unsigned long shared_info;  /* MACHINE address of shared info struct. */
-    uint32_t flags;             /* SIF_xxx flags.                         */
-    xen_pfn_t store_mfn;        /* MACHINE page number of shared page.    */
-    uint32_t store_evtchn;      /* Event channel for store communication. */
-    union {
-        struct {
-            xen_pfn_t mfn;      /* MACHINE page number of console page.   */
-            uint32_t  evtchn;   /* Event channel for console page.        */
-        } domU;
-        struct {
-            uint32_t info_off;  /* Offset of console_info struct.         */
-            uint32_t info_size; /* Size of console_info struct from start.*/
-        } dom0;
-    } console;
-    /* THE FOLLOWING ARE ONLY FILLED IN ON INITIAL BOOT (NOT RESUME).     */
-    unsigned long pt_base;      /* VIRTUAL address of page directory.     */
-    unsigned long nr_pt_frames; /* Number of bootstrap p.t. frames.       */
-    unsigned long mfn_list;     /* VIRTUAL address of page-frame list.    */
-    unsigned long mod_start;    /* VIRTUAL address of pre-loaded module   */
-                                /* (PFN of pre-loaded module if           */
-                                /*  SIF_MOD_START_PFN set in flags).      */
-    unsigned long mod_len;      /* Size (bytes) of pre-loaded module.     */
-    int8_t cmd_line[MAX_GUEST_CMDLINE];
-    /* The pfn range here covers both page table and p->m table frames.   */
-    unsigned long first_p2m_pfn;/* 1st pfn forming initial P->M table.    */
-    unsigned long nr_p2m_frames;/* # of pfns forming initial P->M table.  */
-};
-typedef struct start_info start_info_t;
-
-/* New console union for dom0 introduced in 0x00030203. */
-#if __XEN_INTERFACE_VERSION__ < 0x00030203
-#define console_mfn    console.domU.mfn
-#define console_evtchn console.domU.evtchn
-#endif
-
-/* These flags are passed in the 'flags' field of start_info_t. */
-#define SIF_PRIVILEGED    (1<<0)  /* Is the domain privileged? */
-#define SIF_INITDOMAIN    (1<<1)  /* Is this the initial control domain? */
-#define SIF_MULTIBOOT_MOD (1<<2)  /* Is mod_start a multiboot module? */
-#define SIF_MOD_START_PFN (1<<3)  /* Is mod_start a PFN? */
-#define SIF_PM_MASK       (0xFF<<8) /* reserve 1 byte for xen-pm options */
-
-/*
- * A multiboot module is a package containing modules very similar to a
- * multiboot module array. The only differences are:
- * - the array of module descriptors is by convention simply at the beginning
- *   of the multiboot module,
- * - addresses in the module descriptors are based on the beginning of the
- *   multiboot module,
- * - the number of modules is determined by a termination descriptor that has
- *   mod_start == 0.
- *
- * This permits to both build it statically and reference it in a configuration
- * file, and let the PV guest easily rebase the addresses to virtual addresses
- * and at the same time count the number of modules.
- */
-struct xen_multiboot_mod_list
-{
-    /* Address of first byte of the module */
-    uint32_t mod_start;
-    /* Address of last byte of the module (inclusive) */
-    uint32_t mod_end;
-    /* Address of zero-terminated command line */
-    uint32_t cmdline;
-    /* Unused, must be zero */
-    uint32_t pad;
-};
-
-typedef struct dom0_vga_console_info {
-    uint8_t video_type; /* DOM0_VGA_CONSOLE_??? */
-#define XEN_VGATYPE_TEXT_MODE_3 0x03
-#define XEN_VGATYPE_VESA_LFB    0x23
-#define XEN_VGATYPE_EFI_LFB     0x70
-
-    union {
-        struct {
-            /* Font height, in pixels. */
-            uint16_t font_height;
-            /* Cursor location (column, row). */
-            uint16_t cursor_x, cursor_y;
-            /* Number of rows and columns (dimensions in characters). */
-            uint16_t rows, columns;
-        } text_mode_3;
-
-        struct {
-            /* Width and height, in pixels. */
-            uint16_t width, height;
-            /* Bytes per scan line. */
-            uint16_t bytes_per_line;
-            /* Bits per pixel. */
-            uint16_t bits_per_pixel;
-            /* LFB physical address, and size (in units of 64kB). */
-            uint32_t lfb_base;
-            uint32_t lfb_size;
-            /* RGB mask offsets and sizes, as defined by VBE 1.2+ */
-            uint8_t  red_pos, red_size;
-            uint8_t  green_pos, green_size;
-            uint8_t  blue_pos, blue_size;
-            uint8_t  rsvd_pos, rsvd_size;
-#if __XEN_INTERFACE_VERSION__ >= 0x00030206
-            /* VESA capabilities (offset 0xa, VESA command 0x4f00). */
-            uint32_t gbl_caps;
-            /* Mode attributes (offset 0x0, VESA command 0x4f01). */
-            uint16_t mode_attrs;
-#endif
-        } vesa_lfb;
-    } u;
-} dom0_vga_console_info_t;
-#define xen_vga_console_info dom0_vga_console_info
-#define xen_vga_console_info_t dom0_vga_console_info_t
-
-typedef uint8_t xen_domain_handle_t[16];
-
-/* Turn a plain number into a C unsigned long constant. */
-#define __mk_unsigned_long(x) x ## UL
-#define mk_unsigned_long(x) __mk_unsigned_long(x)
-
-__DEFINE_XEN_GUEST_HANDLE(uint8,  uint8_t);
-__DEFINE_XEN_GUEST_HANDLE(uint16, uint16_t);
-__DEFINE_XEN_GUEST_HANDLE(uint32, uint32_t);
-__DEFINE_XEN_GUEST_HANDLE(uint64, uint64_t);
-
-#else /* __ASSEMBLY__ */
-
-/* In assembly code we cannot use C numeric constant suffixes. */
-#define mk_unsigned_long(x) x
-
-#endif /* !__ASSEMBLY__ */
-
-/* Default definitions for macros used by domctl/sysctl. */
-#if defined(__XEN__) || defined(__XEN_TOOLS__)
-
-#ifndef uint64_aligned_t
-#define uint64_aligned_t uint64_t
-#endif
-#ifndef XEN_GUEST_HANDLE_64
-#define XEN_GUEST_HANDLE_64(name) XEN_GUEST_HANDLE(name)
-#endif
-
-#ifndef __ASSEMBLY__
-struct xenctl_cpumap {
-    XEN_GUEST_HANDLE_64(uint8) bitmap;
-    uint32_t nr_cpus;
-};
-#endif
-
-#endif /* defined(__XEN__) || defined(__XEN_TOOLS__) */
-
-#endif /* __XEN_PUBLIC_XEN_H__ */
-
-/*
- * Local variables:
- * mode: C
- * c-set-style: "BSD"
- * c-basic-offset: 4
- * tab-width: 4
- * indent-tabs-mode: nil
- * End:
- */
diff -Nru xen-4.2.1-new/extras/mini-os/include/xen/xenoprof.h xen-4.2.1/extras/mini-os/include/xen/xenoprof.h
--- xen-4.2.1-new/extras/mini-os/include/xen/xenoprof.h	2014-08-23 21:01:22.000000000 +0800
+++ xen-4.2.1/extras/mini-os/include/xen/xenoprof.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,152 +0,0 @@
-/******************************************************************************
- * xenoprof.h
- * 
- * Interface for enabling system wide profiling based on hardware performance
- * counters
- * 
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- * Copyright (C) 2005 Hewlett-Packard Co.
- * Written by Aravind Menon & Jose Renato Santos
- */
-
-#ifndef __XEN_PUBLIC_XENOPROF_H__
-#define __XEN_PUBLIC_XENOPROF_H__
-
-#include "xen.h"
-
-/*
- * Commands to HYPERVISOR_xenoprof_op().
- */
-#define XENOPROF_init                0
-#define XENOPROF_reset_active_list   1
-#define XENOPROF_reset_passive_list  2
-#define XENOPROF_set_active          3
-#define XENOPROF_set_passive         4
-#define XENOPROF_reserve_counters    5
-#define XENOPROF_counter             6
-#define XENOPROF_setup_events        7
-#define XENOPROF_enable_virq         8
-#define XENOPROF_start               9
-#define XENOPROF_stop               10
-#define XENOPROF_disable_virq       11
-#define XENOPROF_release_counters   12
-#define XENOPROF_shutdown           13
-#define XENOPROF_get_buffer         14
-#define XENOPROF_set_backtrace      15
-
-/* AMD IBS support */
-#define XENOPROF_get_ibs_caps       16
-#define XENOPROF_ibs_counter        17
-#define XENOPROF_last_op            17
-
-#define MAX_OPROF_EVENTS    32
-#define MAX_OPROF_DOMAINS   25
-#define XENOPROF_CPU_TYPE_SIZE 64
-
-/* Xenoprof performance events (not Xen events) */
-struct event_log {
-    uint64_t eip;
-    uint8_t mode;
-    uint8_t event;
-};
-
-/* PC value that indicates a special code */
-#define XENOPROF_ESCAPE_CODE (~0ULL)
-/* Transient events for the xenoprof->oprofile cpu buf */
-#define XENOPROF_TRACE_BEGIN 1
-
-/* Xenoprof buffer shared between Xen and domain - 1 per VCPU */
-struct xenoprof_buf {
-    uint32_t event_head;
-    uint32_t event_tail;
-    uint32_t event_size;
-    uint32_t vcpu_id;
-    uint64_t xen_samples;
-    uint64_t kernel_samples;
-    uint64_t user_samples;
-    uint64_t lost_samples;
-    struct event_log event_log[1];
-};
-#ifndef __XEN__
-typedef struct xenoprof_buf xenoprof_buf_t;
-DEFINE_XEN_GUEST_HANDLE(xenoprof_buf_t);
-#endif
-
-struct xenoprof_init {
-    int32_t  num_events;
-    int32_t  is_primary;
-    char cpu_type[XENOPROF_CPU_TYPE_SIZE];
-};
-typedef struct xenoprof_init xenoprof_init_t;
-DEFINE_XEN_GUEST_HANDLE(xenoprof_init_t);
-
-struct xenoprof_get_buffer {
-    int32_t  max_samples;
-    int32_t  nbuf;
-    int32_t  bufsize;
-    uint64_t buf_gmaddr;
-};
-typedef struct xenoprof_get_buffer xenoprof_get_buffer_t;
-DEFINE_XEN_GUEST_HANDLE(xenoprof_get_buffer_t);
-
-struct xenoprof_counter {
-    uint32_t ind;
-    uint64_t count;
-    uint32_t enabled;
-    uint32_t event;
-    uint32_t hypervisor;
-    uint32_t kernel;
-    uint32_t user;
-    uint64_t unit_mask;
-};
-typedef struct xenoprof_counter xenoprof_counter_t;
-DEFINE_XEN_GUEST_HANDLE(xenoprof_counter_t);
-
-typedef struct xenoprof_passive {
-    uint16_t domain_id;
-    int32_t  max_samples;
-    int32_t  nbuf;
-    int32_t  bufsize;
-    uint64_t buf_gmaddr;
-} xenoprof_passive_t;
-DEFINE_XEN_GUEST_HANDLE(xenoprof_passive_t);
-
-struct xenoprof_ibs_counter {
-    uint64_t op_enabled;
-    uint64_t fetch_enabled;
-    uint64_t max_cnt_fetch;
-    uint64_t max_cnt_op;
-    uint64_t rand_en;
-    uint64_t dispatched_ops;
-};
-typedef struct xenoprof_ibs_counter xenoprof_ibs_counter_t;
-DEFINE_XEN_GUEST_HANDLE(xenoprof_ibs_counter_t);
-
-#endif /* __XEN_PUBLIC_XENOPROF_H__ */
-
-/*
- * Local variables:
- * mode: C
- * c-set-style: "BSD"
- * c-basic-offset: 4
- * tab-width: 4
- * indent-tabs-mode: nil
- * End:
- */
diff -Nru xen-4.2.1-new/extras/mini-os/include/xen/xsm/flask_op.h xen-4.2.1/extras/mini-os/include/xen/xsm/flask_op.h
--- xen-4.2.1-new/extras/mini-os/include/xen/xsm/flask_op.h	2012-12-17 23:01:56.000000000 +0800
+++ xen-4.2.1/extras/mini-os/include/xen/xsm/flask_op.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,193 +0,0 @@
-/*
- *  This file contains the flask_op hypercall commands and definitions.
- *
- *  Author:  George Coker, <gscoker@alpha.ncsc.mil>
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- */
-
-#ifndef __FLASK_OP_H__
-#define __FLASK_OP_H__
-
-#define XEN_FLASK_INTERFACE_VERSION 1
-
-struct xen_flask_load {
-    XEN_GUEST_HANDLE(char) buffer;
-    uint32_t size;
-};
-
-struct xen_flask_setenforce {
-    uint32_t enforcing;
-};
-
-struct xen_flask_sid_context {
-    /* IN/OUT: sid to convert to/from string */
-    uint32_t sid;
-    /* IN: size of the context buffer
-     * OUT: actual size of the output context string
-     */
-    uint32_t size;
-    XEN_GUEST_HANDLE(char) context;
-};
-
-struct xen_flask_access {
-    /* IN: access request */
-    uint32_t ssid;
-    uint32_t tsid;
-    uint32_t tclass;
-    uint32_t req;
-    /* OUT: AVC data */
-    uint32_t allowed;
-    uint32_t audit_allow;
-    uint32_t audit_deny;
-    uint32_t seqno;
-};
-
-struct xen_flask_transition {
-    /* IN: transition SIDs and class */
-    uint32_t ssid;
-    uint32_t tsid;
-    uint32_t tclass;
-    /* OUT: new SID */
-    uint32_t newsid;
-};
-
-struct xen_flask_userlist {
-    /* IN: starting SID for list */
-    uint32_t start_sid;
-    /* IN: size of user string and output buffer
-     * OUT: number of SIDs returned */
-    uint32_t size;
-    union {
-        /* IN: user to enumerate SIDs */
-        XEN_GUEST_HANDLE(char) user;
-        /* OUT: SID list */
-        XEN_GUEST_HANDLE(uint32) sids;
-    } u;
-};
-
-struct xen_flask_boolean {
-    /* IN/OUT: numeric identifier for boolean [GET/SET]
-     * If -1, name will be used and bool_id will be filled in. */
-    uint32_t bool_id;
-    /* OUT: current enforcing value of boolean [GET/SET] */
-    uint8_t enforcing;
-    /* OUT: pending value of boolean [GET/SET] */
-    uint8_t pending;
-    /* IN: new value of boolean [SET] */
-    uint8_t new_value;
-    /* IN: commit new value instead of only setting pending [SET] */
-    uint8_t commit;
-    /* IN: size of boolean name buffer [GET/SET]
-     * OUT: actual size of name [GET only] */
-    uint32_t size;
-    /* IN: if bool_id is -1, used to find boolean [GET/SET]
-     * OUT: textual name of boolean [GET only]
-     */
-    XEN_GUEST_HANDLE(char) name;
-};
-
-struct xen_flask_setavc_threshold {
-    /* IN */
-    uint32_t threshold;
-};
-
-struct xen_flask_hash_stats {
-    /* OUT */
-    uint32_t entries;
-    uint32_t buckets_used;
-    uint32_t buckets_total;
-    uint32_t max_chain_len;
-};
-
-struct xen_flask_cache_stats {
-    /* IN */
-    uint32_t cpu;
-    /* OUT */
-    uint32_t lookups;
-    uint32_t hits;
-    uint32_t misses;
-    uint32_t allocations;
-    uint32_t reclaims;
-    uint32_t frees;
-};
-
-struct xen_flask_ocontext {
-    /* IN */
-    uint32_t ocon;
-    uint32_t sid;
-    uint64_t low, high;
-};
-
-struct xen_flask_peersid {
-    /* IN */
-    evtchn_port_t evtchn;
-    /* OUT */
-    uint32_t sid;
-};
-
-struct xen_flask_op {
-    uint32_t cmd;
-#define FLASK_LOAD              1
-#define FLASK_GETENFORCE        2
-#define FLASK_SETENFORCE        3
-#define FLASK_CONTEXT_TO_SID    4
-#define FLASK_SID_TO_CONTEXT    5
-#define FLASK_ACCESS            6
-#define FLASK_CREATE            7
-#define FLASK_RELABEL           8
-#define FLASK_USER              9
-#define FLASK_POLICYVERS        10
-#define FLASK_GETBOOL           11
-#define FLASK_SETBOOL           12
-#define FLASK_COMMITBOOLS       13
-#define FLASK_MLS               14
-#define FLASK_DISABLE           15
-#define FLASK_GETAVC_THRESHOLD  16
-#define FLASK_SETAVC_THRESHOLD  17
-#define FLASK_AVC_HASHSTATS     18
-#define FLASK_AVC_CACHESTATS    19
-#define FLASK_MEMBER            20
-#define FLASK_ADD_OCONTEXT      21
-#define FLASK_DEL_OCONTEXT      22
-#define FLASK_GET_PEER_SID      23
-    uint32_t interface_version; /* XEN_FLASK_INTERFACE_VERSION */
-    union {
-        struct xen_flask_load load;
-        struct xen_flask_setenforce enforce;
-        /* FLASK_CONTEXT_TO_SID and FLASK_SID_TO_CONTEXT */
-        struct xen_flask_sid_context sid_context;
-        struct xen_flask_access access;
-        /* FLASK_CREATE, FLASK_RELABEL, FLASK_MEMBER */
-        struct xen_flask_transition transition;
-        struct xen_flask_userlist userlist;
-        /* FLASK_GETBOOL, FLASK_SETBOOL */
-        struct xen_flask_boolean boolean;
-        struct xen_flask_setavc_threshold setavc_threshold;
-        struct xen_flask_hash_stats hash_stats;
-        struct xen_flask_cache_stats cache_stats;
-        /* FLASK_ADD_OCONTEXT, FLASK_DEL_OCONTEXT */
-        struct xen_flask_ocontext ocontext;
-        struct xen_flask_peersid peersid;
-    } u;
-};
-typedef struct xen_flask_op xen_flask_op_t;
-DEFINE_XEN_GUEST_HANDLE(xen_flask_op_t);
-
-#endif
diff -Nru xen-4.2.1-new/extras/mini-os/kernel.c xen-4.2.1/extras/mini-os/kernel.c
--- xen-4.2.1-new/extras/mini-os/kernel.c	2015-10-26 10:47:38.003010553 +0800
+++ xen-4.2.1/extras/mini-os/kernel.c	2012-12-17 23:00:05.000000000 +0800
@@ -98,11 +98,6 @@
     printk("    cmd_line: %s\n",  
            si->cmd_line ? (const char *)si->cmd_line : "NULL");
 
-	/*Compute machine addr of module*/
-	printk("machine_mod_start = %d\n", pfn_to_mfn(virt_to_pfn(si->mod_start)));
-
-	printk("machine_start_info = %d\n", pfn_to_mfn(virt_to_pfn(si)));
-
     /* Set up events. */
     init_events();
     
@@ -131,11 +126,9 @@
     /* Init XenBus */
     init_xenbus();
 
-
     /* Call (possibly overridden) app_main() */
     app_main(&start_info);
 
-
     /* Everything initialised, start idle thread */
     run_idle_thread();
 }
diff -Nru xen-4.2.1-new/extras/mini-os/lwip-net.c xen-4.2.1/extras/mini-os/lwip-net.c
--- xen-4.2.1-new/extras/mini-os/lwip-net.c	2015-03-25 19:06:48.445009001 +0800
+++ xen-4.2.1/extras/mini-os/lwip-net.c	2012-12-17 23:00:05.000000000 +0800
@@ -345,15 +345,13 @@
   struct ip_addr ipaddr = { htonl(IF_IPADDR) };
   struct ip_addr netmask = { htonl(IF_NETMASK) };
   struct ip_addr gw = { 0 };
-  char *ip = "10.0.1.101";
-  char *gate = "10.0.1.1";
+  char *ip = NULL;
 
   tprintk("Waiting for network.\n");
 
   dev = init_netfront(NULL, NULL, rawmac, &ip);
   
   if (ip) {
-	gw.addr = inet_addr(gate);
     ipaddr.addr = inet_addr(ip);
     if (IN_CLASSA(ntohl(ipaddr.addr)))
       netmask.addr = htonl(IN_CLASSA_NET);
diff -Nru xen-4.2.1-new/extras/mini-os/main.c xen-4.2.1/extras/mini-os/main.c
--- xen-4.2.1-new/extras/mini-os/main.c	2015-10-26 10:34:49.411010001 +0800
+++ xen-4.2.1/extras/mini-os/main.c	2012-12-17 23:00:05.000000000 +0800
@@ -15,13 +15,6 @@
 #include <unistd.h>
 #include <xenbus.h>
 #include <events.h>
-#include <netinet/in.h>
-#include <sys/types.h>
-#include <sys/socket.h>
-#include <arpa/inet.h>
-#include <string.h>
-#include <sys/time.h>
-
 
 extern int main(int argc, char *argv[], char *envp[]);
 extern void __libc_init_array(void);
@@ -189,301 +182,11 @@
     }
     do_exit();
 }
-int htoi(char s[])
-{
-    int n = 0;
-    int i = 0;
-    while (s[i] != '\0' && s[i] != '\n') {
-        if (s[i] == '0') {
-            if (s[i+1] == 'x' || s[i+1] == 'X')
-                            i+=2;
-        }
-        if (s[i] >= '0' && s[i] <= '9') {
-            n = n * 16 + (s[i] - '0');
-        } else if (s[i] >= 'a' && s[i] <= 'f') {
-            n = n * 16 + (s[i] - 'a') + 10;
-        } else if (s[i] >= 'A' && s[i] <= 'F') {
-            n = n * 16 + (s[i] - 'A') + 10;
-        } else
-            return -1;
-        ++i;
-    }
-    return n;
-}
-unsigned long *gots;
-unsigned long *gotm = (unsigned long *)(0x9a540);
-struct timeval start, end;
-
-void update_minios_parse_sym(void)
-{
-	/*write moduleID to dom0*/
-	int domid;
-	char path[128];
-	char value[10];
-	char *msg, *realaddr;
-	int i;
-
-	gettimeofday(&start, NULL);
-	domid = xenbus_read_integer("domid");
-	snprintf(path, sizeof(path), "/local/domain/%d/console/mid", domid);
-	sprintf(value, "%p", gotm[1]);
-	xenbus_write(0, path, value);
-	gettimeofday(&end, NULL);
-
-	printk("--------parse1 dym: %ldus\n", 1000000 * ( end.tv_sec - start.tv_sec ) + end.tv_usec -start.tv_usec);
-	//gotm[3] = (unsigned long)0xdf1a0;	
-	//getchar();
-	gettimeofday(&start, NULL);
-	for (i=0; i<3; i++){
-		snprintf(path, sizeof(path), "/local/domain/%d/console/realaddr%d", domid, i);
-		msg = xenbus_read(XBT_NIL, path, &realaddr);
-		if (msg)
-			printk("Could not read realaddr!\n");
-		gotm[3+i] = (unsigned long)(0xfd000+htoi(realaddr));
-	}
-}
-
-void update_sotest_parse_sym(void)
-{
-	int domid, count1, i;	
-	char path[128];
-	char *msg, *val_count, *realaddr;
-
-	domid = xenbus_read_integer("domid");
-	snprintf(path, sizeof(path), "/local/domain/%d/console/count1", domid);
-	msg = xenbus_read(XBT_NIL, path, &val_count);
-	count1 = atoi(val_count);
-
-	for (i=0; i<count1; i++){
-		snprintf(path, sizeof(path), "/local/domain/%d/console/addr1_%d", domid, i);
-		msg = xenbus_read(XBT_NIL, path, &realaddr);
-		if (msg)
-			printk("Could not read realaddr!\n");
-		gots[3+i] = (unsigned long )htoi(realaddr);
-	}
-	//printf("-------realaddr = %s\n", realaddr);
-	gettimeofday(&end, NULL);
-	printk("--------rel2 dym: %ldus\n", 1000000 * ( end.tv_sec - start.tv_sec ) + end.tv_usec -start.tv_usec);
-}
-
-/*get updated shared library*/
-static void get_shared_library(void *p)
-{
-	/*
-	int domid;
-	char pathdomgfn[128];
-	unsigned long dom_gfn;
-	char gfn[64];
-	char *shared_addr;
-*/
-	/*step 1: get a pfn of page*/
-/*	shared_addr = (char *)alloc_page();
-	dom_gfn = virt_to_pfn(shared_addr);
-	snprintf(gfn, sizeof(gfn), "%d", dom_gfn);
-*/
-	/*step 2: write pfn to xenstore*/
-	/*
-	domid = xenbus_read_integer("domid");
-	snprintf(pathdomgfn, sizeof(pathdomgfn), "/local/domain/%d/console/domgfn", domid);
-	xenbus_write(0, pathdomgfn, gfn);
-	memcpy(shared_addr, "Hello World", sizeof("Hello World"));
-	printf("shared_addr = %s\n", shared_addr);
-	*/
-
-	/*
-	int server_sockfd;
-	int client_sockfd;
-	int len;
-	struct sockaddr_in my_addr; //server
-	struct sockaddr_in remote_addr; //client
-	int sin_size = sizeof(struct sockaddr_in);
-
-	//declare a struct of socket
-	memset(&my_addr, 0, sizeof(my_addr));//init sockaddr_in
-	my_addr.sin_family = AF_INET; //Set IP communication
-	my_addr.sin_addr.s_addr = INADDR_ANY;//server IP, permit any IP to connect
-	my_addr.sin_port = htons(10000);//set a server port
-
-	//build a socke, if success, return a fd of socket
-	if ((server_sockfd = socket(PF_INET, SOCK_STREAM, 0)) < 0){
-		perror("socket");
-		return 1;
-	}
-
-	//bind socket to network IP
-	if (bind(server_sockfd, (struct sockaddr *)&my_addr, sizeof(struct sockaddr)) < 0){
-		perror("bind");
-		return 1;
-	}
-
-	// listen a request
-	listen(server_sockfd, 5);
-	
-	//wait for a request
-	if ((client_sockfd = accept(server_sockfd, (struct sockaddr *)&remote_addr, &sin_size)) < 0){
-		perror("accept");
-		return 1;
-	}
-	char *buf = (char *)malloc(sizeof(char) *512);
-	char **dest = (char **)malloc(sizeof(char *)*2);
-	int i;
-	for (i=0; i<2; i++)
-		dest[i] = (char *)malloc(sizeof(char)*512);
-	i=0;
-	while ((len = recv(client_sockfd, buf, 512, 0)) > 0){
-		memcpy(dest[i], buf, 512);
-		i++;
-	}
-	for (i=0; i<512; i++)
-		printf("%p, ", dest[0][i]);
-	printf("\n\n\n");
-	close(client_sockfd);
-	close(server_sockfd);
-	return 0;
-	*/
-	/*get .got.plt of libso_test2.so*/
-	int domid;
-	char path[128];
-	char *msg, *val;
-
-	domid = xenbus_read_integer("domid");
-	snprintf(path, sizeof(path), "/local/domain/%d/console/got", domid);
-	while (1){
-		msg = xenbus_read(XBT_NIL, path, &val);	
-		if (msg)
-			continue;
-		if (gots == htoi(val)+0xfd000)
-			continue;
-		//printf("-----val = %s\n", val);
-		gettimeofday(&start, NULL);
-		gots = (unsigned long *)(htoi(val)+0xfd000);
-		//printk("------------gots[0] = %p\n", gots[0]);
-		/*set moduleID in gots[1]*/
-		gots[1] = (unsigned long)0x1;		
-		/*set got[3] to update_parse_sym*/
-		gotm[3] = update_minios_parse_sym;
-		gots[3] = update_sotest_parse_sym;
-		gettimeofday(&end, NULL);
-		printk("------resolve2 time : %ldus\n", 1000000*(end.tv_sec - start.tv_sec) + end.tv_usec - start.tv_usec);
-	}
-
-}
-
-
-/*parse symbol, like _dl_runtime_resolve*/
-void lazy_binding_parse_sym()
-{
-	int domid, count0, count1, i, j;
-	char path[128];
-	//char value[12];
-	//unsigned long *got = (unsigned long *)(&_edata+0xa0);
-	char *msg, *val_count, *realaddr;
-	unsigned long *got0, *got1;
-	
-	/*step 1:write addr into xenstore!*/
-	domid = xenbus_read_integer("domid");
-	snprintf(path, sizeof(path), "/local/domain/%d/console/flag", domid);
-	//sprintf(value, "%p", got[1]);
-	xenbus_write(0, path, "1");
-	//printk("value = %s\n", value);
-	/*step 2:read xenstore and set .got.plt table*/
-	//label 1: read count
-	snprintf(path, sizeof(path), "/local/domain/%d/console/count0", domid);
-	while (1) {
-		msg = xenbus_read(XBT_NIL, path, &val_count);
-		if (msg)
-			continue;
-		break;
-	}
-	count0 = atoi(val_count);
-	//printf("count = %d\n", count);
-	//printf("val_count = %s\n", val_count);
-	//label 2: read addr
-	//find .plt.got
-	//printf("----------------count = %d\n", count);
-	snprintf(path, sizeof(path), "/local/domain/%d/console/count1", domid);
-	msg = xenbus_read(XBT_NIL, path, &val_count);
-	count1 = atoi(val_count);
-	
-	for (j=0; j<2; j++){
-		snprintf(path, sizeof(path), "/local/domain/%d/console/r_got%d", domid, j);
-		if (j == 0){
-			msg = xenbus_read(XBT_NIL, path, &realaddr);
-			if (msg)
-				printk("Could not read realaddr1!\n");
-			got0 = (unsigned long *)htoi(realaddr);
-			//printf("-------------got0 = %p\n", got0);
-		}
-		if (j == 1){
-			msg = xenbus_read(XBT_NIL, path, &realaddr);
-			if (msg)
-				printk("Could not read realaddr2!\n");
-			got1 = (unsigned long *)(htoi(realaddr)+0xdd000);
-			//printf("-------------got1 = %p\n", got1);
-		}
-	}
-	
-	for (i=0; i<count0; i++){
-		snprintf(path, sizeof(path), "/local/domain/%d/console/addr0_%d", domid, i);
-		msg = xenbus_read(XBT_NIL, path, &realaddr);
-		if (msg)
-			printk("Could not read realaddr3!\n");
-		//printf("realaddr = %p\n", htoi(realaddr));
-		got0[i+3] = (unsigned long)htoi(realaddr);
-	}
-	for (i=0; i<count1; i++){
-		snprintf(path, sizeof(path), "/local/domain/%d/console/addr1_%d", domid, i);
-		msg = xenbus_read(XBT_NIL, path, &realaddr);
-		if (msg)
-			printk("Could not read realaddr4!\n");
-		//printf("realaddr = %p\n", htoi(realaddr));
-		got1[i+3] = (unsigned long)htoi(realaddr);
-	}
-	//__asm __volatile ("call %0" :: "m" (got0[3]));
-}
-
-/*define plt_func*/
-/*
-void plt_func(void)
-{
-	__asm __volatile ("call lazy_binding_parse_sym");
-}
-*/
-
-/*init .plt.got, make it to point plt_func*/
-/*
-void init_plt_got(unsigned long *got)
-{
-	got[3] = (unsigned long)plt_func;
-}
-*/
-
 
 int app_main(start_info_t *si)
 {
-	/*step 1: init .plt.got*/
-	unsigned long *got = (unsigned long *)(0x9a540);
-//	unsigned long *gotl = (unsigned long *)(0xde2b0);
-
-/*	
-	unsigned long *got1 = (unsigned long *)0xce2b0;
-	got0[3] = (unsigned long)0xcd1a0;
-*/
-	//got[3] = (unsigned long)0xdd1a0;
-	got[3] = lazy_binding_parse_sym;
-//	gotl[3] = lazy_binding_parse_sym;
-//	lazy_binding_parse_sym();
-//	lazy_thread = create_thread("lazy", lazy_binding_parse_sym, NULL);
-//	sleep(10);
-//	init_plt_got(got);
-	/*step 2: */
-	//printk("--------got[1] = %p\n", got[1]);
-	/*update shared library!*/
-
     printk("Dummy main: start_info=%p\n", si);
     main_thread = create_thread("main", call_main, si);
-	update_thread = create_thread("update", get_shared_library, NULL);
-
     return 0;
 }
 #endif
diff -Nru xen-4.2.1-new/extras/mini-os/main.c~ xen-4.2.1/extras/mini-os/main.c~
--- xen-4.2.1-new/extras/mini-os/main.c~	2015-10-21 10:28:12.098023056 +0800
+++ xen-4.2.1/extras/mini-os/main.c~	1970-01-01 07:00:00.000000000 +0700
@@ -1,440 +0,0 @@
-/*
- * POSIX-compatible main layer
- *
- * Samuel Thibault <Samuel.Thibault@eu.citrix.net>, October 2007
- */
-
-#ifdef HAVE_LIBC
-#include <os.h>
-#include <sched.h>
-#include <console.h>
-#include <netfront.h>
-#include <pcifront.h>
-#include <time.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <xenbus.h>
-#include <events.h>
-#include <netinet/in.h>
-#include <sys/types.h>
-#include <sys/socket.h>
-#include <arpa/inet.h>
-#include <string.h>
-
-
-extern int main(int argc, char *argv[], char *envp[]);
-extern void __libc_init_array(void);
-extern void __libc_fini_array(void);
-extern unsigned long __CTOR_LIST__[];
-extern unsigned long __DTOR_LIST__[];
-
-#if 0
-#include <stdio.h>
-int main(int argc, char *argv[], char *envp[])
-{
-    printf("Hello, World!\n");
-    return 1;
-}
-#endif
-
-void _init(void)
-{
-}
-
-void _fini(void)
-{
-}
-
-extern char __app_bss_start, __app_bss_end;
-static void call_main(void *p)
-{
-    char *c, quote;
-#ifdef CONFIG_QEMU_XS_ARGS
-    char *domargs, *msg;
-#endif
-    int argc;
-    char **argv;
-    char *envp[] = { NULL };
-#ifdef CONFIG_QEMU_XS_ARGS
-    char *vm;
-    char path[128];
-    int domid;
-#endif
-    int i;
-
-    /* Let other parts initialize (including console output) before maybe
-     * crashing. */
-    //sleep(1);
-
-#ifdef CONFIG_SPARSE_BSS
-    sparse((unsigned long) &__app_bss_start, &__app_bss_end - &__app_bss_start);
-#endif
-#if defined(HAVE_LWIP) && defined(CONFIG_START_NETWORK) && defined(CONFIG_NETFRONT)
-    start_networking();
-#endif
-#ifdef CONFIG_PCIFRONT
-    create_thread("pcifront", pcifront_watches, NULL);
-#endif
-
-#ifdef CONFIG_QEMU_XS_ARGS
-    /* Fetch argc, argv from XenStore */
-    domid = xenbus_read_integer("target");
-    if (domid == -1) {
-        printk("Couldn't read target\n");
-        do_exit();
-    }
-
-    snprintf(path, sizeof(path), "/local/domain/%d/vm", domid);
-    msg = xenbus_read(XBT_NIL, path, &vm);
-    if (msg) {
-        printk("Couldn't read vm path\n");
-        do_exit();
-    }
-    printk("dom vm is at %s\n", vm);
-
-    snprintf(path, sizeof(path), "%s/image/dmargs", vm);
-    free(vm);
-    msg = xenbus_read(XBT_NIL, path, &domargs);
-
-    if (msg) {
-        printk("Couldn't get stubdom args: %s\n", msg);
-        domargs = strdup("");
-    }
-#endif
-
-    argc = 1;
-
-#define PARSE_ARGS(ARGS,START,QUOTE,END) \
-    c = ARGS; \
-    quote = 0; \
-    while (*c) { \
-	if (*c != ' ') { \
-	    START; \
-	    while (*c) { \
-		if (quote) { \
-		    if (*c == quote) { \
-			quote = 0; \
-			QUOTE; \
-			continue; \
-		    } \
-		} else if (*c == ' ') \
-		    break; \
-		if (*c == '"' || *c == '\'') { \
-		    quote = *c; \
-		    QUOTE; \
-		    continue; \
-		} \
-		c++; \
-	    } \
-	} else { \
-            END; \
-	    while (*c == ' ') \
-		c++; \
-	} \
-    } \
-    if (quote) {\
-	printk("Warning: unterminated quotation %c\n", quote); \
-	quote = 0; \
-    }
-#define PARSE_ARGS_COUNT(ARGS) PARSE_ARGS(ARGS, argc++, c++, )
-#define PARSE_ARGS_STORE(ARGS) PARSE_ARGS(ARGS, argv[argc++] = c, memmove(c, c + 1, strlen(c + 1) + 1), *c++ = 0)
-
-    PARSE_ARGS_COUNT((char*)start_info.cmd_line);
-#ifdef CONFIG_QEMU_XS_ARGS
-    PARSE_ARGS_COUNT(domargs);
-#endif
-
-    argv = alloca((argc + 1) * sizeof(char *));
-    argv[0] = "main";
-    argc = 1;
-
-    PARSE_ARGS_STORE((char*)start_info.cmd_line)
-#ifdef CONFIG_QEMU_XS_ARGS
-    PARSE_ARGS_STORE(domargs)
-#endif
-
-    argv[argc] = NULL;
-
-    for (i = 0; i < argc; i++)
-	printf("\"%s\" ", argv[i]);
-    printf("\n");
-
-    __libc_init_array();
-    environ = envp;
-    for (i = 0; __CTOR_LIST__[i] != 0; i++)
-        ((void((*)(void)))__CTOR_LIST__[i]) ();
-    tzset();
-
-    exit(main(argc, argv, envp));
-}
-
-void _exit(int ret)
-{
-    int i;
-
-    for (i = 0; __DTOR_LIST__[i] != 0; i++)
-        ((void((*)(void)))__DTOR_LIST__[i]) ();
-    close_all_files();
-    __libc_fini_array();
-    printk("main returned %d\n", ret);
-#if defined(HAVE_LWIP) && defined(CONFIG_NETFRONT)
-    stop_networking();
-#endif
-    stop_kernel();
-    if (!ret) {
-	/* No problem, just shutdown.  */
-        struct sched_shutdown sched_shutdown = { .reason = SHUTDOWN_poweroff };
-        HYPERVISOR_sched_op(SCHEDOP_shutdown, &sched_shutdown);
-    }
-    do_exit();
-}
-int htoi(char s[])
-{
-    int n = 0;
-    int i = 0;
-    while (s[i] != '\0' && s[i] != '\n') {
-        if (s[i] == '0') {
-            if (s[i+1] == 'x' || s[i+1] == 'X')
-                            i+=2;
-        }
-        if (s[i] >= '0' && s[i] <= '9') {
-            n = n * 16 + (s[i] - '0');
-        } else if (s[i] >= 'a' && s[i] <= 'f') {
-            n = n * 16 + (s[i] - 'a') + 10;
-        } else if (s[i] >= 'A' && s[i] <= 'F') {
-            n = n * 16 + (s[i] - 'A') + 10;
-        } else
-            return -1;
-        ++i;
-    }
-    return n;
-}
-unsigned long *got1;
-unsigned long *got = (unsigned long *)(&_edata+0xa0);
-
-void update_minios_parse_sym(void)
-{
-
-}
-
-void update_sotest_parse_sym(void)
-{
-	
-}
-
-/*get updated shared library*/
-static void get_shared_library(void *p)
-{
-	/*
-	int domid;
-	char pathdomgfn[128];
-	unsigned long dom_gfn;
-	char gfn[64];
-	char *shared_addr;
-*/
-	/*step 1: get a pfn of page*/
-/*	shared_addr = (char *)alloc_page();
-	dom_gfn = virt_to_pfn(shared_addr);
-	snprintf(gfn, sizeof(gfn), "%d", dom_gfn);
-*/
-	/*step 2: write pfn to xenstore*/
-	/*
-	domid = xenbus_read_integer("domid");
-	snprintf(pathdomgfn, sizeof(pathdomgfn), "/local/domain/%d/console/domgfn", domid);
-	xenbus_write(0, pathdomgfn, gfn);
-	memcpy(shared_addr, "Hello World", sizeof("Hello World"));
-	printf("shared_addr = %s\n", shared_addr);
-	*/
-
-	/*
-	int server_sockfd;
-	int client_sockfd;
-	int len;
-	struct sockaddr_in my_addr; //server
-	struct sockaddr_in remote_addr; //client
-	int sin_size = sizeof(struct sockaddr_in);
-
-	//declare a struct of socket
-	memset(&my_addr, 0, sizeof(my_addr));//init sockaddr_in
-	my_addr.sin_family = AF_INET; //Set IP communication
-	my_addr.sin_addr.s_addr = INADDR_ANY;//server IP, permit any IP to connect
-	my_addr.sin_port = htons(10000);//set a server port
-
-	//build a socke, if success, return a fd of socket
-	if ((server_sockfd = socket(PF_INET, SOCK_STREAM, 0)) < 0){
-		perror("socket");
-		return 1;
-	}
-
-	//bind socket to network IP
-	if (bind(server_sockfd, (struct sockaddr *)&my_addr, sizeof(struct sockaddr)) < 0){
-		perror("bind");
-		return 1;
-	}
-
-	// listen a request
-	listen(server_sockfd, 5);
-	
-	//wait for a request
-	if ((client_sockfd = accept(server_sockfd, (struct sockaddr *)&remote_addr, &sin_size)) < 0){
-		perror("accept");
-		return 1;
-	}
-	char *buf = (char *)malloc(sizeof(char) *512);
-	char **dest = (char **)malloc(sizeof(char *)*2);
-	int i;
-	for (i=0; i<2; i++)
-		dest[i] = (char *)malloc(sizeof(char)*512);
-	i=0;
-	while ((len = recv(client_sockfd, buf, 512, 0)) > 0){
-		memcpy(dest[i], buf, 512);
-		i++;
-	}
-	for (i=0; i<512; i++)
-		printf("%p, ", dest[0][i]);
-	printf("\n\n\n");
-	close(client_sockfd);
-	close(server_sockfd);
-	return 0;
-	*/
-	/*get .got.plt of libso_test2.so*/
-	int domid;
-	char path[128];
-	char *msg, *val;
-
-	domid = xenbus_read_integer("domid");
-	snprintf(path, sizeof(path), "/local/domain/%d/console/got", domid);
-	while (1){
-		msg = xenbus_read(XBT_NIL, path, &val);	
-		if (msg)
-			continue;
-		break;
-	}
-
-	got1 = (unsigned long *)(htoi(val)+0xde000);
-	//printk("------------got1 = %p\n", htoi(val));
-	/*set moduleID in got1[1]*/
-	got1[1] = (unsigned long)0x1;		
-	/*set got[3] to update_parse_sym*/
-	got[3] = update_minios_parse_sym;
-	got1[3] = update_sotest_parse_sym;
-}
-
-
-/*parse symbol, like _dl_runtime_resolve*/
-void lazy_binding_parse_sym()
-{
-	int domid, count0, count1, i, j;
-	char path[128];
-	//char value[12];
-	//unsigned long *got = (unsigned long *)(&_edata+0xa0);
-	char *msg, *val_count, *realaddr;
-	unsigned long *got0, *got1;
-	
-	/*step 1:write addr into xenstore!*/
-	domid = xenbus_read_integer("domid");
-	snprintf(path, sizeof(path), "/local/domain/%d/console/flag", domid);
-	//sprintf(value, "%p", got[1]);
-	xenbus_write(0, path, "1");
-	//printk("value = %s\n", value);
-	/*step 2:read xenstore and set .got.plt table*/
-	//label 1: read count
-	snprintf(path, sizeof(path), "/local/domain/%d/console/count0", domid);
-	while (1) {
-		msg = xenbus_read(XBT_NIL, path, &val_count);
-		if (msg)
-			continue;
-		break;
-	}
-	count0 = atoi(val_count);
-	//printf("count = %d\n", count);
-	//printf("val_count = %s\n", val_count);
-	//label 2: read addr
-	//find .plt.got
-	//printf("----------------count = %d\n", count);
-	snprintf(path, sizeof(path), "/local/domain/%d/console/count1", domid);
-	msg = xenbus_read(XBT_NIL, path, &val_count);
-	count1 = atoi(val_count);
-	
-	for (j=0; j<2; j++){
-		snprintf(path, sizeof(path), "/local/domain/%d/console/r_got%d", domid, j);
-		if (j == 0){
-			msg = xenbus_read(XBT_NIL, path, &realaddr);
-			if (msg)
-				printk("Could not read realaddr1!\n");
-			got0 = (unsigned long *)htoi(realaddr);
-			//printf("-------------got0 = %p\n", got0);
-		}
-		if (j == 1){
-			msg = xenbus_read(XBT_NIL, path, &realaddr);
-			if (msg)
-				printk("Could not read realaddr2!\n");
-			got1 = (unsigned long *)(htoi(realaddr)+0xdd000);
-			//printf("-------------got1 = %p\n", got1);
-		}
-	}
-	
-	for (i=0; i<count0; i++){
-		snprintf(path, sizeof(path), "/local/domain/%d/console/addr0_%d", domid, i);
-		msg = xenbus_read(XBT_NIL, path, &realaddr);
-		if (msg)
-			printk("Could not read realaddr3!\n");
-		//printf("realaddr = %p\n", htoi(realaddr));
-		got0[i+3] = (unsigned long)htoi(realaddr);
-	}
-	for (i=0; i<count1; i++){
-		snprintf(path, sizeof(path), "/local/domain/%d/console/addr1_%d", domid, i);
-		msg = xenbus_read(XBT_NIL, path, &realaddr);
-		if (msg)
-			printk("Could not read realaddr4!\n");
-		//printf("realaddr = %p\n", htoi(realaddr));
-		got1[i+3] = (unsigned long)htoi(realaddr);
-	}
-	//__asm __volatile ("call %0" :: "m" (got0[3]));
-}
-
-/*define plt_func*/
-/*
-void plt_func(void)
-{
-	__asm __volatile ("call lazy_binding_parse_sym");
-}
-*/
-
-/*init .plt.got, make it to point plt_func*/
-/*
-void init_plt_got(unsigned long *got)
-{
-	got[3] = (unsigned long)plt_func;
-}
-*/
-
-
-int app_main(start_info_t *si)
-{
-	/*step 1: init .plt.got*/
-	unsigned long *got = (unsigned long *)(&_edata+0xa0);
-//	unsigned long *gotl = (unsigned long *)(0xde2b0);
-
-/*	
-	unsigned long *got1 = (unsigned long *)0xce2b0;
-	got0[3] = (unsigned long)0xcd1a0;
-*/
-	//got[3] = (unsigned long)0xdd1a0;
-	got[3] = lazy_binding_parse_sym;
-//	gotl[3] = lazy_binding_parse_sym;
-//	lazy_binding_parse_sym();
-//	lazy_thread = create_thread("lazy", lazy_binding_parse_sym, NULL);
-//	sleep(10);
-//	init_plt_got(got);
-	/*step 2: */
-	//printk("--------got[1] = %p\n", got[1]);
-	/*update shared library!*/
-
-    printk("Dummy main: start_info=%p\n", si);
-    main_thread = create_thread("main", call_main, si);
-	update_thread = create_thread("update", get_shared_library, NULL);
-
-    return 0;
-}
-#endif
diff -Nru xen-4.2.1-new/extras/mini-os/Makefile xen-4.2.1/extras/mini-os/Makefile
--- xen-4.2.1-new/extras/mini-os/Makefile	2015-10-24 00:37:10.685009001 +0800
+++ xen-4.2.1/extras/mini-os/Makefile	2012-12-17 23:00:04.000000000 +0800
@@ -147,7 +147,7 @@
 APP_LDLIBS += -L$(XEN_ROOT)/stubdom/libxc-$(XEN_TARGET_ARCH) -whole-archive -lxenguest -lxenctrl -no-whole-archive
 APP_LDLIBS += -lpci
 APP_LDLIBS += -lz
-#APP_LDLIBS += -lm
+APP_LDLIBS += -lm
 LDLIBS += -lc
 endif
 
@@ -163,47 +163,27 @@
 endif
 
 $(OBJ_DIR)/$(TARGET): links include/list.h $(OBJS) $(APP_O) arch_lib
-	$(LD) $(LDFLAGS) $(LDFLAGS_FINAL) $(HEAD_OBJ) $(APP_O) $(OBJS) $(LDARCHLIB) $(NEWS_OBJS) $(LDLIBS) -o $@
-	$(OBJCOPY) -w -G $(GLOBAL_PREFIX)* -G _start $@ $@
-	$(OBJDUMP) -S $@ > $@.asm
+	$(LD) -r $(LDFLAGS) $(HEAD_OBJ) $(APP_O) $(OBJS) $(LDARCHLIB) $(LDLIBS) -o $@.o
+	$(OBJCOPY) -w -G $(GLOBAL_PREFIX)* -G _start $@.o $@.o
+	$(LD) $(LDFLAGS) $(LDFLAGS_FINAL) $@.o $(EXTRA_OBJS) -o $@
 	gzip -f -9 -c $@ >$@.gz
 
-# for build mini-os in a specific folder (so that not bother dropbox)
-OBJ_MINIOS=obj-minios
-$(OBJ_MINIOS): 
-	[ -d $@ ] || \
-	for i in $$(cd $(CURDIR) ; find . -type d) ; do \
-                mkdir -p $@/$$i ; \
-	done
-
-
-# we can use #make obj# to gen all objs in obj-mininos dir 
-.PHONY: obj obj-clean
-obj: $(OBJ_MINIOS)
-	$(MAKE) DESTDIR= OBJ_DIR=$(CURDIR)/$<
-	ln -sf ../domain_config $(CURDIR)/$<
-	ln -sf ../../../tools/libxl/xl $(CURDIR)/$</xl-test
-	
-obj-clean:
-	rm -fr $(OBJ_MINIOS)
-
 .PHONY: clean arch_clean
 
 arch_clean:
 	$(MAKE) --directory=$(TARGET_ARCH_DIR) OBJ_DIR=$(OBJ_DIR)/$(TARGET_ARCH_DIR) clean || exit 1;
 
-clean:arch_clean obj-clean
+clean:	arch_clean
 	for dir in $(addprefix $(OBJ_DIR)/,$(SUBDIRS)); do \
-		rm -f $$dir/*.o $$dir/*.o.*; \
+		rm -f $$dir/*.o; \
 	done
 	rm -f include/list.h
-	rm -fr include/x86/mini-os
-	rm -f $(OBJ_DIR)/*.o.* $(OBJ_DIR)/*.asm
 	rm -f $(OBJ_DIR)/*.o *~ $(OBJ_DIR)/core $(OBJ_DIR)/$(TARGET).elf $(OBJ_DIR)/$(TARGET).raw $(OBJ_DIR)/$(TARGET) $(OBJ_DIR)/$(TARGET).gz
 	find . $(OBJ_DIR) -type l | xargs rm -f
 	$(RM) $(OBJ_DIR)/lwip.a $(LWO)
 	rm -f tags TAGS
 
+
 define all_sources
      ( find . -follow -name SCCS -prune -o -name '*.[chS]' -print )
 endef
diff -Nru xen-4.2.1-new/extras/mini-os/Makefile~ xen-4.2.1/extras/mini-os/Makefile~
--- xen-4.2.1-new/extras/mini-os/Makefile~	2014-09-08 09:13:15.290015956 +0800
+++ xen-4.2.1/extras/mini-os/Makefile~	1970-01-01 07:00:00.000000000 +0700
@@ -1,223 +0,0 @@
-# Common Makefile for mini-os.
-#
-# Every architecture directory below mini-os/arch has to have a
-# Makefile and a arch.mk.
-#
-
-export XEN_ROOT = $(CURDIR)/../..
-include $(XEN_ROOT)/Config.mk
-OBJ_DIR ?= $(CURDIR)
-
-ifeq ($(MINIOS_CONFIG),)
-include Config.mk
-else
-EXTRA_DEPS += $(MINIOS_CONFIG)
-include $(MINIOS_CONFIG)
-endif
-
-# Configuration defaults
-CONFIG_START_NETWORK ?= y
-CONFIG_SPARSE_BSS ?= y
-CONFIG_QEMU_XS_ARGS ?= n
-CONFIG_TEST ?= n
-CONFIG_PCIFRONT ?= n
-CONFIG_BLKFRONT ?= y
-CONFIG_NETFRONT ?= y
-CONFIG_FBFRONT ?= y
-CONFIG_KBDFRONT ?= y
-CONFIG_CONSFRONT ?= y
-CONFIG_XENBUS ?= y
-CONFIG_LWIP ?= $(lwip)
-
-# Export config items as compiler directives
-flags-$(CONFIG_START_NETWORK) += -DCONFIG_START_NETWORK
-flags-$(CONFIG_SPARSE_BSS) += -DCONFIG_SPARSE_BSS
-flags-$(CONFIG_QEMU_XS_ARGS) += -DCONFIG_QEMU_XS_ARGS
-flags-$(CONFIG_PCIFRONT) += -DCONFIG_PCIFRONT
-flags-$(CONFIG_BLKFRONT) += -DCONFIG_BLKFRONT
-flags-$(CONFIG_NETFRONT) += -DCONFIG_NETFRONT
-flags-$(CONFIG_KBDFRONT) += -DCONFIG_KBDFRONT
-flags-$(CONFIG_FBFRONT) += -DCONFIG_FBFRONT
-flags-$(CONFIG_CONSFRONT) += -DCONFIG_CONSFRONT
-flags-$(CONFIG_XENBUS) += -DCONFIG_XENBUS
-
-DEF_CFLAGS += $(flags-y)
-
-# Include common mini-os makerules.
-include minios.mk
-
-# Set tester flags
-# CFLAGS += -DBLKTEST_WRITE
-
-# Define some default flags for linking.
-LDLIBS := 
-APP_LDLIBS := 
-LDARCHLIB := -L$(OBJ_DIR)/$(TARGET_ARCH_DIR) -l$(ARCH_LIB_NAME)
-LDFLAGS_FINAL := -T $(TARGET_ARCH_DIR)/minios-$(XEN_TARGET_ARCH).lds
-
-# Prefix for global API names. All other symbols are localised before
-# linking with EXTRA_OBJS.
-GLOBAL_PREFIX := xenos_
-EXTRA_OBJS =
-
-TARGET := mini-os
-
-# Subdirectories common to mini-os
-SUBDIRS := lib xenbus console
-
-src-$(CONFIG_BLKFRONT) += blkfront.c
-src-y += daytime.c
-src-y += events.c
-src-$(CONFIG_FBFRONT) += fbfront.c
-src-y += gntmap.c
-src-y += gnttab.c
-src-y += hypervisor.c
-src-y += kernel.c
-src-y += lock.c
-src-y += main.c
-src-y += mm.c
-src-$(CONFIG_NETFRONT) += netfront.c
-src-$(CONFIG_PCIFRONT) += pcifront.c
-src-y += sched.c
-src-$(CONFIG_TEST) += test.c
-
-src-y += lib/ctype.c
-src-y += lib/math.c
-src-y += lib/printf.c
-src-y += lib/stack_chk_fail.c
-src-y += lib/string.c
-src-y += lib/sys.c
-src-y += lib/xmalloc.c
-src-$(CONFIG_XENBUS) += lib/xs.c
-
-src-$(CONFIG_XENBUS) += xenbus/xenbus.c
-
-src-y += console/console.c
-src-y += console/xencons_ring.c
-src-$(CONFIG_CONSFRONT) += console/xenbus.c
-
-# The common mini-os objects to build.
-APP_OBJS :=
-OBJS := $(patsubst %.c,$(OBJ_DIR)/%.o,$(src-y))
-
-.PHONY: default
-default: $(OBJ_DIR)/$(TARGET)
-
-# Create special architecture specific links. The function arch_links
-# has to be defined in arch.mk (see include above).
-ifneq ($(ARCH_LINKS),)
-$(ARCH_LINKS):
-	$(arch_links)
-endif
-
-include/list.h: $(XEN_ROOT)/tools/include/xen-external/bsd-sys-queue-h-seddery $(XEN_ROOT)/tools/include/xen-external/bsd-sys-queue.h
-	perl $^ --prefix=minios  >$@.new
-	$(call move-if-changed,$@.new,$@)
-
-.PHONY: links
-links: include/list.h $(ARCH_LINKS)
-	[ -e include/xen ] || ln -sf ../../../xen/include/public include/xen
-	[ -e include/mini-os ] || ln -sf . include/mini-os
-	[ -e include/$(TARGET_ARCH_FAM)/mini-os ] || ln -sf . include/$(TARGET_ARCH_FAM)/mini-os
-
-.PHONY: arch_lib
-arch_lib:
-	$(MAKE) --directory=$(TARGET_ARCH_DIR) OBJ_DIR=$(OBJ_DIR)/$(TARGET_ARCH_DIR) || exit 1;
-
-ifeq ($(CONFIG_LWIP),y)
-# lwIP library
-LWC	:= $(shell find $(LWIPDIR)/ -type f -name '*.c')
-LWC	:= $(filter-out %6.c %ip6_addr.c %ethernetif.c, $(LWC))
-LWO	:= $(patsubst %.c,%.o,$(LWC))
-LWO	+= $(OBJ_DIR)/lwip-arch.o
-ifeq ($(CONFIG_NETFRONT),y)
-LWO += $(OBJ_DIR)/lwip-net.o
-endif
-
-$(OBJ_DIR)/lwip.a: $(LWO)
-	$(RM) $@
-	$(AR) cqs $@ $^
-
-OBJS += $(OBJ_DIR)/lwip.a
-endif
-
-OBJS := $(filter-out $(OBJ_DIR)/lwip%.o $(LWO), $(OBJS))
-
-ifeq ($(libc),y)
-APP_LDLIBS += -L$(XEN_ROOT)/stubdom/libxc-$(XEN_TARGET_ARCH) -whole-archive -lxenguest -lxenctrl -no-whole-archive
-APP_LDLIBS += -lpci
-APP_LDLIBS += -lz
-APP_LDLIBS += -lm
-LDLIBS += -lc
-endif
-
-ifneq ($(APP_OBJS)-$(lwip),-y)
-OBJS := $(filter-out $(OBJ_DIR)/daytime.o, $(OBJS))
-endif
-
-$(OBJ_DIR)/$(TARGET)_app.o: $(APP_OBJS) app.lds
-	$(LD) -r -d $(LDFLAGS) -\( $^ -\) $(APP_LDLIBS) --undefined main -o $@
-
-ifneq ($(APP_OBJS),)
-APP_O=$(OBJ_DIR)/$(TARGET)_app.o 
-endif
-
-$(OBJ_DIR)/$(TARGET): links include/list.h $(OBJS) $(APP_O) arch_lib
-	$(LD) $(LDFLAGS) $(LDFLAGS_FINAL) $(HEAD_OBJ) $(APP_O) $(OBJS) $(LDARCHLIB) $(LDLIBS) $(EXTRA_OBJS) -o $@
-	$(OBJCOPY) -w -G $(GLOBAL_PREFIX)* -G _start $@ $@
-	$(OBJDUMP) -S $@ > $@.asm
-	gzip -f -9 -c $@ >$@.gz
-
-# for build mini-os in a specific folder (so that not bother dropbox)
-OBJ_MINIOS=obj-minios
-$(OBJ_MINIOS): 
-	[ -d $@ ] || \
-	for i in $$(cd $(CURDIR) ; find . -type d) ; do \
-                mkdir -p $@/$$i ; \
-	done
-
-
-# we can use #make obj# to gen all objs in obj-mininos dir 
-.PHONY: obj obj-clean
-obj: $(OBJ_MINIOS)
-	$(MAKE) DESTDIR= OBJ_DIR=$(CURDIR)/$<
-	ln -sf ../domain_config $(CURDIR)/$<
-	ln -sf ../../../tools/libxl/xl $(CURDIR)/$</xl-test
-	
-obj-clean:
-	rm -fr $(OBJ_MINIOS)
-
-.PHONY: clean arch_clean
-
-arch_clean:
-	$(MAKE) --directory=$(TARGET_ARCH_DIR) OBJ_DIR=$(OBJ_DIR)/$(TARGET_ARCH_DIR) clean || exit 1;
-
-clean:arch_clean obj-clean
-	for dir in $(addprefix $(OBJ_DIR)/,$(SUBDIRS)); do \
-		rm -f $$dir/*.o $$dir/*.o.*; \
-	done
-	rm -f include/list.h
-	rm -fr include/x86/mini-os
-	rm -f $(OBJ_DIR)/*.o.* $(OBJ_DIR)/*.asm
-	rm -f $(OBJ_DIR)/*.o *~ $(OBJ_DIR)/core $(OBJ_DIR)/$(TARGET).elf $(OBJ_DIR)/$(TARGET).raw $(OBJ_DIR)/$(TARGET) $(OBJ_DIR)/$(TARGET).gz
-	find . $(OBJ_DIR) -type l | xargs rm -f
-	$(RM) $(OBJ_DIR)/lwip.a $(LWO)
-	rm -f tags TAGS
-
-define all_sources
-     ( find . -follow -name SCCS -prune -o -name '*.[chS]' -print )
-endef
-
-.PHONY: cscope
-cscope:
-	$(all_sources) > cscope.files
-	cscope -k -b -q
-    
-.PHONY: tags
-tags:
-	$(all_sources) | xargs ctags
-
-.PHONY: TAGS
-TAGS:
-	$(all_sources) | xargs etags
-
diff -Nru xen-4.2.1-new/extras/mini-os/minios.mk xen-4.2.1/extras/mini-os/minios.mk
--- xen-4.2.1-new/extras/mini-os/minios.mk	2015-10-26 10:34:49.415010001 +0800
+++ xen-4.2.1/extras/mini-os/minios.mk	2012-12-17 23:00:05.000000000 +0800
@@ -6,7 +6,7 @@
 
 # Define some default flags.
 # NB. '-Wcast-qual' is nasty, so I omitted it.
-DEF_CFLAGS += -fno-builtin -Wall -Wredundant-decls -Wno-format -Wno-redundant-decls
+DEF_CFLAGS += -fno-builtin -Wall -Werror -Wredundant-decls -Wno-format -Wno-redundant-decls
 DEF_CFLAGS += $(call cc-option,$(CC),-fno-stack-protector,)
 DEF_CFLAGS += $(call cc-option,$(CC),-fgnu89-inline)
 DEF_CFLAGS += -Wstrict-prototypes -Wnested-externs -Wpointer-arith -Winline
@@ -16,12 +16,12 @@
 DEF_LDFLAGS +=
 
 ifeq ($(debug),y)
-DEF_CFLAGS += -O3 
+DEF_CFLAGS += -g
 #DEF_CFLAGS += -DMM_DEBUG
 #DEF_CFLAGS += -DFS_DEBUG
 #DEF_CFLAGS += -DLIBC_DEBUG
-#DEF_CFLAGS += -DGNT_DEBUG
-#DEF_CFLAGS += -DGNTMAP_DEBUG
+DEF_CFLAGS += -DGNT_DEBUG
+DEF_CFLAGS += -DGNTMAP_DEBUG
 else
 DEF_CFLAGS += -O3
 endif
@@ -67,7 +67,6 @@
 
 $(OBJ_DIR)/%.o: %.c $(HDRS) Makefile $(EXTRA_DEPS)
 	$(CC) $(CFLAGS) $(CPPFLAGS) -c $< -o $@
-	$(CC) $(CFLAGS) $(CPPFLAGS) -E $< -o $@.zym  # c pre processing
 
 $(OBJ_DIR)/%.o: %.S $(HDRS) Makefile $(EXTRA_DEPS)
 	$(CC) $(ASFLAGS) $(CPPFLAGS) -c $< -o $@
diff -Nru xen-4.2.1-new/extras/mini-os/netfront.c xen-4.2.1/extras/mini-os/netfront.c
--- xen-4.2.1-new/extras/mini-os/netfront.c	2015-10-26 10:34:49.415010001 +0800
+++ xen-4.2.1/extras/mini-os/netfront.c	2012-12-17 23:00:05.000000000 +0800
@@ -328,7 +328,6 @@
     printk("net TX ring size %d\n", NET_TX_RING_SIZE);
     printk("net RX ring size %d\n", NET_RX_RING_SIZE);
     init_SEMAPHORE(&dev->tx_sem, NET_TX_RING_SIZE);
-	//printk("1\n");
     for(i=0;i<NET_TX_RING_SIZE;i++)
     {
 	add_id_to_freelist(i,dev->tx_freelist);
@@ -341,23 +340,14 @@
         dev->rx_buffers[i].page = (char*)alloc_page();
     }
 
-	//printk("2\n");
-	//printk("path=%s\n", path);
     snprintf(path, sizeof(path), "%s/backend-id", nodename);
-	//printk("path=%s\n", path);
-	//printk("3\n");
     dev->dom = xenbus_read_integer(path);
-	//printk("55\n");
 #ifdef HAVE_LIBC
-	//printk("56\n");
-    if (thenetif_rx == NETIF_SELECT_RX){
+    if (thenetif_rx == NETIF_SELECT_RX)
         evtchn_alloc_unbound(dev->dom, netfront_select_handler, dev, &dev->evtchn);
-	//	printk("11\n");
-	}
     else
 #endif
         evtchn_alloc_unbound(dev->dom, netfront_handler, dev, &dev->evtchn);
-	//printk("12\n");
 
     txs = (struct netif_tx_sring *) alloc_page();
     rxs = (struct netif_rx_sring *) alloc_page();
@@ -390,21 +380,18 @@
                 dev->tx_ring_ref);
     if (err) {
         message = "writing tx ring-ref";
-		//printk("hello world\n");
         goto abort_transaction;
     }
     err = xenbus_printf(xbt, nodename, "rx-ring-ref","%u",
                 dev->rx_ring_ref);
     if (err) {
         message = "writing rx ring-ref";
-		//printk("5\n");
         goto abort_transaction;
     }
     err = xenbus_printf(xbt, nodename,
                 "event-channel", "%u", dev->evtchn);
     if (err) {
         message = "writing event-channel";
-		//printk("6\n");
         goto abort_transaction;
     }
 
@@ -412,7 +399,6 @@
 
     if (err) {
         message = "writing request-rx-copy";
-		//printk("7\n");
         goto abort_transaction;
     }
 
@@ -420,7 +406,6 @@
     err = xenbus_switch_state(xbt, path, XenbusStateConnected);
     if (err) {
         message = "switching state";
-		//printk("8\n");
         goto abort_transaction;
     }
 
diff -Nru xen-4.2.1-new/extras/mini-os/sched.c xen-4.2.1/extras/mini-os/sched.c
--- xen-4.2.1-new/extras/mini-os/sched.c	2015-10-26 10:34:49.423010001 +0800
+++ xen-4.2.1/extras/mini-os/sched.c	2012-12-17 23:00:05.000000000 +0800
@@ -62,10 +62,6 @@
 static int threads_started;
 
 struct thread *main_thread;
-/*update shared_library thread.*/
-struct thread *update_thread;
-struct thread *lazy_thread;
-
 
 void inline print_runqueue(void)
 {
diff -Nru xen-4.2.1-new/extras/mini-os/test.c xen-4.2.1/extras/mini-os/test.c
--- xen-4.2.1-new/extras/mini-os/test.c	2014-08-28 19:27:59.805009310 +0800
+++ xen-4.2.1/extras/mini-os/test.c	2012-12-17 23:00:05.000000000 +0800
@@ -62,7 +62,7 @@
     for(;;)
     {
         gettimeofday(&tv, NULL);
-        //printk("T(s=%ld us=%ld)\n", tv.tv_sec, tv.tv_usec);
+        printk("T(s=%ld us=%ld)\n", tv.tv_sec, tv.tv_usec);
         msleep(1000);
     }
 }
@@ -187,9 +187,6 @@
 static void blkfront_thread(void *p)
 {
     time_t lasttime = 0;
-    int i;
-    uint64_t sector;
-    struct timeval tv;
 
     blk_dev = init_blkfront(NULL, &blk_info);
     if (!blk_dev)
@@ -213,11 +210,9 @@
         blk_read_sector(blk_info.sectors-1);
     }
 
-    i = 0;
-    while (i < 1) {
-    	i++;
-        sector = rand() % blk_info.sectors;
-
+    while (1) {
+        uint64_t sector = rand() % blk_info.sectors;
+        struct timeval tv;
 #ifdef BLKTEST_WRITE
         if (blk_info.mode == O_RDWR)
             blk_write_sector(sector);
@@ -227,7 +222,7 @@
         blkfront_aio_poll(blk_dev);
         gettimeofday(&tv, NULL);
         if (tv.tv_sec > lasttime + 10) {
-	    printk("%llu (bytes) read, %llu (bytes) write\n", blk_size_read, blk_size_write);
+            printk("%llu read, %llu write\n", blk_size_read, blk_size_write);
             lasttime = tv.tv_sec;
         }
 
@@ -442,7 +437,7 @@
     pcifront_scan(pci_dev, print_pcidev);
 }
 
-__attribute__((weak)) int app_main(start_info_t *si)
+int app_main(start_info_t *si)
 {
     printk("Test main: start_info=%p\n", si);
     create_thread("xenbus_tester", xenbus_tester, si);
